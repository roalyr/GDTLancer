#
# PROJECT: GDTLancer
# MODULE: bridge_systems.gd
# STATUS: [Level 2 - Implementation]
# TRUTH_LINK: TRUTH-GDD-COMBINED-TEXT-MAJOR-CHANGE-frozen-2026.02.13.md Section 7 (Tick Sequence steps 3a–3c), Section 6 (Bridge Systems)
# LOG_REF: 2026-02-13
#

extends Reference

## BridgeSystems: Cross-layer processing that connects Grid data to Agent state.
##
## These systems read from BOTH the Grid Layer and Agent Layer, producing
## effects that bridge the two. Runs after Grid Layer, before Agent Layer
## in the tick sequence (GDD Section 7, Step 3).
##
## Step 3a: Heat Sink — binary overheating check per agent
## Step 3b: Entropy System — hull degradation from sector entropy rate
## Step 3c: Knowledge Refresh — update agent knowledge snapshots


# =============================================================================
# === TICK PROCESSING =========================================================
# =============================================================================

## Processes all Bridge Systems steps for one tick.
##
## @param config  Dictionary — tuning constants.
func process_tick(config: Dictionary) -> void:
	for agent_id in GameState.agents:
		var agent: Dictionary = GameState.agents[agent_id]

		# Skip disabled agents — they are "offline"
		if agent.get("is_disabled", false):
			continue

		var sector_id: String = agent.get("current_sector_id", "")

		# Step 3a: Heat Sink
		_process_heat_sink(agent_id, agent, sector_id, config)

		# Step 3b: Entropy System
		_process_entropy(agent_id, agent, sector_id, config)

		# Step 3c: Knowledge Refresh
		_process_knowledge_refresh(agent_id, agent, sector_id, config)


# =============================================================================
# === STEP 3a: HEAT SINK =====================================================
# =============================================================================

## Binary overheating check for a single agent (Phase 1 stub).
##
## Heat is generated by activity (0 if docked, small constant if in space).
## Dissipation rate scales with the sector's thermal_background_k — cooler
## environments dissipate heat faster (deviation from 300K baseline).
##
## If current_heat_level exceeds the threshold, the agent is flagged as
## overheating (future: triggers penalties or forced cooldown).
func _process_heat_sink(agent_id: String, agent: Dictionary, sector_id: String, config: Dictionary) -> void:
	var heat_generation_in_space: float = config.get("heat_generation_in_space", 0.5)
	var heat_dissipation_base: float = config.get("heat_dissipation_base", 1.0)
	var heat_overheat_threshold: float = config.get("heat_overheat_threshold", 100.0)

	# Phase 1 stub: docked agents generate no heat
	var is_docked: bool = false
	if agent_id == "player":
		is_docked = GameState.player_docked_at != ""
	else:
		# NPCs are considered "docked" if at a station-type sector
		var topology: Dictionary = GameState.world_topology.get(sector_id, {})
		is_docked = topology.get("sector_type", "") in ["hub", "frontier"]

	var heat_generated: float = 0.0 if is_docked else heat_generation_in_space

	# Dissipation: cooler environments dissipate faster
	# thermal_background_k < 300 → better cooling (space is cold)
	# thermal_background_k > 300 → worse cooling (near star)
	var hazards: Dictionary = GameState.world_hazards.get(sector_id, {})
	var thermal_k: float = hazards.get("thermal_background_k", 300.0)
	var cooling_factor: float = max(0.1, (300.0 - thermal_k) / 300.0 + 1.0)
	var dissipation: float = heat_dissipation_base * cooling_factor

	# Update heat level
	var current_heat: float = agent.get("current_heat_level", 0.0)
	current_heat = max(0.0, current_heat + heat_generated - dissipation)
	agent["current_heat_level"] = current_heat

	# Flag overheating (Phase 1: just a warning, no gameplay effect yet)
	if current_heat > heat_overheat_threshold:
		# Future: apply penalties, force cooldown, emit event
		pass


# =============================================================================
# === STEP 3b: ENTROPY SYSTEM ================================================
# =============================================================================

## Applies minimal hull degradation from the sector's local entropy rate (Phase 1 stub).
##
## Combat is the primary damage source. Environmental entropy is a slow bleed
## that creates maintenance demand over long timescales.
## Fleet ships receive a reduced rate (they're in storage/standby).
func _process_entropy(agent_id: String, agent: Dictionary, sector_id: String, config: Dictionary) -> void:
	var entropy_hull_multiplier: float = config.get("entropy_hull_multiplier", 0.1)
	var fleet_entropy_reduction: float = config.get("fleet_entropy_reduction", 0.5)

	# Get sector entropy rate from grid_maintenance
	var maintenance: Dictionary = GameState.grid_maintenance.get(sector_id, {})
	var entropy_rate: float = maintenance.get("local_entropy_rate", 0.001)

	# Apply to active ship (hull_integrity)
	var hull: float = agent.get("hull_integrity", 1.0)
	var degradation: float = entropy_rate * entropy_hull_multiplier
	hull = max(0.0, hull - degradation)
	agent["hull_integrity"] = hull

	# Apply reduced rate to fleet ships
	var fleet_ships: Array = agent.get("fleet_ships", [])
	for i in range(fleet_ships.size()):
		var ship_uid = fleet_ships[i]
		if GameState.assets_ships.has(ship_uid):
			var ship: Resource = GameState.assets_ships[ship_uid]
			# Phase 1: fleet ships are Resource templates, hull tracked on agent
			# For now, fleet damage is a stub — just track that it would happen
			pass

	# Consume small amounts of propellant and energy if not docked (operating costs)
	var is_docked: bool = false
	if agent_id == "player":
		is_docked = GameState.player_docked_at != ""
	else:
		var topology: Dictionary = GameState.world_topology.get(sector_id, {})
		is_docked = topology.get("sector_type", "") in ["hub", "frontier"]

	if not is_docked:
		var propellant_drain: float = config.get("propellant_drain_per_tick", 0.5)
		var energy_drain: float = config.get("energy_drain_per_tick", 0.3)
		agent["propellant_reserves"] = max(0.0, agent.get("propellant_reserves", 0.0) - propellant_drain)
		agent["energy_reserves"] = max(0.0, agent.get("energy_reserves", 0.0) - energy_drain)


# =============================================================================
# === STEP 3c: KNOWLEDGE REFRESH =============================================
# =============================================================================

## Refreshes each agent's known_grid_state for their current sector with actual
## grid data. Other sectors receive a small noise factor (knowledge decay).
##
## Phase 1: Current sector = perfect knowledge. Other sectors = stale data
## with no active noise (timestamps track staleness for future use).
func _process_knowledge_refresh(agent_id: String, agent: Dictionary, sector_id: String, config: Dictionary) -> void:
	var known_grid: Dictionary = agent.get("known_grid_state", {})
	var timestamps: Dictionary = agent.get("knowledge_timestamps", {})
	var knowledge_noise: float = config.get("knowledge_noise_factor", 0.0)  # Phase 1: 0 = no noise

	# Current sector: refresh with exact data
	if sector_id != "":
		known_grid[sector_id] = {
			"dominion": GameState.grid_dominion.get(sector_id, {}).duplicate(true),
			"market": GameState.grid_market.get(sector_id, {}).duplicate(true),
			"stockpiles": GameState.grid_stockpiles.get(sector_id, {}).duplicate(true)
		}
		timestamps[sector_id] = GameState.sim_tick_count

	# Other sectors: apply knowledge decay (Phase 1 stub)
	if knowledge_noise > 0.0:
		for other_sector in known_grid:
			if other_sector == sector_id:
				continue
			# Phase 1 stub: no actual noise applied
			# Future: perturb price_deltas and stockpile values by noise factor
			# proportional to (current_tick - timestamp) * knowledge_noise

	agent["known_grid_state"] = known_grid
	agent["knowledge_timestamps"] = timestamps

--- Start of ./autoload/Constants.gd ---

# File: autoload/Constants.gd
# Autoload Singleton: Constants
# Version: 1.3 - Reverted paths/names for Complete Zone Scene architecture

extends Node

# --- Scene Paths ---
const PLAYER_AGENT_SCENE_PATH = "res://core/agents/player_agent.tscn"
const NPC_AGENT_SCENE_PATH = "res://core/agents/npc_agent.tscn"

# Complete Zone Scene Paths (Self-contained environments with AgentContainer etc.)
const INITIAL_ZONE_SCENE_PATH = "res://scenes/zones/basic_flight_zone.tscn"
# Example future zones:
# const ZONE_ASTEROID_BELT_BETA_PATH = "res://scenes/zones/asteroid_belt_beta.tscn"
# const ZONE_SCRAPYARD_STATION_PATH = "res://scenes/zones/scrapyard_station.tscn"

# Agent Template Resource Paths
const PLAYER_DEFAULT_TEMPLATE_PATH = "res://assets/data/templates/agents/player_default.tres"
const NPC_TRAFFIC_TEMPLATE_PATH = "res://assets/data/templates/agents/npc_traffic_base.tres"

# Base UI Scenes
const MAIN_HUD_SCENE_PATH = "res://core/ui/main_hud.tscn"
const MAIN_MENU_SCENE_PATH = "res://scenes/main_menu/main_menu.tscn"

# --- Common Node Names ---
# Inside main_game_scene.tscn
const CURRENT_ZONE_CONTAINER_NAME = "CurrentZoneContainer" # Node holding the loaded zone instance

# Inside Zone Scenes (e.g., basic_flight_zone.tscn)
const AGENT_CONTAINER_NAME = "AgentContainer" # Child node for housing agents
const AGENT_MODEL_CONTAINER_NAME = "Model"
const ENTRY_POINT_NAMES = ["EntryPointA", "EntryPointB", "EntryPointC"] # Expected Position3D/Spatial nodes

# Inside Agent Scenes (e.g., agent.tscn, npc_agent.tscn)
const AGENT_BODY_NODE_NAME = "AgentBody"     # The KinematicBody root in agent scenes
# MOVEMENT_COMPONENT_NAME removed as component was merged
const AI_CONTROLLER_NODE_NAME = "AIController"
const PLAYER_INPUT_HANDLER_NAME = "PlayerInputHandler"

# --- Core Mechanics Thresholds ---
const ACTION_CHECK_FAIL_THRESHOLD = 10
const ACTION_CHECK_SWC_THRESHOLD = 10
const ACTION_CHECK_CRIT_THRESHOLD = 14

# --- Core Mechanics Parameters ---
const FOCUS_MAX_DEFAULT = 3
const FOCUS_BOOST_PER_POINT = 1

# --- Default Simulation Values ---
const DEFAULT_MAX_MOVE_SPEED = 50.0
const DEFAULT_ACCELERATION = 10.0
const DEFAULT_DECELERATION = 15.0
const DEFAULT_MAX_TURN_SPEED = 2.0

# --- System Defaults (Examples - Used by placeholder systems) ---
const MAX_NPCS_DEFAULT = 10
const SPAWN_INTERVAL_DEFAULT = 2.0
const TRAFFIC_SPEED_MULT_DEFAULT = 0.2
const TARGETING_RAY_LENGTH = 1e4

--- Start of ./autoload/CoreMechanicsAPI.gd ---

# File: autoload/CoreMechanicsAPI.gd
# Autoload Singleton: CoreMechanicsAPI
# Purpose: Provides globally accessible functions for core mechanic resolutions,
#          ensuring consistency across the game.
# Version: 1.0

extends Node

# Random Number Generator for dice rolls
var _rng = RandomNumberGenerator.new()

func _ready():
	# Seed the random number generator once when the game starts
	_rng.randomize()
	print("CoreMechanicsAPI Ready.")

# --- Core Action Resolution ---

# Performs the standard 3d6+Mod Action Check based on passed parameters.
# Returns a Dictionary containing the detailed results of the check.
# - module_modifier: The calculated modifier for the current action context (Skill + Asset Diff).
# - focus_points_spent: How many FP the player chose to spend (0-3) *before* the roll.
# Return Dictionary keys:
#   "roll_total": int (Final result after mods/FP)
#   "dice_sum": int (Result of 3d6 only)
#   "modifier": int (Module modifier passed in)
#   "focus_spent": int (FP spent)
#   "focus_bonus": int (Bonus gained from FP)
#   "result_tier": String ("CritSuccess", "SwC", "Failure")
#   "focus_gain": int (FP gained from this result, usually 1 on Crit)
#   "focus_loss_reset": bool (True if FP should be reset to 0 due to Failure)
func perform_action_check(module_modifier: int, focus_points_spent: int) -> Dictionary:
	# Ensure focus spent is within valid range (0 to Max FP defined in Constants)
	focus_points_spent = clamp(focus_points_spent, 0, Constants.FOCUS_MAX_DEFAULT)

	# --- Roll Dice ---
	var d1 = _rng.randi_range(1, 6)
	var d2 = _rng.randi_range(1, 6)
	var d3 = _rng.randi_range(1, 6)
	var dice_sum = d1 + d2 + d3

	# --- Calculate Bonuses ---
	var focus_bonus = focus_points_spent * Constants.FOCUS_BOOST_PER_POINT

	# --- Calculate Final Roll ---
	var total_roll = dice_sum + module_modifier + focus_bonus

	# --- Determine Outcome Tier & Focus Effects ---
	var result_tier = ""
	var focus_gain = 0
	var focus_loss_reset = false

	if total_roll >= Constants.ACTION_CHECK_CRIT_THRESHOLD:
		result_tier = "CritSuccess"
		focus_gain = 1 # Standard gain on Crit
		focus_loss_reset = false
	elif total_roll >= Constants.ACTION_CHECK_SWC_THRESHOLD: # e.g., 10-13
		result_tier = "SwC" # Success with Complication
		focus_gain = 0
		focus_loss_reset = false
	else: # e.g., < 10
		result_tier = "Failure"
		focus_gain = 0
		focus_loss_reset = true # Standard reset on Failure

	# --- Assemble Results Dictionary ---
	var results = {
		"roll_total": total_roll,
		"dice_sum": dice_sum,
		"modifier": module_modifier,
		"focus_spent": focus_points_spent,
		"focus_bonus": focus_bonus,
		"result_tier": result_tier,
		"focus_gain": focus_gain,
		"focus_loss_reset": focus_loss_reset
	}

	# --- Optional: Emit Global Signal ---
	# If many systems need to react directly to *every* check result,
	# emitting a signal here could be useful later. Requires passing agent + approach.
	# EventBus.emit_signal("action_check_resolved", agent_ref, results, approach_ref)
	# For now, let the calling script handle reactions and FP updates.

	# print("Action Check: %d (3d6=%d, Mod=%d, FP=%d(+%d)) -> %s" % [total_roll, dice_sum, module_modifier, focus_points_spent, focus_bonus, result_tier]) # Debug

	return results


# --- Potential Future Core Mechanic Functions ---

# func update_focus_state(agent_stats_ref, focus_change: int):
#     # Central logic for applying focus gain/loss, respecting cap
#     pass

# func calculate_upkeep_cost(agent_assets_ref):
#     # Central logic for determining periodic WP upkeep cost
#     return 0 # Placeholder WP cost

# func advance_time_clock(agent_stats_ref_or_global, tu_amount: int):
#     # Central logic for adding TU and checking for World Event Tick trigger
#     pass

--- Start of ./autoload/EventBus.gd ---

# File: autoload/EventBus.gd
# Version: 1.0 (Reviewed for Complete Zone Scene Architecture)

extends Node

# --- Game State Signals ---
signal game_loaded(save_data)
# signal game_saving(slot_id)
# signal save_complete(slot_id, success)

# --- Agent Lifecycle Signals ---
# Emitted by WorldManager after agent initialized and added to tree
# init_data parameter is now Dictionary {"template": Res, "overrides": Dict}
signal agent_spawned(agent_body, init_data)
# Emitted by Agent's despawn() method via EventBus BEFORE queue_free
signal agent_despawning(agent_body)
# Emitted by AI Controller via EventBus when destination reached
signal agent_reached_destination(agent_body)
# Emitted by WorldManager after player specifically spawned
signal player_spawned(player_agent_body)

# --- Camera Control Signals ---
# Emitted by systems requesting camera target change
signal camera_set_target_requested(target_node)
# Emitted by input handlers requesting target cycle (KEEPING for potential future use)
signal camera_cycle_target_requested()

# --- Zone Loading Signals ---
# Emitted by WorldManager before unloading current zone instance
signal zone_unloading(zone_node) # zone_node is the root of the scene being unloaded
# Emitted by WorldManager when starting to load a new zone path
signal zone_loading(zone_path) # zone_path is path to the complete zone scene
# Emitted by WorldManager after new zone is instanced, added, container found
# zone_node is root of the new zone instance, agent_container_node is ref inside it
signal zone_loaded(zone_node, zone_path, agent_container_node)

# --- Core Mechanics / Gameplay Events (Placeholders) ---
# signal action_check_resolved(agent_body, result_dictionary, action_approach)
# signal focus_changed(agent_body, new_focus_value)
# signal wealth_changed(agent_body, new_wealth_value)
# signal world_event_tick_triggered()

# --- Goal System Events (Placeholders) ---
# signal goal_progress_updated(agent_body, goal_id, new_progress)
# signal goal_completed(agent_body, goal_id, success_level)

# --- Module Specific Signals (Placeholders - Use sparingly) ---
# signal major_discovery_made(discovery_data)

func _ready():
	print("EventBus Ready.")

--- Start of ./autoload/GameStateManager.gd ---

# File: autoload/GameStateManager.gd
# Autoload Singleton: GameStateManager
# Purpose: Handles saving and loading game state.
# Version: 1.1 - Corrected ProjectSettings.get_setting for Godot 3

extends Node

const SAVE_DIR = "user://savegames/"
const SAVE_FILE_PREFIX = "save_"
const SAVE_FILE_EXT = ".sav" # Godot's variant storage format

func _ready():
	print("GameStateManager Ready.")
	# Ensure save directory exists on startup
	var dir = Directory.new()
	if not dir.dir_exists(SAVE_DIR):
		var err = dir.make_dir_recursive(SAVE_DIR)
		if err != OK:
			printerr("GameStateManager Error: Could not create save directory: ", SAVE_DIR, " Error: ", err)

# --- Save Game ---
# Returns true on success, false on failure
func save_game(slot_id: int) -> bool:
	print("Attempting to save game to slot ", slot_id)
	var save_data = {} # Dictionary to hold all save data

	# --- गैदरिंग डाटा (Gathering Data) ---
	# 1. Player Data
	if is_instance_valid(GlobalRefs.player_agent_body):
		var player_data = {}
		player_data["scene_path"] = Constants.PLAYER_AGENT_SCENE_PATH
		player_data["position_x"] = GlobalRefs.player_agent_body.global_transform.origin.x
		player_data["position_y"] = GlobalRefs.player_agent_body.global_transform.origin.y
		player_data["position_z"] = GlobalRefs.player_agent_body.global_transform.origin.z
		player_data["rotation_basis_cols"] = [
			GlobalRefs.player_agent_body.global_transform.basis.x,
			GlobalRefs.player_agent_body.global_transform.basis.y,
			GlobalRefs.player_agent_body.global_transform.basis.z
		]
		save_data["player_state"] = player_data
	else:
		printerr("Save Error: Player agent body not valid!")
		return false

	# 2. Character System Data (FP, WP, Skills, etc.) - Assumed Placeholder
	if is_instance_valid(GlobalRefs.character_system) and GlobalRefs.character_system.has_method("get_player_save_data"):
		 save_data["character_state"] = GlobalRefs.character_system.get_player_save_data()
	else:
		 print("Save Warning: CharacterSystem missing or no save method. FP/WP/Skills NOT saved.")

	# 3. World State
	var world_data = {}
	if is_instance_valid(GlobalRefs.current_zone):
		world_data["current_zone_path"] = GlobalRefs.current_zone.filename
	else:
		printerr("Save Error: Current zone reference invalid!")
		return false
	# TODO: Add Time Clock Value - Requires Time System/Manager reference
	# world_data["time_clock_tu"] = GlobalRefs.time_manager.get_current_tu()
	save_data["world_state"] = world_data

	# 4. Goal System State - Assumed Placeholder
	# if is_instance_valid(GlobalRefs.goal_system) and GlobalRefs.goal_system.has_method("get_save_data"):
	#     save_data["goal_system_state"] = GlobalRefs.goal_system.get_save_data()

	# 5. Add Metadata
	# *** CORRECTED for Godot 3 ***
	var game_version_setting = ProjectSettings.get_setting("application/config/version")
	var game_version = "0.0.1" # Default version
	if game_version_setting != null:
		game_version = str(game_version_setting) # Ensure it's a string if found
	# *** END CORRECTION ***

	save_data["metadata"] = {
		"save_time": OS.get_unix_time(),
		"game_version": game_version
	}

	# --- Writing File ---
	var file = File.new()
	var path = SAVE_DIR + SAVE_FILE_PREFIX + str(slot_id) + SAVE_FILE_EXT
	var err = file.open(path, File.WRITE)

	if err == OK:
		# Use true for share/compression - valid in Godot 3
		file.store_var(save_data, true)
		file.close()
		print("Game saved successfully to: ", path)
		return true
	else:
		printerr("Error saving game to path: ", path, " Error code: ", err)
		file.close() # Ensure file is closed even on error
		return false

# --- Load Game ---
# Returns true on success, false on failure
func load_game(slot_id: int) -> bool:
	print("Load attempt for slot ", slot_id)
	var path = get_save_slot_path(slot_id)
	print("Load path: ", path)

	var file = File.new()
	if not file.file_exists(path):
		 printerr("Load Error: Save file not found at path!")
		 return false

	print("Load Debug: File exists. Attempting to open...")
	var err = file.open(path, File.READ)
	if err != OK:
		printerr("Load Error: Failed to open file for reading! Error code: ", err)
		return false

	print("Load Debug: File opened. Attempting to get var...")
	# Use true if store_var used true
	var save_data = file.get_var(true)
	var file_err = file.get_error() # Check error *after* operation
	file.close() # Close file immediately

	if file_err != OK:
		printerr("Load Error: Error reading var from file! File Error code: ", file_err)
		return false

	print("Load Debug: Got var. Checking type...")
	if not save_data is Dictionary:
		printerr("Load Error: Save file data is not a Dictionary! Type is: ", typeof(save_data))
		return false

	print("Save file loaded successfully. Applying state...")
	# ... (Placeholder apply logic) ...
	EventBus.emit_signal("game_loaded", save_data)
	return true

	# --- Apply Loaded State ---
	# This section requires careful coordination with scene loading and initialization.
	# It might need to emit signals or use call_deferred extensively.
	# Placeholder logic - assumes this is called from a state where loading is safe (e.g., main menu)

	# 1. Request Zone Load (WorldManager listens for this?) - NEEDS A ROBUST WORKFLOW
	if save_data.has("world_state") and save_data.world_state.has("current_zone_path"):
		var zone_path = save_data.world_state.current_zone_path
		if is_instance_valid(GlobalRefs.world_manager) and GlobalRefs.world_manager.has_method("load_zone"):
			# Ideally, loading should happen via scene transition, not direct call here.
			# For now, just logging. Actual loading needs proper handling.
			print("Load Request: Need to load zone: ", zone_path)
			# GlobalRefs.world_manager.load_zone(zone_path) # Direct call here is usually problematic
			# Need a system to handle scene transition THEN player spawn/restore
			# Emit signal instead? EventBus.emit_signal("load_zone_requested", zone_path, save_data)
		else:
			printerr("Load Error: Cannot request zone load, WorldManager invalid/missing method.")
			return false
	else:
		printerr("Load Error: Save data missing world state or zone path.")
		return false

	# 2. Restore Player State (Should happen AFTER zone is loaded)
	# This logic needs to be triggered *after* the scene transition and player spawn.
	# Placeholder - This should be handled by CharacterSystem reacting to load event or player spawn
	if save_data.has("player_state"):
		var p_state = save_data.player_state
		var p_pos = Vector3(p_state.get("position_x", 0), p_state.get("position_y", 0), p_state.get("position_z", 0))
		var p_basis_cols = p_state.get("rotation_basis_cols", [Vector3.RIGHT, Vector3.UP, Vector3.BACK])
		var p_basis = Basis(p_basis_cols[0], p_basis_cols[1], p_basis_cols[2])
		# Need to apply pos/rot AFTER player is spawned in the new zone.
		print("Load Request: Player should spawn at ", p_pos, " with rotation")

	if save_data.has("character_state"):
		# CharacterSystem should listen for game_loaded or player_spawned signal
		# and apply this data to the player agent
		print("Load Request: Character state needs restore: ", save_data.character_state)
		# GlobalRefs.character_system.load_save_data(save_data.character_state)

	# 3. Restore Time Clock
	# print("Load Request: Time clock needs restore")
	# GlobalRefs.time_manager.load_save_data(...)

	# 4. Restore Goal System State
	# print("Load Request: Goals need restore")
	# GlobalRefs.goal_system.load_save_data(...)

	# 5. Restore Persistent NPCs (Later Phase)

	# 6. Emit signal that load data is ready (systems should listen and apply)
	print("Load Process: Emitting game_loaded signal...")
	EventBus.emit_signal("game_loaded", save_data) # Pass full data

	# IMPORTANT: Returning true here only means the file was read.
	# Actual game state restoration is asynchronous and depends on listeners.
	return true


# --- Helper Functions ---
func get_save_slot_path(slot_id: int) -> String:
	return SAVE_DIR + SAVE_FILE_PREFIX + str(slot_id) + SAVE_FILE_EXT

func save_exists(slot_id: int) -> bool:
	var file = File.new()
	return file.file_exists(get_save_slot_path(slot_id))

# Gets only the metadata part of a save file, if possible
func get_save_metadata(slot_id: int) -> Dictionary:
	var path = get_save_slot_path(slot_id)
	var file = File.new()
	if not file.file_exists(path): return {}
	var err = file.open(path, File.READ)
	if err != OK: return {}
	# Use false here if we ONLY want the top-level dict, not full object parsing
	# Depends if metadata is stored simply at top level
	var data = file.get_var(true)
	file.close()
	if data is Dictionary and data.has("metadata"):
		return data.metadata
	# Try parsing non-shared if metadata is simple? Might fail on complex saves.
	# var file2 = File.new(); file2.open(path, File.READ); var data2 = file2.get_var(false); file2.close()
	# if data2 is Dictionary and data2.has("metadata"): return data2.metadata
	print("Warning: Could not read metadata from save slot ", slot_id)
	return {}

--- Start of ./autoload/GlobalRefs.gd ---

# File: autoload/GlobalRefs.gd
# Autoload Singleton: GlobalRefs
# Purpose: Holds easily accessible references to unique global nodes/managers.
# Nodes register themselves here via setter functions during their _ready() phase.
# Version: 1.0

extends Node

# --- Key Node References ---
# Other scripts access these directly (e.g., GlobalRefs.player_agent_body)
# but should ALWAYS check if is_instance_valid() first!

var player_agent_body = null setget set_player_agent_body
var main_camera = null setget set_main_camera
var world_manager = null setget set_world_manager
var event_system = null setget set_event_system      # If EventSystem is a Node, not Autoload
var goal_system = null setget set_goal_system        # If GoalSystem is a Node
var character_system = null setget set_character_system  # If CharacterSystem is a Node
var asset_system = null setget set_asset_system      # If AssetSystem is a Node
# Add other core system node references as needed...

var current_zone = null setget set_current_zone          # Reference to the root node of the loaded zone scene
var agent_container = null setget set_agent_container    # Reference to the node *within* the zone where agents are parented

func _ready():
	print("GlobalRefs Ready.")
	# This script typically doesn't do much itself, it just holds references set by others.

# --- Setters (Provide controlled way to update references & add validation) ---
# Using setget ensures these are called automatically on assignment.

func set_player_agent_body(new_ref):
	if new_ref == player_agent_body: return # No change
	if new_ref == null or is_instance_valid(new_ref):
		player_agent_body = new_ref
		print("GlobalRefs: Player Agent reference ", "set to ", new_ref.name if new_ref else "null")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Player Agent reference: ", new_ref)

func set_main_camera(new_ref):
	if new_ref == main_camera: return
	if new_ref == null or is_instance_valid(new_ref):
		main_camera = new_ref
		print("GlobalRefs: Main Camera reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Main Camera reference: ", new_ref)

func set_world_manager(new_ref):
	if new_ref == world_manager: return
	if new_ref == null or is_instance_valid(new_ref):
		world_manager = new_ref
		print("GlobalRefs: World Manager reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid World Manager reference: ", new_ref)

func set_event_system(new_ref):
	if new_ref == event_system: return
	if new_ref == null or is_instance_valid(new_ref):
		event_system = new_ref
		print("GlobalRefs: Event System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Event System reference: ", new_ref)

func set_goal_system(new_ref):
	if new_ref == goal_system: return
	if new_ref == null or is_instance_valid(new_ref):
		goal_system = new_ref
		print("GlobalRefs: Goal System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Goal System reference: ", new_ref)

func set_character_system(new_ref):
	if new_ref == character_system: return
	if new_ref == null or is_instance_valid(new_ref):
		character_system = new_ref
		print("GlobalRefs: Character System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Character System reference: ", new_ref)

func set_asset_system(new_ref):
	if new_ref == asset_system: return
	if new_ref == null or is_instance_valid(new_ref):
		asset_system = new_ref
		print("GlobalRefs: Asset System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Asset System reference: ", new_ref)

func set_current_zone(new_ref):
	if new_ref == current_zone: return
	if new_ref == null or is_instance_valid(new_ref):
		current_zone = new_ref
		print("GlobalRefs: Current Zone reference ", "set to ", new_ref.name if new_ref else "null")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Current Zone reference: ", new_ref)

func set_agent_container(new_ref):
	if new_ref == agent_container: return
	if new_ref == null or is_instance_valid(new_ref):
		agent_container = new_ref
		print("GlobalRefs: Agent Container reference ", "set to ", new_ref.name if new_ref else "null")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Agent Container reference: ", new_ref)

# --- Optional: Add simple getter functions if needed ---
# func get_player() -> KinematicBody:
#     return player_agent_body if is_instance_valid(player_agent_body) else null

--- Start of ./core/agents/agent.gd ---

# File: core/agents/agent.gd
# Version: 3.11 - Strict formatting applied (Tabs, Line Length, Expanded Conditionals)

extends KinematicBody

# --- Command Types Enumeration ---
enum CommandType {
	IDLE,         # Drifting, decelerating naturally
	STOPPING,     # Actively braking to a halt
	MOVE_TO,      # Move towards a specific Vector3 position
	MOVE_DIRECTION,# Move continuously in a specific direction vector
	APPROACH,     # Move towards a target node, stopping at a set distance
	ORBIT,        # Attempt to orbit a target node at a set distance
	FLEE,         # Move directly away from a target node
	ALIGN_TO      # Rotate to face a specific direction vector
}

# --- Agent Identification ---
var agent_name: String = "Default Agent"
var faction_id: String = "Neutral"
var template_id: String = "default"

# --- Movement Capabilities ---
var max_move_speed: float = 0.0
var acceleration: float = 0.0
var deceleration: float = 0.0
var brake_strength: float = 0.0
var max_turn_speed: float = 0.0

var interaction_radius: float = 0.0

# --- Constants for Approach ---
const APPROACH_DISTANCE_MULTIPLIER = 1.5
const APPROACH_MIN_DISTANCE = 50.0

# --- Current State ---
var current_velocity: Vector3 = Vector3.ZERO
var _current_command = {} # Set in initialize
var _is_braking: bool = false

# --- Initialization ---
func initialize(template: AgentTemplate, overrides: Dictionary = {}):
	if not template is AgentTemplate:
		printerr("Agent Initialize Error: Invalid template for ", self.name)
		return

	# Load base stats from template, apply overrides
	self.template_id = template.template_id
	var default_name = template.default_agent_name + \
			"_" + str(get_instance_id())
	self.agent_name = overrides.get("name", default_name)
	self.faction_id = overrides.get("faction", template.default_faction_id)
	self.max_move_speed = overrides.get("max_move_speed",
		template.max_move_speed)
	self.acceleration = overrides.get("acceleration",
		template.acceleration)
	self.deceleration = overrides.get("deceleration",
		template.deceleration)
	self.max_turn_speed = overrides.get("max_turn_speed",
		template.max_turn_speed)
	var default_brake = self.deceleration * 1.5
	self.brake_strength = overrides.get("brake_strength", default_brake)
	self.name = self.agent_name # Set Node name
	self.interaction_radius = overrides.get("interaction_radius", template.interaction_radius)

	_set_command_idle() # Start idle
	print(self.name + " initialized template '", self.template_id, "'.")

# --- Godot Lifecycle ---
func _ready():
	add_to_group("Agents")
	set_physics_process(true)

func _physics_process(delta):
	_execute_current_command(delta)
	current_velocity = move_and_slide(current_velocity, Vector3.UP)

# --- Command Execution Logic ---
func _execute_current_command(delta):
	var cmd_type = _current_command.get("type", CommandType.IDLE)
	var target_node = _current_command.get("target_node", null)

	# Validate target node if required by the command type
	var is_target_cmd = cmd_type in [CommandType.APPROACH,
			CommandType.ORBIT, CommandType.FLEE]
	if is_target_cmd:
		if not is_instance_valid(target_node):
			command_stop()
			cmd_type = _current_command.get("type", CommandType.STOPPING)

	# Execute logic based on command type
	match cmd_type:
		CommandType.IDLE:
			_apply_deceleration(delta)

		CommandType.STOPPING:
			var stopped = _apply_braking(delta)
			if stopped:
				print(agent_name, ": Stopped. Emitting agent_reached_destination.")
				EventBus.emit_signal("agent_reached_destination", self)
				_set_command_idle()

		CommandType.MOVE_TO:
			var target_pos = _current_command.target_pos
			var vector_to_target = target_pos - global_transform.origin
			var distance_sq = vector_to_target.length_squared()
			var stopping_dist_sq = pow(10.0, 2) # Example

			if distance_sq < stopping_dist_sq:
				command_stop()
			else:
				var direction = vector_to_target.normalized()
				_apply_rotation(delta, direction)
				_apply_acceleration(delta, direction)

		CommandType.MOVE_DIRECTION:
			var move_dir = _current_command.get("target_dir", Vector3.ZERO)
			if move_dir.length_squared() > 0.001:
				# Optional: Align to move direction?
				_apply_rotation(delta, move_dir)
				_apply_acceleration(delta, move_dir)
			else:
				# Invalid direction, slow down
				_apply_deceleration(delta)

		CommandType.APPROACH:
			if not is_instance_valid(target_node):
				# Target check again inside case for safety
				command_stop()
				return

			var target_pos = target_node.global_transform.origin
			var target_radius = _get_target_effective_radius(target_node)
			var desired_stop_dist = max(APPROACH_MIN_DISTANCE,
					target_radius * APPROACH_DISTANCE_MULTIPLIER)
			var upper_bound = desired_stop_dist * 1.10
			var lower_bound = desired_stop_dist

			var current_pos = global_transform.origin
			var vector_to_target = target_pos - current_pos
			var distance = vector_to_target.length()
			var direction = Vector3.ZERO
			if distance > 0.01:
				direction = vector_to_target / distance

			_apply_rotation(delta, direction) # Always face target

			if distance > upper_bound:
				_apply_acceleration(delta, direction)
			elif distance <= lower_bound:
				# print(agent_name, " APPROACH: Reached target distance.")
				command_stop()
			else: # Within tolerance band
				_apply_deceleration(delta)

		CommandType.ORBIT:
			if not is_instance_valid(target_node):
				command_stop()
				return

			var target_pos = target_node.global_transform.origin
			var orbit_dist = _current_command.distance
			var vector_to_target = target_pos - global_transform.origin
			var distance = vector_to_target.length()
			var direction_to_target = -global_transform.basis.z
			if distance > 0.01:
				direction_to_target = vector_to_target / distance

			_apply_rotation(delta, direction_to_target)

			var target_up = Vector3.UP
			if target_node is Spatial:
				target_up = target_node.global_transform.basis.y
			var tangent_dir = direction_to_target.cross(target_up).normalized()

			var speed_factor = 1.0
			if distance < orbit_dist * 0.95:
				speed_factor = 0.7
			elif distance > orbit_dist * 1.05:
				speed_factor = 1.0
			_apply_acceleration(delta, tangent_dir * speed_factor)

		CommandType.FLEE:
			if not is_instance_valid(target_node):
				command_stop() # Or switch to IDLE? Stop seems safer.
				return

			var target_pos = target_node.global_transform.origin
			var vector_away = global_transform.origin - target_pos
			var direction_away = -global_transform.basis.z
			if vector_away.length_squared() > 0.01:
				direction_away = vector_away.normalized()

			_apply_rotation(delta, direction_away)
			_apply_acceleration(delta, direction_away)

		CommandType.ALIGN_TO:
			var target_dir = _current_command.target_dir
			_apply_rotation(delta, target_dir)
			_apply_deceleration(delta)
			var current_fwd = -global_transform.basis.z
			if current_fwd.dot(target_dir) > 0.998:
				_set_command_idle()


# --- Internal Movement Helpers ---
func _apply_acceleration(delta, direction):
	if direction.length_squared() < 0.001:
		_apply_deceleration(delta)
		return
	var target_velocity = direction.normalized() * max_move_speed
	current_velocity = current_velocity.linear_interpolate(
		target_velocity,
		acceleration * delta
	)
	_is_braking = false

func _apply_deceleration(delta):
	current_velocity = current_velocity.linear_interpolate(
		Vector3.ZERO,
		deceleration * delta
	)
	_is_braking = false

func _apply_braking(delta) -> bool:
	current_velocity = current_velocity.linear_interpolate(
		Vector3.ZERO,
		brake_strength * delta
	)
	_is_braking = true
	return current_velocity.length_squared() < 0.5

func _apply_rotation(delta, target_look_dir):
	if target_look_dir.length_squared() < 0.001:
		return

	var target_dir = target_look_dir.normalized()
	var current_transform = global_transform
	var current_basis = current_transform.basis

	var up_vector = Vector3.UP
	if abs(target_dir.dot(Vector3.UP)) > 0.999:
		up_vector = Vector3.FORWARD

	var look_at_transform = Transform(Basis(), Vector3.ZERO).looking_at(
		target_dir,
		up_vector
	)
	var target_basis = look_at_transform.basis

	current_basis = current_basis.orthonormalized()
	target_basis = target_basis.orthonormalized()

	if current_basis.is_equal_approx(target_basis):
		return

	if max_turn_speed > 0.001:
		var turn_step = max_turn_speed * delta
		var new_basis = current_basis.slerp(target_basis, turn_step)
		global_transform.basis = new_basis
		
# --- Public Getter for Radius ---
func get_interaction_radius() -> float:
	return interaction_radius

# --- Target Size Helper ---
func _get_target_effective_radius(target_node: Spatial) -> float:
	var longest_half_extent = 1.0 # Minimum radius default
	var default_radius = 25.0     # Fallback if nothing found
	var shape_found = false

	if not is_instance_valid(target_node):
		return default_radius

	if target_node.has_method("get_interaction_radius"):
		return max(target_node.get_interaction_radius(), 1.0)

	if target_node.get_child_count() > 0:
		for child in target_node.get_children():
			if child is CollisionShape and is_instance_valid(child.shape):
				var shape = child.shape
				if shape is SphereShape:
					longest_half_extent = shape.radius
					shape_found = true
					break
				elif shape is BoxShape:
					longest_half_extent = shape.extents.max_axis()
					shape_found = true
					break
				elif shape is CapsuleShape:
					longest_half_extent = max(shape.radius, shape.height / 2.0)
					shape_found = true
					break
				elif shape is CylinderShape:
					longest_half_extent = max(shape.radius, shape.height / 2.0)
					shape_found = true
					break

	if not shape_found and target_node.get_child_count() > 0:
		for child in target_node.get_children():
			if child is MeshInstance and is_instance_valid(child.mesh):
				var aabb = child.mesh.get_aabb()
				longest_half_extent = aabb.get_longest_axis_size() / 2.0
				shape_found = true
				# print("Warning: Using Mesh AABB for target radius") # Optional
				break

	if not shape_found:
		# print("Warning: Using default radius for target") # Optional
		return default_radius

	return max(longest_half_extent, 1.0)


# --- Public Command Methods ---
func command_stop():
	_current_command = { "type": CommandType.STOPPING }

func command_move_to(position: Vector3):
	_current_command = { "type": CommandType.MOVE_TO, "target_pos": position }

func command_move_direction(direction: Vector3):
	if direction.length_squared() < 0.001:
		printerr("MoveDirection command: Invalid direction vector.")
		command_stop()
		return
	_current_command = {
		"type": CommandType.MOVE_DIRECTION,
		"target_dir": direction.normalized()
	}

func command_approach(target: Spatial): # Removed distance arg
	if not is_instance_valid(target):
		printerr("Approach command: Invalid target node.")
		return
	_current_command = {
		"type": CommandType.APPROACH,
		"target_node": target
	}

func command_orbit(target: Spatial, distance: float):
	if not is_instance_valid(target):
		printerr("Orbit command: Invalid target node.")
		return
	_current_command = {
		"type": CommandType.ORBIT,
		"target_node": target,
		"distance": max(10.0, distance)
	}

func command_flee(target: Spatial): # Renamed from keep_at_range
	if not is_instance_valid(target):
		printerr("Flee command: Invalid target node.")
		return
	_current_command = {
		"type": CommandType.FLEE,
		"target_node": target
	}

func command_align_to(direction: Vector3):
	if direction.length_squared() < 0.001:
		printerr("AlignTo command: Invalid direction vector.")
		return
	_current_command = {
		"type": CommandType.ALIGN_TO,
		"target_dir": direction.normalized()
	}

# Internal helper
func _set_command_idle():
	var last_look = -global_transform.basis.z
	# Expanded if
	if _current_command and "target_dir" in _current_command:
		last_look = _current_command.target_dir
	_current_command = { "type": CommandType.IDLE, "target_dir": last_look }
	_is_braking = false

# --- Despawn ---
func despawn():
	print("Agent ", self.name, " despawning...")
	EventBus.emit_signal("agent_despawning", self)
	queue_free()

# --- Placeholders ---
# ...

--- Start of ./core/agents/agent_template.gd ---

# File: core/agents/agent_template.gd
# Resource Definition for Agent Stats/Config
# Version: 1.0

extends Resource
class_name AgentTemplate # Allows type hinting and creating this resource type in editor

# --- Identification ---
export var template_id : String = "default_template" # Unique ID for this template type
export var default_agent_name : String = "Agent"     # Base name for agents using this
export var default_faction_id : String = "Neutral"   # Default faction

# --- Base Movement Capabilities (Reads defaults from Constants) ---
export var max_move_speed : float = Constants.DEFAULT_MAX_MOVE_SPEED
export var acceleration : float = Constants.DEFAULT_ACCELERATION
export var deceleration : float = Constants.DEFAULT_DECELERATION
export var max_turn_speed : float = Constants.DEFAULT_MAX_TURN_SPEED

# --- Interaction Size ---
# Used by camera targeting, docking, etc. Represents effective size.
export var interaction_radius : float = 15.0 # Default reasonable size

# --- Base Combat Stats (Placeholders - Link to Combat Module/Character System later) ---
# export var base_hull : int = 100
# export var base_shields : int = 0

# --- Base Skills (Placeholders - Link to Character System later) ---
# These represent the inherent skill level associated with this *type* of agent
# export var base_piloting_skill : int = 0
# export var base_tech_skill : int = 0
# export var base_social_skill : int = 0

# --- AI Behavior Hint (Optional) ---
# export var default_ai_behavior : String = "idle" # Hint for AI controller selection/init

# --- Visuals / Asset Links (Placeholders) ---
# Optional: Could link to default ship model path, visual effects, etc.
# export (String, FILE, "*.tscn,*.glb,*.gltf") var default_model_path = ""

--- Start of ./core/systems/asset_system.gd ---

extends Node


# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/character_system.gd ---

extends Node


# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/chronicle_system.gd ---

extends Node


# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/event_system.gd ---

extends Node


# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/goal_system.gd ---

extends Node


# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/progression_system.gd ---

extends Node


# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/traffic_system_placeholder.gd ---

extends Node


# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/world_map_system.gd ---

extends Node


# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./modules/piloting/scripts/player_controller_ship.gd ---

# File: modules/piloting/scripts/player_controller_ship.gd
# Version 2.8 - Added Double-Click Move To command

extends Node

# --- References ---
var agent_script: Node = null
var agent_body: KinematicBody = null

# --- State ---
var _target_under_cursor: Spatial = null
var _selected_target: Spatial = null

# --- Constants ---
const DEFAULT_ORBIT_DIST = 3000.0
# Distance to project Move To command when double-clicking empty space
const DEFAULT_MOVE_TO_PROJECTION_DIST = 1e6

# --- Initialization ---
func _ready():
	var parent = get_parent()
	if parent is KinematicBody and parent.has_method("command_stop"):
		agent_body = parent
		agent_script = parent
		print("Player Controller ready for: ", agent_script.agent_name)
		call_deferred("_find_camera_raycast_workaround") # Using workaround name
		Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
	else:
		printerr("Player Controller Error: Parent invalid or missing command methods!")
		set_physics_process(false)
		set_process_input(false)
		return

# Workaround: Camera might not have RayCast immediately in _ready via GlobalRefs
# This waits a frame, then tries to get it. A signal-based approach might be better later.
func _find_camera_raycast_workaround():
	yield(get_tree(), "idle_frame") # Wait one frame
	if is_instance_valid(GlobalRefs.main_camera):
		# We removed the RayCast node dependency, this function is no longer needed
		# _camera_raycast = GlobalRefs.main_camera.get_node_or_null("TargetRayCast")
		# if not is_instance_valid(_camera_raycast):
		#	 printerr("Player Controller Error: Could not find 'TargetRayCast' on Main Camera!")
		pass # No RayCast node needed now
	else:
		printerr("Player Controller Error: Could not find Main Camera in GlobalRefs.")


# --- Physics Update ---
func _physics_process(delta):
	# Only update target under cursor if mouse is visible (for selection/clicks)
	if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE:
		_update_target_under_cursor()
	else:
		_target_under_cursor = null


func _update_target_under_cursor():
	_target_under_cursor = null
	if not is_instance_valid(agent_body): # Need agent to get world
		return
	var camera = get_viewport().get_camera()
	if not is_instance_valid(camera):
		return

	var mouse_pos = get_viewport().get_mouse_position()
	var ray_origin = camera.project_ray_origin(mouse_pos)
	var ray_normal = camera.project_ray_normal(mouse_pos)
	var ray_length = Constants.TARGETING_RAY_LENGTH
	var ray_end = ray_origin + ray_normal * ray_length

	var space_state = agent_body.get_world().direct_space_state
	var collision_mask = 1 # Layer 1 -> "targetable"
	var exclude_array = [agent_body]

	var result = space_state.intersect_ray(ray_origin, ray_end,
			exclude_array, collision_mask)

	if result:
		if result.collider is Spatial:
			_target_under_cursor = result.collider
			# TODO: Highlight _target_under_cursor


# --- Input Event Handling ---
func _unhandled_input(event):
	var input_handled = false

	# --- Mouse Button Input ---
	if event is InputEventMouseButton:
		if event.button_index == BUTTON_LEFT and event.pressed:
			# Check for double-click FIRST
			if event.doubleclick:
				# --- Double Click Handling (Move To Point) ---
				if is_instance_valid(agent_script):
					var camera = get_viewport().get_camera()
					if is_instance_valid(camera):
						var mouse_pos = event.position
						var ray_origin = camera.project_ray_origin(mouse_pos)
						var ray_normal = camera.project_ray_normal(mouse_pos)
						# Calculate point some distance along ray
						var target_point = ray_origin + \
								ray_normal * DEFAULT_MOVE_TO_PROJECTION_DIST
						print("Input: Double-Click Move To ", target_point)
						agent_script.command_move_to(target_point)
						input_handled = true
					else:
						print("Move To Failed: Camera invalid")
				else:
					print("Move To Failed: Agent invalid")
			else:
				# --- Single Click Handling (Target Selection) ---
				# Only process if mouse is visible
				if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE:
					if is_instance_valid(_target_under_cursor):
						if _selected_target != _target_under_cursor:
							_selected_target = _target_under_cursor
							print("Player selected target: ", _selected_target.name)
					elif not is_instance_valid(_target_under_cursor): # Clicked empty space
						if is_instance_valid(_selected_target):
							print("Player de-selected target.")
							_selected_target = null
					input_handled = true # Consume single click as well

	# --- Keyboard Commands & Mouse Toggle ---
	if not input_handled and is_instance_valid(agent_script): # Process only if mouse didn't handle it
		var command_action_key = ""
		if Input.is_action_just_pressed("command_approach"): command_action_key = "approach"
		elif Input.is_action_just_pressed("command_orbit"): command_action_key = "orbit"
		elif Input.is_action_just_pressed("command_flee"): command_action_key = "flee"
		elif Input.is_action_just_pressed("command_stop"): command_action_key = "stop"
		elif Input.is_action_just_pressed("command_move_direction"): command_action_key = "move_direction"
		elif Input.is_action_just_pressed("toggle_mouse_capture"): command_action_key = "toggle_mouse"

		if command_action_key != "":
			input_handled = true # Assume handled unless check fails

			match command_action_key:
				"approach", "orbit", "flee":
					if is_instance_valid(_selected_target):
						match command_action_key:
							"approach": agent_script.command_approach(_selected_target)
							"orbit": agent_script.command_orbit(_selected_target, DEFAULT_ORBIT_DIST)
							"flee": agent_script.command_flee(_selected_target)
						print("Command Input: ", command_action_key.to_upper()," ", _selected_target.name)
					else:
						print("Command Input: ", command_action_key," failed - no target.")
						input_handled = false
				"stop":
					print("Command Input: STOP"); agent_script.command_stop()
				"move_direction":
					if is_instance_valid(GlobalRefs.main_camera):
						var move_dir = -GlobalRefs.main_camera.global_transform.basis.z.normalized()
						print("Command Input: MOVE_DIRECTION ", move_dir); agent_script.command_move_direction(move_dir)
					else: print("Command Input: MoveDirection fail - camera invalid."); input_handled = false
				"toggle_mouse":
					if Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED: Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
					else: Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)
				_:
					input_handled = false # Unhandled action key

	# Consume event if handled
	if input_handled:
		get_viewport().set_input_as_handled()

--- Start of ./modules/piloting/scripts/ship_controller_ai.gd ---

# File: modules/piloting/scripts/ship_controller_ai.gd
# Attach to Node child of AgentBody in npc_agent.tscn
# Version 2.1 - Simplified for agent command execution model

extends Node

# --- References ---
# Set in _ready()
var agent_script: Node = null # Reference to the parent agent.gd script instance

# --- Initialization ---
func _ready():
	# Get reference to parent agent script
	var parent = get_parent()
	# Check if parent is the correct type and has the command methods
	if parent is KinematicBody and parent.has_method("command_move_to"):
		agent_script = parent
		# print("AI Controller ready for: ", agent_script.agent_name) # Optional Debug
	else:
		printerr("AI Controller Error: Parent node is not an Agent KinematicBody with command methods!")
		# If setup fails, this controller can't function.
		# We can disable physics process (though it's empty now)
		# or even detach the script to prevent errors.
		set_physics_process(false)
		set_script(null) # Detach script if parent is wrong

# Called by WorldManager's spawn_agent function (via initialize dictionary in agent.gd)
# The 'config' dictionary here is the 'overrides' passed to spawn_agent
func initialize(config: Dictionary):
	# Ensure agent script reference is valid before issuing command
	if not is_instance_valid(agent_script):
		printerr("AI Initialize Error: Agent script invalid. Cannot issue command.")
		return

	# Read necessary parameters from config dictionary if present
	var stopping_dist = config.get("stopping_distance", 10.0) # May not be needed by AI now
	# TODO: Agent's MOVE_TO command should probably use its own internal stopping distance logic

	# Immediately issue the initial command based on 'initial_target' in config
	if config.has("initial_target") and config.initial_target is Vector3:
		var target_pos = config.initial_target
		print(agent_script.agent_name, " AI issuing command: MOVE_TO ", target_pos)
		# Call the command method on the agent script
		agent_script.command_move_to(target_pos)
	else:
		# If no target, the agent remains IDLE (its default state)
		if is_instance_valid(agent_script): # Check again just in case
			 print("AI Controller Warning: No initial target provided for ",
					agent_script.agent_name, ". Agent will remain idle.")


# --- No Physics Update Needed ---
# For this simple "go-to" AI, the agent itself executes the command issued
# during initialize. This controller doesn't need to do anything frame-by-frame.
# More complex AI would have state machines here, checking conditions and
# issuing different commands (approach, orbit, flee, etc.) as needed.
# func _physics_process(delta):
#     pass


# --- No Event Handling Needed Here ---
# The agent itself now emits "agent_reached_destination" via EventBus
# when its relevant command (MOVE_TO -> STOPPING -> IDLE) completes.
# WorldManager listens for that signal to trigger the despawn.
# func _handle_target_reached(): # Removed
# func _on_Agent_Reached_Destination(agent_body): # Removed

# --- No Public Functions Needed Here ---
# func set_target(new_target: Vector3): # Removed - command issued once at init

--- Start of ./scenes/camera/orbit_camera.gd ---

# File: scenes/camera/orbit_camera.gd
# Version 1.20 - Simplified radius calc uses target method, Strict Formatting

extends Camera

# --- Configuration ---
var distance: float = 55.0        # Fallback/preferred distance basis
var min_distance_multiplier: float = 1.8
var max_distance_multiplier: float = 15.0
var preferred_distance_multiplier: float = 2.5
const MIN_ABSOLUTE_DISTANCE = 8.0
const MAX_ABSOLUTE_DISTANCE = 500.0
var zoom_speed: float = 1.5
var rotation_speed: float = 0.008
var pitch_min: float = -1.45
var pitch_max: float = 1.45
var position_smoothing_speed: float = 15.0
var rotation_smoothing_speed: float = 10.0
var bob_frequency: float = 0.6
var bob_amplitude: float = 0.06

# --- Internal State ---
var _target: Spatial = null
var _target_radius: float = 15.0
var _yaw: float = PI
var _pitch: float = 0.25
var _current_distance: float = 55.0
var _is_player_rotating: bool = false
var _bob_timer: float = 0.0

# --- Initialization ---
func _ready():
	_current_distance = distance
	_yaw = PI
	_pitch = 0.25
	set_as_toplevel(true)
	GlobalRefs.main_camera = self

	if EventBus:
		if not EventBus.is_connected("camera_set_target_requested", self,
				"_on_Camera_Set_Target_Requested"):
			var err = EventBus.connect("camera_set_target_requested", self,
					"_on_Camera_Set_Target_Requested")
			if err != OK:
				printerr("Camera Error: Failed connect signal! Code: ", err)
	else:
		printerr("Camera Error: EventBus not available!")

	# Proactive Check for player
	if not is_instance_valid(_target):
		if is_instance_valid(GlobalRefs.player_agent_body):
			set_target_node(GlobalRefs.player_agent_body)

func initialize(config: Dictionary):
	if config.has("distance"):
		self.distance = config.distance
	if config.has("min_distance_multiplier"):
		self.min_distance_multiplier = config.min_distance_multiplier
	if config.has("max_distance_multiplier"):
		self.max_distance_multiplier = config.max_distance_multiplier
	if config.has("preferred_distance_multiplier"):
		self.preferred_distance_multiplier = config.preferred_distance_multiplier
	if config.has("zoom_speed"):
		self.zoom_speed = config.zoom_speed
	if config.has("rotation_speed"):
		self.rotation_speed = config.rotation_speed
	if config.has("pitch_min_deg"):
		self.pitch_min = deg2rad(config.pitch_min_deg)
	if config.has("pitch_max_deg"):
		self.pitch_max = deg2rad(config.pitch_max_deg)
	if config.has("position_smoothing_speed"):
		self.position_smoothing_speed = config.position_smoothing_speed
	if config.has("rotation_smoothing_speed"):
		self.rotation_smoothing_speed = config.rotation_smoothing_speed
	if config.has("bob_frequency"):
		self.bob_frequency = config.bob_frequency
	if config.has("bob_amplitude"):
		self.bob_amplitude = config.bob_amplitude

	self._yaw = deg2rad(config.get("initial_yaw_deg", 180.0))
	self._pitch = clamp(deg2rad(config.get("initial_pitch_deg", 15.0)),
			pitch_min, pitch_max)
	_current_distance = self.distance
	print("OrbitCamera initialized.")


# --- Input Handling ---
func _unhandled_input(event):
	# Track RMB state
	if event is InputEventMouseButton:
		if event.button_index == BUTTON_RIGHT:
			_is_player_rotating = event.pressed

	# Rotation Input (RMB Drag)
	if event is InputEventMouseMotion:
		if _is_player_rotating:
			_yaw -= event.relative.x * rotation_speed
			_pitch += event.relative.y * rotation_speed
			_pitch = clamp(_pitch, pitch_min, pitch_max)
			get_viewport().set_input_as_handled()

	# Zoom Input (Wheel) - Only works when attached
	if is_instance_valid(_target):
		if event is InputEventMouseButton:
			var dyn_min_dist = max(MIN_ABSOLUTE_DISTANCE,
					_target_radius * min_distance_multiplier)
			var dyn_max_calc = max(dyn_min_dist + 1.0,
					_target_radius * max_distance_multiplier)
			var dyn_max_dist = min(MAX_ABSOLUTE_DISTANCE, dyn_max_calc)

			var zoom_factor = 1.0 + (zoom_speed * 0.1)
			var input_handled = false

			if event.button_index == BUTTON_WHEEL_UP and event.pressed:
				_current_distance = max(dyn_min_dist,
						_current_distance / zoom_factor)
				input_handled = true
			elif event.button_index == BUTTON_WHEEL_DOWN and event.pressed:
				_current_distance = min(dyn_max_dist,
						_current_distance * zoom_factor)
				input_handled = true

			if input_handled:
				get_viewport().set_input_as_handled()


# --- Physics Update ---
func _physics_process(delta):
	_bob_timer += delta

	if not is_instance_valid(_target):
		# Detached Mode: Rotate in Place
		var new_basis = Basis()
		new_basis = new_basis.rotated(Vector3.UP, _yaw)
		new_basis = new_basis.rotated(new_basis.x, _pitch)
		global_transform.basis = new_basis.orthonormalized()
		return

	# --- Attached Mode ---
	var target_pos = _target.global_transform.origin

	# Calculate Bobbing Offset
	var bob_offset = global_transform.basis.y * \
			sin(_bob_timer * bob_frequency * TAU) * bob_amplitude

	# Calculate Desired Camera Position
	var camera_basis = Basis()
	camera_basis = camera_basis.rotated(Vector3.UP, _yaw)
	camera_basis = camera_basis.rotated(camera_basis.x, _pitch)
	var position_offset = -camera_basis.z * _current_distance
	var desired_position = target_pos + position_offset + bob_offset

	# Smoothly Interpolate Camera Position
	global_transform.origin = global_transform.origin.linear_interpolate(
			desired_position, position_smoothing_speed * delta)

	# Smoothly Interpolate Look At
	var target_look_transform = global_transform.looking_at(target_pos, Vector3.UP)
	global_transform.basis = global_transform.basis.slerp(
			target_look_transform.basis, rotation_smoothing_speed * delta)


# --- Signal Handler & Public Functions ---
func _on_Camera_Set_Target_Requested(target_node):
	set_target_node(target_node)

func set_target_node(new_target: Spatial):
	if is_instance_valid(new_target):
		if _target != new_target:
			_target = new_target
			# Update target radius using target's own method or default
			_target_radius = _get_target_effective_radius(_target)
			print("OrbitCamera target set to: ", new_target.name,
					" | Eff Radius: ", _target_radius)
			# Reset/Clamp distance based on new target size
			var dyn_min_dist = max(MIN_ABSOLUTE_DISTANCE,
					_target_radius * min_distance_multiplier)
			var dyn_max_calc = max(dyn_min_dist + 1.0,
					_target_radius * max_distance_multiplier)
			var dyn_max_dist = min(MAX_ABSOLUTE_DISTANCE, dyn_max_calc)
			var preferred_dist = max(dyn_min_dist,
					_target_radius * preferred_distance_multiplier)
			_current_distance = clamp(preferred_dist, dyn_min_dist, dyn_max_dist)
			print("  Reset distance to: ", _current_distance)
	else:
		# Target is being cleared
		if _target != null:
			print("OrbitCamera target cleared.")
		_target = null
		_target_radius = 10.0 # Reset to default radius


# --- Target Size Helper ---
# Simplified to primarily rely on the target having get_interaction_radius()
func _get_target_effective_radius(target_node: Spatial) -> float:
	var default_radius = 10.0 # Fallback if method missing or invalid

	if not is_instance_valid(target_node):
		return default_radius

	# Prioritize specific method if target implements it
	if target_node.has_method("get_interaction_radius"):
		var radius = target_node.get_interaction_radius()
		# Validate the returned value
		if radius is float or radius is int:
			if radius > 0.0:
				# Return custom radius, ensuring minimum 1.0
				return max(radius, 1.0)
			else:
				print("Warning: get_interaction_radius returned non-positive value for ",
						target_node.name)
		else:
			print("Warning: get_interaction_radius returned non-numeric value for ",
					target_node.name)
	# else:
	#	 print("Warning: Target ", target_node.name,
	#			 " missing get_interaction_radius(), using default.") # Optional

	# Fallback if method doesn't exist or returns invalid value
	return default_radius


func get_current_target() -> Spatial:
	if is_instance_valid(_target):
		return _target
	else:
		return null

# --- Cleanup ---
func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		if EventBus:
			if EventBus.is_connected("camera_set_target_requested", self,
					"_on_Camera_Set_Target_Requested"):
				EventBus.disconnect("camera_set_target_requested", self,
						"_on_Camera_Set_Target_Requested")
		if GlobalRefs:
			if GlobalRefs.main_camera == self:
				GlobalRefs.main_camera = null

--- Start of ./scenes/game_world/world_manager.gd ---

# File: scenes/game_world/world_manager.gd
# Version 2.3 - Code style cleanup (Tabs, Line Length, If/Else)

extends Node

# --- NodePaths ---
const ACTIVE_MODULE_CONTAINER_PATH = "../" + Constants.CURRENT_ZONE_CONTAINER_NAME

# --- State ---
var current_zone_instance: Node = null
var _spawned_agent_bodies = []
var _player_agent_body: KinematicBody = null

# --- Initialization ---
func _ready():
	GlobalRefs.world_manager = self
	if EventBus:
		var err1 = EventBus.connect("agent_reached_destination", self,
				"_on_Agent_Reached_Destination")
		var err2 = EventBus.connect("agent_despawning", self,
				"_on_Agent_Despawning")
		var err3 = EventBus.connect("zone_loaded", self,
				"_on_Zone_Loaded_WorldManager")
		if err1 != OK or err2 != OK or err3 != OK:
			printerr("WM _ready Error: Failed connect EventBus signals!")
	else:
		printerr("WM _ready Error: EventBus not available!")

	randomize()
	print("WM: 1/13 - _ready started.")
	print("WM _ready Debug: Checking Constant value...")
	print("- Constants.INITIAL_ZONE_SCENE_PATH = '",
			Constants.INITIAL_ZONE_SCENE_PATH, "'")
	print("- Type = ", typeof(Constants.INITIAL_ZONE_SCENE_PATH))

	print("WM: 2/13 - Attempting load_zone...")
	load_zone(Constants.INITIAL_ZONE_SCENE_PATH)
	print("WM: 9/13 - Returned from initial load_zone call.")
	print("WM: 10/13 - _ready finished (Player spawn handled by signal).")


# --- Zone Management ---
func load_zone(zone_scene_path: String):
	print("WM: 3/13 - load_zone starting for path: ", zone_scene_path)

	if not zone_scene_path or zone_scene_path.empty():
		printerr("WM Error: Invalid zone path provided.")
		return

	# 1. Cleanup Previous Zone
	if is_instance_valid(current_zone_instance):
		EventBus.emit_signal("zone_unloading", current_zone_instance)
		_spawned_agent_bodies.clear()
		_player_agent_body = null
		GlobalRefs.player_agent_body = null
		GlobalRefs.current_zone = null
		GlobalRefs.agent_container = null
		current_zone_instance.queue_free()
		current_zone_instance = null

	# 2. Find Parent Container Node
	var parent_node = get_parent()
	if not is_instance_valid(parent_node):
		printerr("WM Error: Could not get valid parent node!")
		return
	var zone_holder = parent_node.get_node_or_null(
			Constants.CURRENT_ZONE_CONTAINER_NAME)

	if not zone_holder:
		printerr("WM Error: Node '", Constants.CURRENT_ZONE_CONTAINER_NAME,
				"' missing as child of parent '", parent_node.name, "'")
		return
	print("WM: 4/13 - Found zone holder: ", zone_holder.name)

	# 3. Load and Instance the Zone Scene
	var zone_scene = load(zone_scene_path)
	if not zone_scene:
		printerr("WM Error: Failed load Zone Scene Resource: ", zone_scene_path)
		return

	current_zone_instance = zone_scene.instance()
	if not current_zone_instance:
		printerr("WM Error: Failed instance Zone Scene: ", zone_scene_path)
		return

	print("WM: 5/13 - Instanced Zone Scene: ", current_zone_instance.name)

	# 4. Add Zone to Tree & Update GlobalRefs for Zone
	zone_holder.add_child(current_zone_instance)
	GlobalRefs.current_zone = current_zone_instance

	# 5. Find Agent Container *within* the Zone & Update GlobalRef
	if not is_instance_valid(current_zone_instance):
		printerr("WM Error: current_zone_instance invalid after add_child?")
		return

	var agent_cont_ref = current_zone_instance.find_node(
			Constants.AGENT_CONTAINER_NAME, true, false)
	GlobalRefs.agent_container = agent_cont_ref
	print("WM: 6/13 - Found Agent Container: ", agent_cont_ref)
	if not agent_cont_ref:
		printerr("WM Warning: Agent container '",
				Constants.AGENT_CONTAINER_NAME, "' not found in zone.")

	# 6. Emit Loaded Signal
	print("WM: 7/13 - Emitting zone_loaded signal.")
	EventBus.emit_signal("zone_loaded", current_zone_instance,
			zone_scene_path, GlobalRefs.agent_container)
	print("WM: 8/13 - load_zone finished.")


# --- Agent Spawning & Management ---
# Called by handler for zone_loaded signal
func spawn_player():
	print("WM: 12/13 - spawn_player called.")
	var container = GlobalRefs.agent_container
	if not is_instance_valid(container):
		printerr("WM spawn_player Error: GlobalRefs.agent_container invalid.")
		return

	var player_template = load(Constants.PLAYER_DEFAULT_TEMPLATE_PATH)
	if not player_template is AgentTemplate:
		printerr("WM Error: Failed load Player AgentTemplate")
		return

	var player_spawn_pos = Vector3.ZERO
	var env_instance = GlobalRefs.current_zone
	if is_instance_valid(env_instance):
		var entry_node = null
		if Constants.ENTRY_POINT_NAMES.size() > 0:
			entry_node = env_instance.find_node(
					Constants.ENTRY_POINT_NAMES[0], true, false)
		if entry_node is Spatial:
			player_spawn_pos = entry_node.global_transform.origin + Vector3(0,5,15)

	var player_overrides = { "name": "PlayerShip", "faction": "Player" }
	_player_agent_body = spawn_agent(Constants.PLAYER_AGENT_SCENE_PATH,
			player_spawn_pos, player_template, player_overrides)

	if is_instance_valid(_player_agent_body):
		GlobalRefs.player_agent_body = _player_agent_body
		EventBus.emit_signal("camera_set_target_requested", _player_agent_body)
		EventBus.emit_signal("player_spawned", _player_agent_body)
	else:
		printerr("WorldManager Error: Failed to spawn player agent body!")
	print("WM: 13/13 - spawn_player finished.")


# Generic function CALLED BY EXTERNAL systems
func spawn_agent(agent_scene_path: String, position: Vector3,
		agent_template: Resource, overrides: Dictionary = {}) -> KinematicBody:

	var container = GlobalRefs.agent_container
	if not is_instance_valid(container):
		printerr("WM Spawn Error: Invalid GlobalRefs.agent_container.")
		return null
	if not agent_template is AgentTemplate:
		printerr("WM Spawn Error: Invalid AgentTemplate Resource.")
		return null
	if not agent_scene_path or agent_scene_path.empty():
		printerr("WM Spawn Error: Invalid scene path.")
		return null

	var agent_scene = load(agent_scene_path)
	if not agent_scene:
		printerr("WM Spawn Error: Failed load agent scene: ", agent_scene_path)
		return null
	var agent_root_instance = agent_scene.instance()
	if not agent_root_instance:
		printerr("WM Spawn Error: Failed instance agent scene!")
		return null

	var agent_node = agent_root_instance.get_node_or_null(
			Constants.AGENT_BODY_NODE_NAME)
	if not agent_node or not agent_node is KinematicBody:
		var error_msg = str("WM Spawn Error: Invalid node '",
				Constants.AGENT_BODY_NODE_NAME, "' in scene: ", agent_scene_path)
		printerr(error_msg)
		agent_root_instance.queue_free()
		return null

	var instance_name = overrides.get("name",
			agent_template.default_agent_name + "_" + str(agent_root_instance.get_instance_id()))
	agent_root_instance.name = instance_name

	container.add_child(agent_root_instance)
	agent_node.global_transform.origin = position

	if agent_node.has_method("initialize"):
		agent_node.initialize(agent_template, overrides)

	_spawned_agent_bodies.append(agent_node)
	var name_to_print = instance_name
	# Expanded check using 'in' for property existence
	if "agent_name" in agent_node:
		name_to_print = agent_node.agent_name
	print("Spawned agent '", name_to_print, "' core node.")

	EventBus.emit_signal("agent_spawned", agent_node,
			{"template": agent_template, "overrides": overrides})

	var controller = agent_node.get_node_or_null(Constants.AI_CONTROLLER_NODE_NAME)
	if controller and controller.has_method("initialize"):
		controller.initialize(overrides)
	elif controller and controller.has_method("set_target") and ("initial_target" in overrides):
		controller.set_target(overrides.initial_target)

	return agent_node


# --- Signal Handlers ---
func _on_Agent_Reached_Destination(agent_body):
	if is_instance_valid(agent_body) and agent_body != _player_agent_body:
		if agent_body.has_method("despawn"):
			agent_body.despawn()
		else:
			agent_body.queue_free() # Fallback
	elif is_instance_valid(agent_body) and agent_body == _player_agent_body:
		pass # Player reached destination, do nothing here


func _on_Agent_Despawning(agent_body):
	call_deferred("_cleanup_despawned_agent_from_list", agent_body)

func _cleanup_despawned_agent_from_list(agent_instance):
	if _spawned_agent_bodies.has(agent_instance):
		_spawned_agent_bodies.erase(agent_instance)
	# Expanded check
	if _player_agent_body == agent_instance:
		print("Player agent reference cleared during cleanup.")
		_player_agent_body = null
		GlobalRefs.player_agent_body = null

func _on_Zone_Loaded_WorldManager(_zone_instance, _zone_path, agent_container_node):
	print("WM: 11/13 - Reacting to zone_loaded signal.")
	if is_instance_valid(agent_container_node):
		if not is_instance_valid(_player_agent_body):
			# Try direct call again now that other issues might be fixed
			spawn_player()
	else:
		printerr("WM _on_Zone_Loaded Error: Agent container invalid. Cannot spawn player.")


# --- Cleanup ---
func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		print("!!! WM: RECEIVED NOTIFICATION_PREDELETE !!!")
		if EventBus:
			# Expanded disconnect checks
			if EventBus.is_connected("agent_reached_destination", self, "_on_Agent_Reached_Destination"):
				EventBus.disconnect("agent_reached_destination", self, "_on_Agent_Reached_Destination")
			if EventBus.is_connected("agent_despawning", self, "_on_Agent_Despawning"):
				EventBus.disconnect("agent_despawning", self, "_on_Agent_Despawning")
			if EventBus.is_connected("zone_loaded", self, "_on_Zone_Loaded_WorldManager"):
				EventBus.disconnect("zone_loaded", self, "_on_Zone_Loaded_WorldManager")
		# Expanded GlobalRefs check
		if GlobalRefs and GlobalRefs.world_manager == self:
			GlobalRefs.world_manager = null
		# Expanded instance check
		if is_instance_valid(current_zone_instance):
			current_zone_instance.queue_free()

--- Start of ./autoload/Constants.gd ---

# File: autoload/Constants.gd
# Autoload Singleton: Constants
# Version: 1.3 - Reverted paths/names for Complete Zone Scene architecture

extends Node

# --- Scene Paths ---
const PLAYER_AGENT_SCENE_PATH = "res://core/agents/player_agent.tscn"
const NPC_AGENT_SCENE_PATH = "res://core/agents/npc_agent.tscn"

# Complete Zone Scene Paths (Self-contained environments with AgentContainer etc.)
const INITIAL_ZONE_SCENE_PATH = "res://scenes/zones/basic_flight_zone.tscn"
# Example future zones:
# const ZONE_ASTEROID_BELT_BETA_PATH = "res://scenes/zones/asteroid_belt_beta.tscn"
# const ZONE_SCRAPYARD_STATION_PATH = "res://scenes/zones/scrapyard_station.tscn"

# Agent Template Resource Paths
const PLAYER_DEFAULT_TEMPLATE_PATH = "res://assets/data/templates/agents/player_default.tres"
const NPC_TRAFFIC_TEMPLATE_PATH = "res://assets/data/templates/agents/npc_traffic.tres"

# Base UI Scenes
const MAIN_HUD_SCENE_PATH = "res://core/ui/main_hud.tscn"
const MAIN_MENU_SCENE_PATH = "res://scenes/main_menu/main_menu.tscn"

# --- Common Node Names ---
# Inside main_game_scene.tscn
const CURRENT_ZONE_CONTAINER_NAME = "CurrentZoneContainer"  # Node holding the loaded zone instance

# Inside Zone Scenes (e.g., basic_flight_zone.tscn)
const AGENT_CONTAINER_NAME = "AgentContainer"  # Child node for housing agents
const AGENT_MODEL_CONTAINER_NAME = "Model"
const ENTRY_POINT_NAMES = ["EntryPointA", "EntryPointB", "EntryPointC"]  # Expected Position3D/Spatial nodes

# Inside Agent Scenes (e.g., agent.tscn, npc_agent.tscn)
const AGENT_BODY_NODE_NAME = "AgentBody"  # The KinematicBody root in agent scenes
# MOVEMENT_COMPONENT_NAME removed as component was merged
const AI_CONTROLLER_NODE_NAME = "AIController"
const PLAYER_INPUT_HANDLER_NAME = "PlayerInputHandler"

# --- Core Mechanics Thresholds ---
const ACTION_CHECK_FAIL_THRESHOLD = 10
const ACTION_CHECK_SWC_THRESHOLD = 10
const ACTION_CHECK_CRIT_THRESHOLD = 14

# --- Core Mechanics Parameters ---
const FOCUS_MAX_DEFAULT = 3
const FOCUS_BOOST_PER_POINT = 1

# --- Default Simulation Values ---
const DEFAULT_MAX_MOVE_SPEED = 300.0 # m/s
const DEFAULT_ACCELERATION = 1.0 # NOT m/s^2
const DEFAULT_DECELERATION = 1.0 # NOT m/s^2
const DEFAULT_MAX_TURN_SPEED = 2.0

# --- Gameplay / Physics Approximations ---
const ORBIT_FULL_SPEED_RADIUS = 2000.0  # Example value (e.g., 5000 units)

# --- System Defaults (Examples - Used by placeholder systems) ---
const MAX_NPCS_DEFAULT = 10
const SPAWN_INTERVAL_DEFAULT = 2.0
const TRAFFIC_SPEED_MULT_DEFAULT = 0.2
const TARGETING_RAY_LENGTH = 1e4

--- Start of ./autoload/CoreMechanicsAPI.gd ---

# File: autoload/CoreMechanicsAPI.gd
# Autoload Singleton: CoreMechanicsAPI
# Purpose: Provides globally accessible functions for core mechanic resolutions,
#          ensuring consistency across the game.
# Version: 1.0

extends Node

# Random Number Generator for dice rolls
var _rng = RandomNumberGenerator.new()


func _ready():
	# Seed the random number generator once when the game starts
	_rng.randomize()
	print("CoreMechanicsAPI Ready.")


# --- Core Action Resolution ---


# Performs the standard 3d6+Mod Action Check based on passed parameters.
# Returns a Dictionary containing the detailed results of the check.
# - module_modifier: The calculated modifier for the current action context (Skill + Asset Diff).
# - focus_points_spent: How many FP the player chose to spend (0-3) *before* the roll.
# Return Dictionary keys:
#   "roll_total": int (Final result after mods/FP)
#   "dice_sum": int (Result of 3d6 only)
#   "modifier": int (Module modifier passed in)
#   "focus_spent": int (FP spent)
#   "focus_bonus": int (Bonus gained from FP)
#   "result_tier": String ("CritSuccess", "SwC", "Failure")
#   "focus_gain": int (FP gained from this result, usually 1 on Crit)
#   "focus_loss_reset": bool (True if FP should be reset to 0 due to Failure)
func perform_action_check(module_modifier: int, focus_points_spent: int) -> Dictionary:
	# Ensure focus spent is within valid range (0 to Max FP defined in Constants)
	focus_points_spent = clamp(focus_points_spent, 0, Constants.FOCUS_MAX_DEFAULT)

	# --- Roll Dice ---
	var d1 = _rng.randi_range(1, 6)
	var d2 = _rng.randi_range(1, 6)
	var d3 = _rng.randi_range(1, 6)
	var dice_sum = d1 + d2 + d3

	# --- Calculate Bonuses ---
	var focus_bonus = focus_points_spent * Constants.FOCUS_BOOST_PER_POINT

	# --- Calculate Final Roll ---
	var total_roll = dice_sum + module_modifier + focus_bonus

	# --- Determine Outcome Tier & Focus Effects ---
	var result_tier = ""
	var focus_gain = 0
	var focus_loss_reset = false

	if total_roll >= Constants.ACTION_CHECK_CRIT_THRESHOLD:
		result_tier = "CritSuccess"
		focus_gain = 1  # Standard gain on Crit
		focus_loss_reset = false
	elif total_roll >= Constants.ACTION_CHECK_SWC_THRESHOLD:  # e.g., 10-13
		result_tier = "SwC"  # Success with Complication
		focus_gain = 0
		focus_loss_reset = false
	else:  # e.g., < 10
		result_tier = "Failure"
		focus_gain = 0
		focus_loss_reset = true  # Standard reset on Failure

	# --- Assemble Results Dictionary ---
	var results = {
		"roll_total": total_roll,
		"dice_sum": dice_sum,
		"modifier": module_modifier,
		"focus_spent": focus_points_spent,
		"focus_bonus": focus_bonus,
		"result_tier": result_tier,
		"focus_gain": focus_gain,
		"focus_loss_reset": focus_loss_reset
	}

	# --- Optional: Emit Global Signal ---
	# If many systems need to react directly to *every* check result,
	# emitting a signal here could be useful later. Requires passing agent + approach.
	# EventBus.emit_signal("action_check_resolved", agent_ref, results, approach_ref)
	# For now, let the calling script handle reactions and FP updates.

	# print("Action Check: %d (3d6=%d, Mod=%d, FP=%d(+%d)) -> %s" % [total_roll, dice_sum, module_modifier, focus_points_spent, focus_bonus, result_tier]) # Debug

	return results

# --- Potential Future Core Mechanic Functions ---

# func update_focus_state(agent_stats_ref, focus_change: int):
#     # Central logic for applying focus gain/loss, respecting cap
#     pass

# func calculate_upkeep_cost(agent_assets_ref):
#     # Central logic for determining periodic WP upkeep cost
#     return 0 # Placeholder WP cost

# func advance_time_clock(agent_stats_ref_or_global, tu_amount: int):
#     # Central logic for adding TU and checking for World Event Tick trigger
#     pass

--- Start of ./autoload/EventBus.gd ---

# File: autoload/EventBus.gd
# Version: 1.1 Added target picking.

extends Node

# --- Game State Signals ---
signal game_loaded(save_data)
# signal game_saving(slot_id)
# signal save_complete(slot_id, success)

# --- Agent Lifecycle Signals ---
# Emitted by WorldManager after agent initialized and added to tree
# init_data parameter is now Dictionary {"template": Res, "overrides": Dict}
signal agent_spawned(agent_body, init_data)
# Emitted by Agent's despawn() method via EventBus BEFORE queue_free
signal agent_despawning(agent_body)
# Emitted by AI Controller via EventBus when destination reached
signal agent_reached_destination(agent_body)
# Emitted by WorldManager after player specifically spawned
signal player_spawned(player_agent_body)

# --- Camera Control Signals ---
# Emitted by systems requesting camera target change
signal camera_set_target_requested(target_node)
# Emitted by input handlers requesting target cycle (KEEPING for potential future use)
signal camera_cycle_target_requested

# --- Player Interaction Signals --- ADDED SECTION
signal player_target_selected(target_node)
signal player_target_deselected
signal player_free_flight_toggled
signal player_stop_pressed
signal player_orbit_pressed
signal player_approach_pressed
signal player_flee_pressed

# --- Zone Loading Signals ---
# Emitted by WorldManager before unloading current zone instance
signal zone_unloading(zone_node)  # zone_node is the root of the scene being unloaded
# Emitted by WorldManager when starting to load a new zone path
signal zone_loading(zone_path)  # zone_path is path to the complete zone scene
# Emitted by WorldManager after new zone is instanced, added, container found
# zone_node is root of the new zone instance, agent_container_node is ref inside it
signal zone_loaded(zone_node, zone_path, agent_container_node)

# --- Core Mechanics / Gameplay Events (Placeholders) ---
# signal action_check_resolved(agent_body, result_dictionary, action_approach)
# signal focus_changed(agent_body, new_focus_value)
# signal wealth_changed(agent_body, new_wealth_value)
# signal world_event_tick_triggered()

# --- Goal System Events (Placeholders) ---
# signal goal_progress_updated(agent_body, goal_id, new_progress)
# signal goal_completed(agent_body, goal_id, success_level)

# --- Module Specific Signals (Placeholders - Use sparingly) ---
# signal major_discovery_made(discovery_data)


func _ready():
	print("EventBus Ready.")

--- Start of ./autoload/GameStateManager.gd ---

# File: autoload/GameStateManager.gd
# Autoload Singleton: GameStateManager
# Purpose: Handles saving and loading game state.
# Version: 1.1 - Corrected ProjectSettings.get_setting for Godot 3

extends Node

const SAVE_DIR = "user://savegames/"
const SAVE_FILE_PREFIX = "save_"
const SAVE_FILE_EXT = ".sav"  # Godot's variant storage format


func _ready():
	print("GameStateManager Ready.")
	# Ensure save directory exists on startup
	var dir = Directory.new()
	if not dir.dir_exists(SAVE_DIR):
		var err = dir.make_dir_recursive(SAVE_DIR)
		if err != OK:
			printerr(
				"GameStateManager Error: Could not create save directory: ",
				SAVE_DIR,
				" Error: ",
				err
			)


# --- Save Game ---
# Returns true on success, false on failure
func save_game(slot_id: int) -> bool:
	print("Attempting to save game to slot ", slot_id)
	var save_data = {}  # Dictionary to hold all save data

	# --- गैदरिंग डाटा (Gathering Data) ---
	# 1. Player Data
	if is_instance_valid(GlobalRefs.player_agent_body):
		var player_data = {}
		player_data["scene_path"] = Constants.PLAYER_AGENT_SCENE_PATH
		player_data["position_x"] = GlobalRefs.player_agent_body.global_transform.origin.x
		player_data["position_y"] = GlobalRefs.player_agent_body.global_transform.origin.y
		player_data["position_z"] = GlobalRefs.player_agent_body.global_transform.origin.z
		player_data["rotation_basis_cols"] = [
			GlobalRefs.player_agent_body.global_transform.basis.x,
			GlobalRefs.player_agent_body.global_transform.basis.y,
			GlobalRefs.player_agent_body.global_transform.basis.z
		]
		save_data["player_state"] = player_data
	else:
		printerr("Save Error: Player agent body not valid!")
		return false

	# 2. Character System Data (FP, WP, Skills, etc.) - Assumed Placeholder
	if (
		is_instance_valid(GlobalRefs.character_system)
		and GlobalRefs.character_system.has_method("get_player_save_data")
	):
		save_data["character_state"] = GlobalRefs.character_system.get_player_save_data()
	else:
		print("Save Warning: CharacterSystem missing or no save method. FP/WP/Skills NOT saved.")

	# 3. World State
	var world_data = {}
	if is_instance_valid(GlobalRefs.current_zone):
		world_data["current_zone_path"] = GlobalRefs.current_zone.filename
	else:
		printerr("Save Error: Current zone reference invalid!")
		return false
	# TODO: Add Time Clock Value - Requires Time System/Manager reference
	# world_data["time_clock_tu"] = GlobalRefs.time_manager.get_current_tu()
	save_data["world_state"] = world_data

	# 4. Goal System State - Assumed Placeholder
	# if is_instance_valid(GlobalRefs.goal_system) and GlobalRefs.goal_system.has_method("get_save_data"):
	#     save_data["goal_system_state"] = GlobalRefs.goal_system.get_save_data()

	# 5. Add Metadata
	# *** CORRECTED for Godot 3 ***
	var game_version_setting = ProjectSettings.get_setting("application/config/version")
	var game_version = "0.0.1"  # Default version
	if game_version_setting != null:
		game_version = str(game_version_setting)  # Ensure it's a string if found
	# *** END CORRECTION ***

	save_data["metadata"] = {"save_time": OS.get_unix_time(), "game_version": game_version}

	# --- Writing File ---
	var file = File.new()
	var path = SAVE_DIR + SAVE_FILE_PREFIX + str(slot_id) + SAVE_FILE_EXT
	var err = file.open(path, File.WRITE)

	if err == OK:
		# Use true for share/compression - valid in Godot 3
		file.store_var(save_data, true)
		file.close()
		print("Game saved successfully to: ", path)
		return true
	else:
		printerr("Error saving game to path: ", path, " Error code: ", err)
		file.close()  # Ensure file is closed even on error
		return false


# --- Load Game ---
# Returns true on success, false on failure
func load_game(slot_id: int) -> bool:
	print("Load attempt for slot ", slot_id)
	var path = get_save_slot_path(slot_id)
	print("Load path: ", path)

	var file = File.new()
	if not file.file_exists(path):
		printerr("Load Error: Save file not found at path!")
		return false

	print("Load Debug: File exists. Attempting to open...")
	var err = file.open(path, File.READ)
	if err != OK:
		printerr("Load Error: Failed to open file for reading! Error code: ", err)
		return false

	print("Load Debug: File opened. Attempting to get var...")
	# Use true if store_var used true
	var save_data = file.get_var(true)
	var file_err = file.get_error()  # Check error *after* operation
	file.close()  # Close file immediately

	if file_err != OK:
		printerr("Load Error: Error reading var from file! File Error code: ", file_err)
		return false

	print("Load Debug: Got var. Checking type...")
	if not save_data is Dictionary:
		printerr("Load Error: Save file data is not a Dictionary! Type is: ", typeof(save_data))
		return false

	print("Save file loaded successfully. Applying state...")
	# ... (Placeholder apply logic) ...
	EventBus.emit_signal("game_loaded", save_data)
	return true

	# --- Apply Loaded State ---
	# This section requires careful coordination with scene loading and initialization.
	# It might need to emit signals or use call_deferred extensively.
	# Placeholder logic - assumes this is called from a state where loading is safe (e.g., main menu)

	# 1. Request Zone Load (WorldManager listens for this?) - NEEDS A ROBUST WORKFLOW
	if save_data.has("world_state") and save_data.world_state.has("current_zone_path"):
		var zone_path = save_data.world_state.current_zone_path
		if (
			is_instance_valid(GlobalRefs.world_manager)
			and GlobalRefs.world_manager.has_method("load_zone")
		):
			# Ideally, loading should happen via scene transition, not direct call here.
			# For now, just logging. Actual loading needs proper handling.
			print("Load Request: Need to load zone: ", zone_path)
			# GlobalRefs.world_manager.load_zone(zone_path) # Direct call here is usually problematic
			# Need a system to handle scene transition THEN player spawn/restore
			# Emit signal instead? EventBus.emit_signal("load_zone_requested", zone_path, save_data)
		else:
			printerr("Load Error: Cannot request zone load, WorldManager invalid/missing method.")
			return false
	else:
		printerr("Load Error: Save data missing world state or zone path.")
		return false

	# 2. Restore Player State (Should happen AFTER zone is loaded)
	# This logic needs to be triggered *after* the scene transition and player spawn.
	# Placeholder - This should be handled by CharacterSystem reacting to load event or player spawn
	if save_data.has("player_state"):
		var p_state = save_data.player_state
		var p_pos = Vector3(
			p_state.get("position_x", 0), p_state.get("position_y", 0), p_state.get("position_z", 0)
		)
		var p_basis_cols = p_state.get(
			"rotation_basis_cols", [Vector3.RIGHT, Vector3.UP, Vector3.BACK]
		)
		var p_basis = Basis(p_basis_cols[0], p_basis_cols[1], p_basis_cols[2])
		# Need to apply pos/rot AFTER player is spawned in the new zone.
		print("Load Request: Player should spawn at ", p_pos, " with rotation")

	if save_data.has("character_state"):
		# CharacterSystem should listen for game_loaded or player_spawned signal
		# and apply this data to the player agent
		print("Load Request: Character state needs restore: ", save_data.character_state)
		# GlobalRefs.character_system.load_save_data(save_data.character_state)

	# 3. Restore Time Clock
	# print("Load Request: Time clock needs restore")
	# GlobalRefs.time_manager.load_save_data(...)

	# 4. Restore Goal System State
	# print("Load Request: Goals need restore")
	# GlobalRefs.goal_system.load_save_data(...)

	# 5. Restore Persistent NPCs (Later Phase)

	# 6. Emit signal that load data is ready (systems should listen and apply)
	print("Load Process: Emitting game_loaded signal...")
	EventBus.emit_signal("game_loaded", save_data)  # Pass full data

	# IMPORTANT: Returning true here only means the file was read.
	# Actual game state restoration is asynchronous and depends on listeners.
	return true


# --- Helper Functions ---
func get_save_slot_path(slot_id: int) -> String:
	return SAVE_DIR + SAVE_FILE_PREFIX + str(slot_id) + SAVE_FILE_EXT


func save_exists(slot_id: int) -> bool:
	var file = File.new()
	return file.file_exists(get_save_slot_path(slot_id))


# Gets only the metadata part of a save file, if possible
func get_save_metadata(slot_id: int) -> Dictionary:
	var path = get_save_slot_path(slot_id)
	var file = File.new()
	if not file.file_exists(path):
		return {}
	var err = file.open(path, File.READ)
	if err != OK:
		return {}
	# Use false here if we ONLY want the top-level dict, not full object parsing
	# Depends if metadata is stored simply at top level
	var data = file.get_var(true)
	file.close()
	if data is Dictionary and data.has("metadata"):
		return data.metadata
	# Try parsing non-shared if metadata is simple? Might fail on complex saves.
	# var file2 = File.new(); file2.open(path, File.READ); var data2 = file2.get_var(false); file2.close()
	# if data2 is Dictionary and data2.has("metadata"): return data2.metadata
	print("Warning: Could not read metadata from save slot ", slot_id)
	return {}

--- Start of ./autoload/GlobalRefs.gd ---

# File: autoload/GlobalRefs.gd
# Autoload Singleton: GlobalRefs
# Purpose: Holds easily accessible references to unique global nodes/managers.
# Nodes register themselves here via setter functions during their _ready() phase.
# Version: 1.0

extends Node

# --- Key Node References ---
# Other scripts access these directly (e.g., GlobalRefs.player_agent_body)
# but should ALWAYS check if is_instance_valid() first!

var player_agent_body = null setget set_player_agent_body
var main_camera = null setget set_main_camera
var world_manager = null setget set_world_manager
var event_system = null setget set_event_system  # If EventSystem is a Node, not Autoload
var goal_system = null setget set_goal_system  # If GoalSystem is a Node
var character_system = null setget set_character_system  # If CharacterSystem is a Node
var asset_system = null setget set_asset_system  # If AssetSystem is a Node
# Add other core system node references as needed...

var current_zone = null setget set_current_zone  # Reference to the root node of the loaded zone scene
var agent_container = null setget set_agent_container  # Reference to the node *within* the zone where agents are parented


func _ready():
	print("GlobalRefs Ready.")
	# This script typically doesn't do much itself, it just holds references set by others.


# --- Setters (Provide controlled way to update references & add validation) ---
# Using setget ensures these are called automatically on assignment.


func set_player_agent_body(new_ref):
	if new_ref == player_agent_body:
		return  # No change
	if new_ref == null or is_instance_valid(new_ref):
		player_agent_body = new_ref
		print("GlobalRefs: Player Agent reference ", "set to ", new_ref.name if new_ref else "null")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Player Agent reference: ", new_ref)


func set_main_camera(new_ref):
	if new_ref == main_camera:
		return
	if new_ref == null or is_instance_valid(new_ref):
		main_camera = new_ref
		print("GlobalRefs: Main Camera reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Main Camera reference: ", new_ref)


func set_world_manager(new_ref):
	if new_ref == world_manager:
		return
	if new_ref == null or is_instance_valid(new_ref):
		world_manager = new_ref
		print("GlobalRefs: World Manager reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid World Manager reference: ", new_ref)


func set_event_system(new_ref):
	if new_ref == event_system:
		return
	if new_ref == null or is_instance_valid(new_ref):
		event_system = new_ref
		print("GlobalRefs: Event System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Event System reference: ", new_ref)


func set_goal_system(new_ref):
	if new_ref == goal_system:
		return
	if new_ref == null or is_instance_valid(new_ref):
		goal_system = new_ref
		print("GlobalRefs: Goal System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Goal System reference: ", new_ref)


func set_character_system(new_ref):
	if new_ref == character_system:
		return
	if new_ref == null or is_instance_valid(new_ref):
		character_system = new_ref
		print("GlobalRefs: Character System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Character System reference: ", new_ref)


func set_asset_system(new_ref):
	if new_ref == asset_system:
		return
	if new_ref == null or is_instance_valid(new_ref):
		asset_system = new_ref
		print("GlobalRefs: Asset System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Asset System reference: ", new_ref)


func set_current_zone(new_ref):
	if new_ref == current_zone:
		return
	if new_ref == null or is_instance_valid(new_ref):
		current_zone = new_ref
		print("GlobalRefs: Current Zone reference ", "set to ", new_ref.name if new_ref else "null")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Current Zone reference: ", new_ref)


func set_agent_container(new_ref):
	if new_ref == agent_container:
		return
	if new_ref == null or is_instance_valid(new_ref):
		agent_container = new_ref
		print(
			"GlobalRefs: Agent Container reference ", "set to ", new_ref.name if new_ref else "null"
		)
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Agent Container reference: ", new_ref)

# --- Optional: Add simple getter functions if needed ---
# func get_player() -> KinematicBody:
#     return player_agent_body if is_instance_valid(player_agent_body) else null

--- Start of ./core/agents/agent.gd ---

# File: res://core/agents/agent.gd (Attached to AgentBody KinematicBody)
# Version: 3.33 - Fetched component nodes inside initialize() due to execution order.
extends KinematicBody

# --- Core State & Identity ---
var agent_name: String = "Default Agent"
var faction_id: String = "Neutral"
var template_id: String = "default"
var interaction_radius: float = 15.0

# --- Physics State ---
var current_velocity: Vector3 = Vector3.ZERO

# --- Component References ---
# Declare vars, assign them in initialize() now
var movement_system: Node = null
var navigation_system: Node = null


# --- Initialization ---
# Called externally (e.g., by WorldManager) after instancing and adding to tree
func initialize(template: AgentTemplate, overrides: Dictionary = {}):
	# 1. Basic AgentBody Initialization
	if not template is AgentTemplate:
		printerr("AgentBody Initialize Error: Invalid template for ", self.name)
		return

	self.template_id = template.template_id
	var default_name = template.default_agent_name + "_" + str(get_instance_id())
	self.agent_name = overrides.get("name", default_name)
	self.faction_id = overrides.get("faction", template.default_faction_id)
	self.name = self.agent_name  # Set Node name
	self.interaction_radius = overrides.get("interaction_radius", template.interaction_radius)

	# *** Fetch Component Nodes HERE inside initialize ***
	movement_system = get_node_or_null("MovementSystem")
	navigation_system = get_node_or_null("NavigationSystem")

	# *** Check if references were successfully obtained NOW ***
	if not is_instance_valid(movement_system) or not is_instance_valid(navigation_system):
		printerr(
			"AgentBody Initialize Error: Failed to get required component nodes (MovementSystem or NavigationSystem) for '",
			self.name,
			"'. Check node names and scene structure."
		)
		set_physics_process(false)  # Disable physics if components are missing
		return  # Stop initialization

	# If we got here, components were found successfully.

	# 2. Prepare Params for Components
	var move_params = {
		"max_move_speed": overrides.get("max_move_speed", template.max_move_speed),
		"acceleration": overrides.get("acceleration", template.acceleration),
		"deceleration": overrides.get("deceleration", template.deceleration),
		"max_turn_speed": overrides.get("max_turn_speed", template.max_turn_speed),
		"brake_strength": overrides.get("brake_strength", template.deceleration * 1.5),
		"alignment_threshold_angle_deg":
		overrides.get("alignment_threshold_angle_deg", template.alignment_threshold_angle_deg)
	}
	var nav_params = {
		"orbit_kp": overrides.get("orbit_kp", 3.0),
		"orbit_ki": overrides.get("orbit_ki", 0.1),
		"orbit_kd": overrides.get("orbit_kd", 0.5)
	}

	# 3. Initialize Components
	movement_system.initialize_movement_params(move_params)
	navigation_system.initialize_navigation(nav_params, movement_system)  # Pass ref to movement_system

	print(
		"AgentBody '",
		self.name,
		"' initialized WITH COMPONENTS successfully using template '",
		self.template_id,
		"'."
	)


# --- Godot Lifecycle ---
func _ready():
	add_to_group("Agents")
	# No need to fetch nodes here anymore, moved to initialize()
	set_physics_process(true)  # Enable physics processing


func _physics_process(delta: float):
	# Check components validity just in case something weird happens after init
	if not is_instance_valid(navigation_system) or not is_instance_valid(movement_system):
		# If components somehow became invalid after successful init, stop processing.
		if delta > 0:  # Avoid printing flood if physics is disabled
			printerr("AgentBody _physics_process Error: Components invalid for '", self.name, "'!")
		set_physics_process(false)
		return

	if delta <= 0.0001:
		return

	# 1. Update Navigation & Movement Logic
	navigation_system.update_navigation(delta)

	# 2. Apply Physics Engine Movement
	current_velocity = move_and_slide(current_velocity, Vector3.UP)

	# 3. Apply Post-Movement Corrections (e.g., PID)
	navigation_system.apply_orbit_pid_correction(delta)

	# 4. Final Velocity Clamping
	var max_speed = movement_system.max_move_speed
	if current_velocity.length_squared() > max_speed * max_speed:
		current_velocity = current_velocity.normalized() * max_speed


# --- Public Command API (Delegates to NavigationSystem) ---
# (Command functions remain the same as v3.32)
# ...
func command_stop():
	if is_instance_valid(navigation_system):
		navigation_system.set_command_stopping()
	else:
		printerr("AgentBody: Cannot command_stop - NavigationSystem invalid.")


func command_move_to(position: Vector3):
	if is_instance_valid(navigation_system):
		navigation_system.set_command_move_to(position)
	else:
		printerr("AgentBody: Cannot command_move_to - NavigationSystem invalid.")


func command_move_direction(direction: Vector3):
	if is_instance_valid(navigation_system):
		navigation_system.set_command_move_direction(direction)
	else:
		printerr("AgentBody: Cannot command_move_direction - NavigationSystem invalid.")


func command_approach(target: Spatial):
	if is_instance_valid(navigation_system):
		navigation_system.set_command_approach(target)
	else:
		printerr("AgentBody: Cannot command_approach - NavigationSystem invalid.")


func command_orbit(target: Spatial):
	if not is_instance_valid(target):
		printerr("AgentBody: command_orbit - Invalid target node provided.")
		if is_instance_valid(navigation_system):
			navigation_system.set_command_stopping()
		return

	if is_instance_valid(navigation_system):
		var vec_to_target_local = to_local(target.global_transform.origin)
		var orbit_clockwise = vec_to_target_local.x > 0.01
		var target_size = navigation_system._get_target_effective_size(target)
		var current_dist = global_transform.origin.distance_to(target.global_transform.origin)
		var min_orbit_dist = target_size * 1.2 + 10.0
		var captured_orbit_dist = max(current_dist, min_orbit_dist)
		navigation_system.set_command_orbit(target, captured_orbit_dist, orbit_clockwise)
	else:
		printerr("AgentBody: Cannot command_orbit - NavigationSystem invalid.")


func command_flee(target: Spatial):
	if is_instance_valid(navigation_system):
		navigation_system.set_command_flee(target)
	else:
		printerr("AgentBody: Cannot command_flee - NavigationSystem invalid.")


func command_align_to(direction: Vector3):
	if is_instance_valid(navigation_system):
		navigation_system.set_command_align_to(direction)
	else:
		printerr("AgentBody: Cannot command_align_to - NavigationSystem invalid.")


# --- Public Getters ---
func get_interaction_radius() -> float:
	return interaction_radius


# --- Despawn ---
func despawn():
	print("AgentBody '", self.name, "' despawning...")
	EventBus.emit_signal("agent_despawning", self)
	set_physics_process(false)
	call_deferred("queue_free")
# ...

--- Start of ./core/agents/agent_template.gd ---

# File: core/agents/agent_template.gd
# Resource Definition for Agent Stats/Config
# Version: 1.1 - Added alignment threshold export

extends Resource
class_name AgentTemplate  # Allows type hinting and creating this resource type in editor

# --- Identification ---
export var template_id: String = "default_template"  # Unique ID for this template type
export var default_agent_name: String = "Agent"  # Base name for agents using this
export var default_faction_id: String = "Neutral"  # Default faction

# --- Base Movement Capabilities (Reads defaults from Constants) ---
export var max_move_speed: float = Constants.DEFAULT_MAX_MOVE_SPEED
export var acceleration: float = Constants.DEFAULT_ACCELERATION
export var deceleration: float = Constants.DEFAULT_DECELERATION
export var max_turn_speed: float = Constants.DEFAULT_MAX_TURN_SPEED

# --- Interaction Size ---
# Used by camera targeting, docking, etc. Represents effective size.
export var interaction_radius: float = 15.0  # Default reasonable size

# --- NEW: Alignment Threshold ---
# Agent will only accelerate forward if facing within this angle (degrees) of the target direction.
# Relevant for MOVE_TO, MOVE_DIRECTION, APPROACH, FLEE commands.
export var alignment_threshold_angle_deg: float = 45.0

# --- Base Combat Stats (Placeholders - Link to Combat Module/Character System later) ---
# export var base_hull : int = 100
# export var base_shields : int = 0

# --- Base Skills (Placeholders - Link to Character System later) ---
# These represent the inherent skill level associated with this *type* of agent
# export var base_piloting_skill : int = 0
# export var base_tech_skill : int = 0
# export var base_social_skill : int = 0

# --- AI Behavior Hint (Optional) ---
# export var default_ai_behavior : String = "idle" # Hint for AI controller selection/init

# --- Visuals / Asset Links (Placeholders) ---
# Optional: Could link to default ship model path, visual effects, etc.
# export (String, FILE, "*.tscn,*.glb,*.gltf") var default_model_path = ""

--- Start of ./core/agents/components/movement_system.gd ---

# File: res://core/agents/components/movement_system.gd
# Version: 1.0
# Purpose: Handles the low-level execution of agent movement and rotation physics.
# Called by NavigationSystem.

extends Node

# --- Movement Capabilities (Set by AgentBody during initialize) ---
var max_move_speed: float = Constants.DEFAULT_MAX_MOVE_SPEED
var acceleration: float = Constants.DEFAULT_ACCELERATION
var deceleration: float = Constants.DEFAULT_DECELERATION
var brake_strength: float = Constants.DEFAULT_DECELERATION * 1.5  # Default derived value
var max_turn_speed: float = Constants.DEFAULT_MAX_TURN_SPEED
var alignment_threshold_angle_deg: float = 45.0
var _alignment_threshold_rad: float = deg2rad(alignment_threshold_angle_deg)

# Reference to the parent AgentBody KinematicBody
var agent_body: KinematicBody = null


func _ready():
	# Get reference to parent body ONCE. Assumes this node is direct child.
	agent_body = get_parent()
	if not agent_body is KinematicBody:
		printerr("MovementSystem Error: Parent is not a KinematicBody!")
		agent_body = null  # Invalidate if wrong type
		set_process(false)  # Disable if setup fails


# Called by AgentBody's initialize method
func initialize_movement_params(params: Dictionary):
	max_move_speed = params.get("max_move_speed", max_move_speed)
	acceleration = params.get("acceleration", acceleration)
	deceleration = params.get("deceleration", deceleration)
	brake_strength = params.get("brake_strength", deceleration * 1.5)  # Use provided or derive default
	max_turn_speed = params.get("max_turn_speed", max_turn_speed)
	alignment_threshold_angle_deg = params.get(
		"alignment_threshold_angle_deg", alignment_threshold_angle_deg
	)
	_alignment_threshold_rad = deg2rad(alignment_threshold_angle_deg)
	print(
		(
			"MovementSystem Initialized: Speed=%.1f, Accel=%.1f, Decel=%.1f, Turn=%.1f, Align=%.1f"
			% [
				max_move_speed,
				acceleration,
				deceleration,
				max_turn_speed,
				alignment_threshold_angle_deg
			]
		)
	)


# --- Public Methods Called by NavigationSystem ---


# Applies acceleration towards max_move_speed ONLY if aligned within threshold.
# Modifies agent_body.current_velocity directly.
func apply_acceleration(target_direction: Vector3, delta: float):
	if not is_instance_valid(agent_body):
		return

	if target_direction.length_squared() < 0.001:
		# If target direction is zero, just decelerate
		apply_deceleration(delta)
		return

	var target_dir_norm = target_direction.normalized()
	var current_forward = -agent_body.global_transform.basis.z.normalized()
	# Calculate the angle between current forward and target direction
	var angle = current_forward.angle_to(target_dir_norm)

	# Check if angle is within the alignment threshold
	if angle <= _alignment_threshold_rad:
		# Aligned: Interpolate towards target velocity
		var target_velocity = target_dir_norm * max_move_speed
		agent_body.current_velocity = agent_body.current_velocity.linear_interpolate(
			target_velocity, acceleration * delta
		)
		# agent_body._is_braking = false # State managed by NavigationSystem or AgentBody now
	else:
		# Not aligned: Apply natural deceleration while turning continues
		apply_deceleration(delta)


# Applies natural deceleration (drag). Modifies agent_body.current_velocity.
func apply_deceleration(delta: float):
	if not is_instance_valid(agent_body):
		return
	agent_body.current_velocity = agent_body.current_velocity.linear_interpolate(
		Vector3.ZERO, deceleration * delta
	)
	# agent_body._is_braking = false


# Applies active braking force. Modifies agent_body.current_velocity.
# Returns true if velocity is considered stopped.
func apply_braking(delta: float) -> bool:
	if not is_instance_valid(agent_body):
		return true  # Assume stopped if no body
	agent_body.current_velocity = agent_body.current_velocity.linear_interpolate(
		Vector3.ZERO, brake_strength * delta
	)
	# agent_body._is_braking = true
	# Return true if velocity is very close to zero
	return agent_body.current_velocity.length_squared() < 0.5


# Handles rotation towards a target look direction using Slerp.
# Modifies agent_body.global_transform.basis directly.
func apply_rotation(target_look_dir: Vector3, delta: float):
	if not is_instance_valid(agent_body):
		return

	if target_look_dir.length_squared() < 0.001:
		return  # Ignore zero vector

	var target_dir = target_look_dir.normalized()
	# --- IMPORTANT: Operate on the PARENT's basis ---
	var current_basis = agent_body.global_transform.basis.orthonormalized()

	# Determine the 'up' vector for looking_at, avoiding gimbal lock
	var up_vector = Vector3.UP
	if abs(target_dir.dot(Vector3.UP)) > 0.999:
		up_vector = Vector3.FORWARD  # Use Forward as fallback up vector

	# Calculate the target basis using looking_at
	var target_basis = Transform(Basis(), Vector3.ZERO).looking_at(target_dir, up_vector).basis.orthonormalized()

	# Check if already aligned (approximately)
	if current_basis.is_equal_approx(target_basis):
		return

	# Rotate towards the target basis using Slerp if turn speed is positive
	if max_turn_speed > 0.001:
		var turn_step = max_turn_speed * delta  # Rotation amount this frame
		var new_basis = current_basis.slerp(target_basis, turn_step)
		# --- IMPORTANT: Apply result back to PARENT's basis ---
		agent_body.global_transform.basis = new_basis
	else:
		# If turn speed is zero, snap instantly
		agent_body.global_transform.basis = target_basis

--- Start of ./core/agents/components/navigation_system.gd ---

# File: res://core/agents/components/navigation_system.gd
# Version: 1.2.1 - Fixed PID instantiation order.
extends Node

# --- Enums and Constants ---
enum CommandType { IDLE, STOPPING, MOVE_TO, MOVE_DIRECTION, APPROACH, ORBIT, FLEE, ALIGN_TO }
const APPROACH_DISTANCE_MULTIPLIER = 1.5
const APPROACH_MIN_DISTANCE = 500.0
# Thresholds for considering PID-controlled arrival complete (tune these)
const ARRIVAL_DISTANCE_THRESHOLD = 5.0
const ARRIVAL_SPEED_THRESHOLD_SQ = 1.0  # Squared speed (1 m/s)^2

# --- References (Set by AgentBody) ---
var agent_body: KinematicBody = null
var movement_system: Node = null  # Reference to the MovementSystem sibling node

# --- State ---
var _current_command = {}  # Holds the active command dictionary

# --- PID Controller Instances --- # DECLARED HERE, INSTANTIATED IN initialize_navigation
var _orbit_pid: PIDController = null  # For maintaining orbit distance
var _approach_pid: PIDController = null  # For controlling approach speed based on distance
var _move_to_pid: PIDController = null  # For controlling move speed based on distance

# --- Initialization ---

func _ready():
	# Initial state is typically set via AgentBody calling a command method
	# Ensure a default state if nothing else is called *after* initialization
	# Note: PIDs are now instantiated in initialize_navigation
	if not _current_command:
		set_command_idle()

# Called by AgentBody's initialize method
func initialize_navigation(nav_params: Dictionary, move_sys_ref: Node):
	# Store references provided by AgentBody
	movement_system = move_sys_ref
	agent_body = get_parent() # Assume NavigationSystem is a direct child of AgentBody

	# Safety check references BEFORE using them
	if not is_instance_valid(agent_body):
		printerr("NavigationSystem Error: Parent AgentBody is not valid!")
		return # Cannot proceed without agent body
	if not is_instance_valid(movement_system):
		printerr("NavigationSystem Error: MovementSystem reference is not valid!")
		# Could potentially continue without movement system for some logic,
		# but PID initialization relies on it for max speed, so return here too.
		return

	# --- Instantiate PID Controllers HERE ---
	var PIDControllerScript = load("res://core/utils/pid_controller.gd")
	if PIDControllerScript:
		_orbit_pid = PIDControllerScript.new()
		_approach_pid = PIDControllerScript.new()
		_move_to_pid = PIDControllerScript.new()
		print("NavigationSystem: PID Controllers instantiated.") # Moved print here
	else:
		printerr("NavigationSystem Error: Failed to load PIDController script! Cannot initialize PIDs.")
		# PIDs will remain null, subsequent checks will fail gracefully
		# but PID functionality will be disabled.

	# --- Initialize PID controllers ---
	# Now we can safely check is_instance_valid because we *attempted* instantiation above.

	# Orbit PID
	if is_instance_valid(_orbit_pid):
		var pid_kp = nav_params.get("orbit_kp", 0.1)
		var pid_ki = nav_params.get("orbit_ki", 0.0)
		var pid_kd = nav_params.get("orbit_kd", 0.05)
		var pid_i_limit = nav_params.get("orbit_pid_integral_limit", 1000.0)
		var pid_o_limit = nav_params.get("orbit_pid_output_limit", 50.0)
		_orbit_pid.initialize(pid_kp, pid_ki, pid_kd, pid_i_limit, pid_o_limit)
		print("  Orbit PID Initialized (Kp=%.2f, Ki=%.2f, Kd=%.2f)" % [pid_kp, pid_ki, pid_kd])
	else:
		# This error now means instantiation failed (script load error)
		printerr("NavigationSystem Error: _orbit_pid instance is not valid during initialization (Instantiation likely failed).")

	# Approach PID (Gains suggested for 300 m/s max speed, 150 m/s^2 accel - **NEEDS TUNING**)
	if is_instance_valid(_approach_pid):
		var ap_kp = nav_params.get("approach_kp", 0.1)
		var ap_ki = nav_params.get("approach_ki", 0.0)
		var ap_kd = nav_params.get("approach_kd", 0.5)
		# Safely access max_move_speed now that move_sys_ref check passed
		var ap_o_limit = movement_system.max_move_speed
		_approach_pid.initialize(ap_kp, ap_ki, ap_kd, 1000.0, ap_o_limit)
		print("  Approach PID Initialized (Kp=%.3f, Ki=%.3f, Kd=%.3f)" % [ap_kp, ap_ki, ap_kd])
	else:
		printerr("NavigationSystem Error: _approach_pid instance not valid during init (Instantiation likely failed).")

	# Move To PID (Gains suggested for 300 m/s max speed, 150 m/s^2 accel - **NEEDS TUNING**)
	if is_instance_valid(_move_to_pid):
		var mt_kp = nav_params.get("move_to_kp", 0.1)
		var mt_ki = nav_params.get("move_to_ki", 0.0)
		var mt_kd = nav_params.get("move_to_kd", 0.5)
		# Safely access max_move_speed now that move_sys_ref check passed
		var mt_o_limit = movement_system.max_move_speed
		_move_to_pid.initialize(mt_kp, mt_ki, mt_kd, 1000.0, mt_o_limit)
		print("  MoveTo PID Initialized (Kp=%.3f, Ki=%.3f, Kd=%.3f)" % [mt_kp, mt_ki, mt_kd])
	else:
		printerr("NavigationSystem Error: _move_to_pid instance not valid during init (Instantiation likely failed).")

	print("NavigationSystem Initialized.")
	# Set initial command *after* everything is set up, if needed
	# Or rely on AgentBody to issue the first command post-initialization.
	# Let's keep the _ready check for a default idle state for safety.
	# if not _current_command:
	#     set_command_idle()


# --- Public Command Setting Methods (Called by AgentBody) ---
# (Reset logic remains the same, but now we are sure the PIDs exist
# or are properly null if instantiation failed)

func set_command_idle():
	var last_look = (
		-agent_body.global_transform.basis.z
		if is_instance_valid(agent_body)
		else Vector3.BACK
	)
	if _current_command:
		if "target_dir" in _current_command:
			last_look = _current_command.target_dir
		elif "target_node" in _current_command:
			var cmd_target = _current_command.target_node
			if is_instance_valid(cmd_target) and is_instance_valid(agent_body):
				last_look = (cmd_target.global_transform.origin - agent_body.global_transform.origin).normalized()

	_current_command = {"type": CommandType.IDLE, "target_dir": last_look}
	# No need to reset PIDs on idle

func set_command_stopping():
	_current_command = {"type": CommandType.STOPPING}
	if is_instance_valid(_orbit_pid): _orbit_pid.reset()
	if is_instance_valid(_approach_pid): _approach_pid.reset()
	if is_instance_valid(_move_to_pid): _move_to_pid.reset()

func set_command_move_to(position: Vector3):
	_current_command = {"type": CommandType.MOVE_TO, "target_pos": position}
	if is_instance_valid(_orbit_pid): _orbit_pid.reset()
	if is_instance_valid(_approach_pid): _approach_pid.reset()
	if is_instance_valid(_move_to_pid): _move_to_pid.reset()

func set_command_move_direction(direction: Vector3):
	if direction.length_squared() < 0.001:
		printerr("NavigationSystem: Invalid direction vector for MOVE_DIRECTION.")
		set_command_stopping()
		return
	_current_command = {"type": CommandType.MOVE_DIRECTION, "target_dir": direction.normalized()}
	if is_instance_valid(_orbit_pid): _orbit_pid.reset()
	if is_instance_valid(_approach_pid): _approach_pid.reset()
	if is_instance_valid(_move_to_pid): _move_to_pid.reset()

func set_command_approach(target: Spatial):
	if not is_instance_valid(target):
		printerr("NavigationSystem: Invalid target node for APPROACH.")
		set_command_stopping()
		return
	_current_command = {"type": CommandType.APPROACH, "target_node": target}
	if is_instance_valid(_orbit_pid): _orbit_pid.reset()
	if is_instance_valid(_approach_pid): _approach_pid.reset()
	if is_instance_valid(_move_to_pid): _move_to_pid.reset()

func set_command_orbit(target: Spatial, distance: float, clockwise: bool):
	# Re-issue check
	if (
		_current_command.get("type") == CommandType.ORBIT
		and _current_command.get("target_node") == target
		and is_equal_approx(_current_command.get("distance"), distance)
		and _current_command.get("clockwise") == clockwise
	):
		return

	if not is_instance_valid(target):
		printerr("NavigationSystem: Invalid target node for ORBIT.")
		set_command_stopping()
		return

	_current_command = {
		"type": CommandType.ORBIT,
		"target_node": target,
		"distance": distance,
		"clockwise": clockwise
	}
	if is_instance_valid(_orbit_pid): _orbit_pid.reset()
	if is_instance_valid(_approach_pid): _approach_pid.reset()
	if is_instance_valid(_move_to_pid): _move_to_pid.reset()

func set_command_flee(target: Spatial):
	if not is_instance_valid(target):
		printerr("NavigationSystem: Invalid target node for FLEE.")
		set_command_stopping()
		return
	_current_command = {"type": CommandType.FLEE, "target_node": target}
	if is_instance_valid(_orbit_pid): _orbit_pid.reset()
	if is_instance_valid(_approach_pid): _approach_pid.reset()
	if is_instance_valid(_move_to_pid): _move_to_pid.reset()

func set_command_align_to(direction: Vector3):
	if direction.length_squared() < 0.001:
		printerr("NavigationSystem: Invalid direction vector for ALIGN_TO.")
		set_command_idle() # Go idle if direction is invalid
		return
	_current_command = {"type": CommandType.ALIGN_TO, "target_dir": direction.normalized()}
	if is_instance_valid(_orbit_pid): _orbit_pid.reset()
	if is_instance_valid(_approach_pid): _approach_pid.reset()
	if is_instance_valid(_move_to_pid): _move_to_pid.reset()


# --- Main Update Logic (Called by AgentBody._physics_process before move_and_slide) ---
func update_navigation(delta: float):
	# Check basic validity early
	if not is_instance_valid(agent_body) or not is_instance_valid(movement_system):
		# Print error only once maybe? Or rely on initialization errors.
		return

	var cmd_type = _current_command.get("type", CommandType.IDLE)
	var target_node = _current_command.get("target_node", null) # Get potential target node

	# --- Target Validity Check (for commands requiring a target node) ---
	var is_target_cmd = cmd_type in [CommandType.APPROACH, CommandType.ORBIT, CommandType.FLEE]
	if is_target_cmd and not is_instance_valid(target_node):
		# Target became invalid after command was issued
		printerr("NavigationSystem: Target node for command %s became invalid." % CommandType.keys()[cmd_type])
		set_command_stopping()
		cmd_type = CommandType.STOPPING # Update local type for this frame's match

	# --- Command Execution Logic ---
	match cmd_type:
		CommandType.IDLE:
			movement_system.apply_deceleration(delta)

		CommandType.STOPPING:
			var stopped = movement_system.apply_braking(delta)
			if stopped and not _current_command.get("signaled_stop", false):
				EventBus.emit_signal("agent_reached_destination", agent_body)
				_current_command["signaled_stop"] = true
			# Stay stopping even after signal

		CommandType.MOVE_TO:
			# Check PID validity specifically for this command
			if not is_instance_valid(_move_to_pid):
				printerr("NavigationSystem Error: MOVE_TO requires a valid _move_to_pid instance.")
				set_command_stopping() # Fallback if PID isn't available
				return # Skip rest of MOVE_TO logic

			var target_pos = _current_command.target_pos
			var vector_to_target = target_pos - agent_body.global_transform.origin
			var distance = vector_to_target.length()
			var distance_error = distance
			var pid_target_speed = _move_to_pid.update(distance_error, delta)
			pid_target_speed = clamp(pid_target_speed, 0, movement_system.max_move_speed)

			var direction = Vector3.ZERO
			if distance > 0.01: # Avoid normalization of zero vector
				direction = vector_to_target.normalized()

			movement_system.apply_rotation(direction, delta)

			var target_velocity = direction * pid_target_speed
			agent_body.current_velocity = agent_body.current_velocity.linear_interpolate(
				target_velocity, movement_system.acceleration * delta
			)

			# Completion Check
			if (distance < ARRIVAL_DISTANCE_THRESHOLD and
				agent_body.current_velocity.length_squared() < ARRIVAL_SPEED_THRESHOLD_SQ):
				if not _current_command.get("signaled_stop", false):
					print("Agent ", agent_body.name, " reached move_to destination.")
					EventBus.emit_signal("agent_reached_destination", agent_body)
					_current_command["signaled_stop"] = true
				movement_system.apply_braking(delta) # Gentle stop
			else:
				_current_command["signaled_stop"] = false # Reset if we overshoot or condition not met

		CommandType.MOVE_DIRECTION:
			var move_dir = _current_command.get("target_dir", Vector3.ZERO)
			if move_dir.length_squared() > 0.001:
				movement_system.apply_rotation(move_dir, delta)
				movement_system.apply_acceleration(move_dir, delta)
			else:
				# Invalid direction likely handled by setter, but decelerate just in case
				movement_system.apply_deceleration(delta)

		CommandType.APPROACH:
			# Check PID validity specifically for this command
			if not is_instance_valid(_approach_pid):
				printerr("NavigationSystem Error: APPROACH requires a valid _approach_pid instance.")
				set_command_stopping() # Fallback if PID isn't available
				return # Skip rest of APPROACH logic

			# Target validity already checked at the start of the function
			var target_pos = target_node.global_transform.origin
			var target_size = _get_target_effective_size(target_node)
			var desired_stop_dist = max(
				APPROACH_MIN_DISTANCE, target_size * APPROACH_DISTANCE_MULTIPLIER
			)

			var vector_to_target = target_pos - agent_body.global_transform.origin
			var distance = vector_to_target.length()
			var direction = Vector3.ZERO
			if distance > 0.01:
				direction = vector_to_target.normalized()

			movement_system.apply_rotation(direction, delta)

			var distance_error = distance - desired_stop_dist
			var pid_target_speed = _approach_pid.update(distance_error, delta)
			pid_target_speed = clamp(
				pid_target_speed,
				-movement_system.max_move_speed * 0.1, # Allow slight reverse
				movement_system.max_move_speed
			)

			var target_velocity = direction * pid_target_speed
			agent_body.current_velocity = agent_body.current_velocity.linear_interpolate(
				target_velocity, movement_system.acceleration * delta
			)

			# Completion Check
			if (abs(distance_error) < ARRIVAL_DISTANCE_THRESHOLD and
				agent_body.current_velocity.length_squared() < ARRIVAL_SPEED_THRESHOLD_SQ):
				if not _current_command.get("signaled_stop", false):
					print("Agent ", agent_body.name, " reached approach destination.")
					EventBus.emit_signal("agent_reached_destination", agent_body)
					_current_command["signaled_stop"] = true
				movement_system.apply_braking(delta) # Gentle stop
			else:
				_current_command["signaled_stop"] = false # Reset if we overshoot or condition not met

		CommandType.ORBIT:
			# Check PID validity specifically for this command (used in apply_orbit_pid_correction)
			if not is_instance_valid(_orbit_pid):
				printerr("NavigationSystem Error: ORBIT requires a valid _orbit_pid instance.")
				set_command_stopping() # Fallback if PID isn't available
				return # Skip rest of ORBIT logic

			# Target validity already checked at the start of the function
			var target_pos = target_node.global_transform.origin
			var orbit_dist = _current_command.get("distance", 100.0)
			var clockwise = _current_command.get("clockwise", false)

			var vector_to_target = target_pos - agent_body.global_transform.origin
			var distance = vector_to_target.length()
			# Avoid division by zero if exactly on top of target
			if distance < 0.01: distance = 0.01
			var direction_to_target = vector_to_target / distance

			# Determine tangent direction (simplified, assumes mostly planar movement for Up vector)
			var target_up = Vector3.UP
			var tangent_dir : Vector3
			# Use agent's right vector as fallback if target is directly above/below
			var cross_fallback_axis = agent_body.global_transform.basis.x
			var cross_product = direction_to_target.cross(target_up) if not clockwise else target_up.cross(direction_to_target)

			if cross_product.length_squared() < 0.01: # Check if aligned with target_up
				cross_product = direction_to_target.cross(cross_fallback_axis) if not clockwise else cross_fallback_axis.cross(direction_to_target)

			tangent_dir = cross_product.normalized()

			# Apply rotation towards the tangent
			movement_system.apply_rotation(tangent_dir, delta)

			# Calculate target speed based on orbit distance (same as before)
			var target_tangential_speed = 0.0
			var full_speed_radius = Constants.ORBIT_FULL_SPEED_RADIUS
			if orbit_dist <= 0:
				target_tangential_speed = 0.0
			elif orbit_dist < full_speed_radius:
				target_tangential_speed = movement_system.max_move_speed * (distance / full_speed_radius)
			else:
				target_tangential_speed = movement_system.max_move_speed
			target_tangential_speed = clamp(target_tangential_speed, 0.0, movement_system.max_move_speed)

			# Interpolate velocity towards tangential target velocity
			var target_velocity = tangent_dir * target_tangential_speed
			agent_body.current_velocity = agent_body.current_velocity.linear_interpolate(
				target_velocity, movement_system.acceleration * delta
			)
			# PID correction for distance applied in apply_orbit_pid_correction

		CommandType.FLEE:
			# Target validity already checked at the start of the function
			var target_pos = target_node.global_transform.origin
			var vector_away = agent_body.global_transform.origin - target_pos
			var direction_away = Vector3.ZERO
			if vector_away.length_squared() > 0.01:
				direction_away = vector_away.normalized()
			else:
				# If exactly on top, flee in current forward direction or an arbitrary one
				direction_away = -agent_body.global_transform.basis.z if agent_body.global_transform.basis.z.length_squared() > 0.01 else Vector3.FORWARD

			movement_system.apply_rotation(direction_away, delta)
			movement_system.apply_acceleration(direction_away, delta)

		CommandType.ALIGN_TO:
			var target_dir = _current_command.target_dir
			movement_system.apply_rotation(target_dir, delta)
			movement_system.apply_deceleration(delta) # Slow down while aligning

			# Check if alignment is complete
			var current_fwd = -agent_body.global_transform.basis.z
			# Use a tolerance for floating point comparison
			if current_fwd.dot(target_dir) > 0.999: # Increased precision slightly
				set_command_idle() # Alignment complete, go idle

# --- PID Correction Logic (Called by AgentBody._physics_process AFTER move_and_slide) ---
func apply_orbit_pid_correction(delta: float):
	# Only apply ORBIT PID correction here
	if _current_command.get("type") != CommandType.ORBIT:
		return
	# Check validity again, could have become invalid between update and correction
	if not is_instance_valid(agent_body) or not is_instance_valid(movement_system):
		return
	# Ensure the PID controller specifically needed is valid
	if not is_instance_valid(_orbit_pid):
		# Error already printed during update, no need to repeat spam usually
		# printerr("NavigationSystem Error: Orbit PID controller instance is invalid in correction!")
		return

	var target_node = _current_command.get("target_node", null)
	# Also re-check target validity here
	if is_instance_valid(target_node):
		var desired_orbit_dist = _current_command.get("distance", 100.0)
		var target_pos = target_node.global_transform.origin
		var current_pos = agent_body.global_transform.origin
		var vector_to_target = target_pos - current_pos
		var current_distance = vector_to_target.length()

		# Avoid issues if distance is zero
		if current_distance < 0.01:
			# Cannot determine radial direction, skip correction this frame
			return

		var distance_error = current_distance - desired_orbit_dist
		var pid_output = _orbit_pid.update(distance_error, delta)

		# Radial direction points from target towards agent
		var radial_direction = -vector_to_target.normalized()

		# Apply correction *against* current velocity
		# Subtracting means positive PID output (too far) pushes towards target
		# Negative PID output (too close) pushes away from target
		var velocity_correction = radial_direction * pid_output

		# Apply the correction scaled by delta
		# Note: Applying directly to velocity *after* move_and_slide can feel 'snappy'.
		# Consider if applying force/acceleration based on PID output is smoother.
		# For now, keeping direct velocity adjustment as implied by original code.
		agent_body.current_velocity -= velocity_correction # Removed delta scaling here - PID output often represents a target *rate* or *force*, applying directly might be intended. If it feels too strong, re-add * delta. Check PIDController implementation details. Assuming output is corrective velocity delta.

# --- Helper Functions ---

# Target Size Helper (Unchanged - Make sure Constants exists and has the key if used)
func _get_target_effective_size(target_node: Spatial) -> float:
	var calculated_size = 1.0
	var default_size = 50.0
	var found_source = false

	if not is_instance_valid(target_node):
		return default_size

	# 1. Check for explicit method
	if target_node.has_method("get_interaction_radius"):
		var explicit_size = target_node.get_interaction_radius()
		if (explicit_size is float or explicit_size is int) and explicit_size > 0:
			calculated_size = float(explicit_size) # Cast to float
			found_source = true
			# print("Found size via get_interaction_radius: ", calculated_size) # Debug

	# 2. Check for 'Model' child VisualInstance AABB (more reliable for meshes)
	if not found_source:
		var model_node = target_node.get_node_or_null("Model")
		if is_instance_valid(model_node) and model_node is VisualInstance: # Check if it's renderable
			var aabb: AABB = model_node.get_aabb()
			# Use the largest dimension of the AABB multiplied by the largest scale component
			var model_scale = model_node.global_transform.basis.get_scale()
			var max_scale = max(model_scale.x, max(model_scale.y, model_scale.z))
			calculated_size = aabb.get_longest_axis_size() * max_scale
			if calculated_size > 0.01: # Ensure valid size
				found_source = true
				# print("Found size via Model AABB: ", calculated_size) # Debug
			else:
				# Fallback if AABB is zero/invalid but Model exists
				calculated_size = max(max_scale, 1.0) # Use scale directly
				found_source = true # Still counts as found from Model node
				# print("Found size via Model Scale (AABB fallback): ", calculated_size) # Debug


	# 3. Fallback to target node's own scale if no explicit size or valid Model found
	if not found_source:
		var node_scale = target_node.global_transform.basis.get_scale()
		calculated_size = max(node_scale.x, max(node_scale.y, node_scale.z))
		if calculated_size <= 0.01: # Check for zero or negative scale
			calculated_size = 1.0 # Use minimum size
		# print("Found size via Node Scale: ", calculated_size) # Debug
		# No need to set found_source = true, if we reach here, we use this or default

	# 4. Final fallback to default size if no other source worked or calculated size is tiny
	if not found_source or calculated_size < 1.0:
		# print("Using default size: ", default_size) # Debug
		calculated_size = default_size


	return max(calculated_size, 1.0) # Ensure size is at least 1.0

--- Start of ./core/systems/asset_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/character_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/chronicle_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/event_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/goal_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/progression_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/traffic_system_placeholder.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/world_map_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/ui/main_hud.gd ---

# File: res://core/ui/main_hud.gd
# Script for the main HUD container. Handles displaying targeting info, etc.
# Version: 1.1 - Fixed targeting indicator visibility restoration

extends Control

# --- Nodes ---
onready var targeting_indicator: Control = $TargetingIndicator

# --- State ---
var _current_target: Spatial = null
var _main_camera: Camera = null


# --- Initialization ---
func _ready():
	# Ensure indicator starts hidden
	targeting_indicator.visible = false

	# Get camera reference once
	_main_camera = get_viewport().get_camera()  # Initial attempt
	if not is_instance_valid(_main_camera) and is_instance_valid(GlobalRefs.main_camera):
		_main_camera = GlobalRefs.main_camera  # Fallback via GlobalRefs

	if not is_instance_valid(_main_camera):
		printerr("MainHUD Error: Could not get a valid camera reference!")
		set_process(false)  # Disable processing if no camera

	# Connect to EventBus signals
	if EventBus:
		if not EventBus.is_connected("player_target_selected", self, "_on_Player_Target_Selected"):
			EventBus.connect("player_target_selected", self, "_on_Player_Target_Selected")
		if not EventBus.is_connected(
			"player_target_deselected", self, "_on_Player_Target_Deselected"
		):
			EventBus.connect("player_target_deselected", self, "_on_Player_Target_Deselected")
	else:
		printerr("MainHUD Error: EventBus not available!")

	# Connect draw signal for custom drawing (optional, but good for style)
	targeting_indicator.connect("draw", self, "_draw_targeting_indicator")


# --- Process Update ---
func _process(delta):
	# Only update position if a target is selected and valid
	if is_instance_valid(_current_target) and is_instance_valid(_main_camera):
		# Project the target's 3D origin position to 2D screen coordinates
		var screen_pos: Vector2 = _main_camera.unproject_position(
			_current_target.global_transform.origin
		)

		# Check if the target is behind the camera
		var target_dir = (_current_target.global_transform.origin - _main_camera.global_transform.origin).normalized()
		var camera_fwd = -_main_camera.global_transform.basis.z.normalized()
		var is_in_front = target_dir.dot(camera_fwd) >= 0  # Use >= 0 to include exactly perpendicular

		# --- MODIFIED Visibility Logic ---
		# Set visibility based on whether the target is in front
		targeting_indicator.visible = is_in_front

		# Only update position and redraw if it's actually visible
		if targeting_indicator.visible:
			# Update the indicator's position
			targeting_indicator.rect_position = screen_pos - (targeting_indicator.rect_size / 2.0)
			targeting_indicator.update()  # Trigger redraw if using _draw
	else:
		# Ensure indicator is hidden if target becomes invalid or camera is invalid
		if targeting_indicator.visible:
			targeting_indicator.visible = false


# --- Signal Handlers ---
func _on_Player_Target_Selected(target_node: Spatial):
	print(target_node)
	if is_instance_valid(target_node):
		_current_target = target_node
		# Visibility is now primarily handled in _process,
		# but we still need to ensure _process runs.
		# targeting_indicator.visible = true # This line can be removed or kept, _process will override
		set_process(true)  # Ensure _process runs
	else:
		_on_Player_Target_Deselected()


func _on_Player_Target_Deselected():
	_current_target = null
	targeting_indicator.visible = false
	set_process(false)  # Can disable processing if target is deselected


# --- Custom Drawing (Optional but Recommended) ---
func _draw_targeting_indicator():
	# Example: Draw a simple white rectangle outline
	var rect = Rect2(Vector2.ZERO, targeting_indicator.rect_size)
	var line_color = Color.white
	var line_width = 1.0  # Adjust thickness as needed
	#targeting_indicator.draw_rect(rect, line_color, false, line_width)

	# Example: Draw simple corner brackets
	var size = targeting_indicator.rect_size
	var corner_len = size.x * 0.25  # Length of corner lines
	var color = Color.cyan
	var width = 2.0
	# # Top-left
	targeting_indicator.draw_line(Vector2(0, 0), Vector2(corner_len, 0), color, width)
	targeting_indicator.draw_line(Vector2(0, 0), Vector2(0, corner_len), color, width)
	# # Top-right
	targeting_indicator.draw_line(Vector2(size.x, 0), Vector2(size.x - corner_len, 0), color, width)
	targeting_indicator.draw_line(Vector2(size.x, 0), Vector2(size.x, corner_len), color, width)
	# # Bottom-left
	targeting_indicator.draw_line(Vector2(0, size.y), Vector2(corner_len, size.y), color, width)
	targeting_indicator.draw_line(Vector2(0, size.y), Vector2(0, size.y - corner_len), color, width)
	# # Bottom-right
	targeting_indicator.draw_line(
		Vector2(size.x, size.y), Vector2(size.x - corner_len, size.y), color, width
	)
	targeting_indicator.draw_line(
		Vector2(size.x, size.y), Vector2(size.x, size.y - corner_len), color, width
	)


# --- Cleanup ---
func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		if EventBus:
			if EventBus.is_connected("player_target_selected", self, "_on_Player_Target_Selected"):
				EventBus.disconnect("player_target_selected", self, "_on_Player_Target_Selected")
			if EventBus.is_connected(
				"player_target_deselected", self, "_on_Player_Target_Deselected"
			):
				EventBus.disconnect(
					"player_target_deselected", self, "_on_Player_Target_Deselected"
				)


func _on_ButtonFreeFlight_pressed():
	if EventBus:
		EventBus.emit_signal("player_free_flight_toggled")


func _on_ButtonStop_pressed():
	if EventBus:
		EventBus.emit_signal("player_stop_pressed")


func _on_ButtonOrbit_pressed():
	if EventBus:
		EventBus.emit_signal("player_orbit_pressed")


func _on_ButtonApproach_pressed():
	if EventBus:
		EventBus.emit_signal("player_approach_pressed")


func _on_ButtonFlee_pressed():
	if EventBus:
		EventBus.emit_signal("player_flee_pressed")

--- Start of ./core/utils/pid_controller.gd ---

# File: core/utils/pid_controller.gd
# Version: 1.0
# Purpose: A reusable PID controller class.

extends Node  # Or use 'extends Reference' if node features aren't needed
class_name PIDController

# --- Gains ---
var kp: float = 1.0 setget set_kp
var ki: float = 0.0 setget set_ki
var kd: float = 0.0 setget set_kd

# --- Limits ---
var integral_limit: float = 1000.0 setget set_integral_limit
var output_limit: float = 50.0 setget set_output_limit

# --- State ---
var integral: float = 0.0
var previous_error: float = 0.0


# --- Initialization ---
func initialize(
	p_gain: float, i_gain: float, d_gain: float, i_limit: float = 1000.0, o_limit: float = 50.0
):
	kp = p_gain
	ki = i_gain
	kd = d_gain
	integral_limit = abs(i_limit)  # Ensure positive limit
	output_limit = abs(o_limit)  # Ensure positive limit
	reset()  # Start with a clean state


# --- Update ---
# Calculates the PID output based on the current error and delta time.
# Returns the clamped PID output value.
func update(error: float, delta: float) -> float:
	if delta <= 0.0001:
		# Avoid division by zero or instability with tiny delta
		return 0.0

	# --- Proportional Term ---
	var p_term = kp * error

	# --- Integral Term ---
	integral += error * delta
	# Clamp integral to prevent windup
	integral = clamp(integral, -integral_limit, integral_limit)
	var i_term = ki * integral

	# --- Derivative Term ---
	var derivative = (error - previous_error) / delta
	var d_term = kd * derivative

	# --- Update State for Next Iteration ---
	previous_error = error

	# --- Calculate & Clamp Output ---
	var output = p_term + i_term + d_term
	output = clamp(output, -output_limit, output_limit)

	return output


# --- Reset ---
# Resets the integral and previous error state.
func reset():
	integral = 0.0
	previous_error = 0.0


# --- Setters (Optional, for runtime tweaking if needed) ---
func set_kp(value: float):
	kp = value


func set_ki(value: float):
	ki = value


func set_kd(value: float):
	kd = value


func set_integral_limit(value: float):
	integral_limit = abs(value)


func set_output_limit(value: float):
	output_limit = abs(value)

--- Start of ./modules/piloting/scripts/player_controller_ship.gd ---

# File: modules/piloting/scripts/player_controller_ship.gd
# Version 3.7 - Stop command now also exits free flight mode.

extends Node

# --- References ---
var agent_script: Node = null
var agent_body: KinematicBody = null
var _main_camera: Camera = null

# --- State ---
var _target_under_cursor: Spatial = null  # Updated in _physics_process
var _selected_target: Spatial = null setget _set_selected_target
var _is_free_flight_mode: bool = false

# --- Input Tracking State ---
var _lmb_pressed: bool = false
var _lmb_press_pos: Vector2 = Vector2.ZERO
var _lmb_press_time: int = 0  # Using OS.get_ticks_msec()
var _is_dragging: bool = false
var _last_tap_time: int = 0
# Removed _potential_double_click flag

# --- Constants ---
const DEFAULT_ORBIT_DIST = 3000.0
const DEFAULT_MOVE_TO_PROJECTION_DIST = 1e6
const DRAG_THRESHOLD_PX_SQ = 10 * 10  # Squared distance threshold to start drag
const DOUBLE_CLICK_TIME_MS = 400  # Max milliseconds between taps for double-click


# --- Initialization ---
func _ready():
	# Connect to EventBus signals
	if EventBus:
		# Ensure signal name matches exactly what's emitted
		if not EventBus.is_connected(
			"player_free_flight_toggled", self, "_on_Player_Free_Flight_Toggled"
		):
			var err = EventBus.connect(
				"player_free_flight_toggled", self, "_on_Player_Free_Flight_Toggled"
			)
			if err != OK:
				printerr(
					"PlayerController Error: Failed connect player_free_flight_toggled signal! Code: ",
					err
				)

		if not EventBus.is_connected("player_stop_pressed", self, "_on_Player_Stop_Pressed"):
			var err = EventBus.connect("player_stop_pressed", self, "_on_Player_Stop_Pressed")
			if err != OK:
				printerr(
					"PlayerController Error: Failed connect player_stop_pressed signal! Code: ", err
				)

		if not EventBus.is_connected("player_orbit_pressed", self, "_on_Player_Orbit_Pressed"):
			var err = EventBus.connect("player_orbit_pressed", self, "_on_Player_Orbit_Pressed")
			if err != OK:
				printerr(
					"PlayerController Error: Failed connect player_orbit_pressed signal! Code: ",
					err
				)

		if not EventBus.is_connected(
			"player_approach_pressed", self, "_on_Player_Approach_Pressed"
		):
			var err = EventBus.connect(
				"player_approach_pressed", self, "_on_Player_Approach_Pressed"
			)
			if err != OK:
				printerr(
					"PlayerController Error: Failed connect player_orbit_pressed signal! Code: ",
					err
				)  # Typo in original error message fixed

		if not EventBus.is_connected("player_flee_pressed", self, "_on_Player_Flee_Pressed"):
			var err = EventBus.connect("player_flee_pressed", self, "_on_Player_Flee_Pressed")
			if err != OK:
				printerr(  # Typo in original error message fixed
					"PlayerController Error: Failed connect player_flee_pressed signal! Code: ", err
				)

	else:
		printerr("PlayerController Error: EventBus not available!")

	var parent = get_parent()
	if parent is KinematicBody and parent.has_method("command_stop"):
		agent_body = parent
		agent_script = parent
		print("Player Controller ready for: ", agent_script.agent_name)
		call_deferred("_get_camera_reference")
		Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
	else:
		printerr("Player Controller Error: Parent invalid or missing command methods!")
		set_physics_process(false)
		set_process_input(false)
		return


func _get_camera_reference():
	yield(get_tree(), "idle_frame")
	if is_instance_valid(GlobalRefs.main_camera) and GlobalRefs.main_camera is Camera:
		_main_camera = GlobalRefs.main_camera
		print("Player Controller obtained camera reference.")
	else:
		printerr("Player Controller Error: Could not find valid Main Camera in GlobalRefs.")


# --- Physics Update ---
func _physics_process(delta):
	# Always update target under cursor when mouse is visible, might be needed for hover effects later
	if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE:
		_update_target_under_cursor()
	else:
		_target_under_cursor = null  # Clear if mouse not visible (e.g., free flight)

	# Free Flight Movement (Unchanged)
	if _is_free_flight_mode:
		if is_instance_valid(_main_camera) and is_instance_valid(agent_script):
			var move_dir = -_main_camera.global_transform.basis.z.normalized()
			agent_script.command_move_direction(move_dir)
		elif is_instance_valid(agent_script):
			agent_script.command_stop()  # Existing stop if camera invalid
		# Removed warping logic


# --- Target Raycast ---
func _update_target_under_cursor():
	# Reset first
	_target_under_cursor = null
	if not is_instance_valid(agent_body):
		return
	var camera = get_viewport().get_camera()  # Use viewport camera for UI interaction
	if not is_instance_valid(camera):
		return

	var mouse_pos = get_viewport().get_mouse_position()
	var ray_origin = camera.project_ray_origin(mouse_pos)
	var ray_normal = camera.project_ray_normal(mouse_pos)
	var ray_end = ray_origin + ray_normal * Constants.TARGETING_RAY_LENGTH

	var space_state = agent_body.get_world().direct_space_state
	var result = space_state.intersect_ray(ray_origin, ray_end, [agent_body], 1)  # Mask 1

	if result and result.collider is Spatial:
		_target_under_cursor = result.collider
		# TODO: Highlight _target_under_cursor (visual feedback)


# --- Target Selection Setter ---
func _set_selected_target(new_target: Spatial):
	if _selected_target == new_target:
		return

	_selected_target = new_target

	if is_instance_valid(_selected_target):
		if EventBus:
			EventBus.emit_signal("player_target_selected", _selected_target)
		print("Player selected target: ", _selected_target.name)
	else:
		# Handle deselection explicitly via signal
		if EventBus:
			EventBus.emit_signal("player_target_deselected")
		print("Player de-selected target.")


# --- Public Deselect Function --- (For UI Button)
func deselect_current_target():
	if is_instance_valid(_selected_target):
		self._selected_target = null  # Will trigger deselection signal via setter


# --- Input Event Handling ---
func _unhandled_input(event):
	var input_handled = false

	# --- Free Flight Toggle (Keyboard - Direct Check Re-added) ---
	if Input.is_action_just_pressed("toggle_free_flight"):
		_toggle_free_flight()
		input_handled = true  # CONSUME the input event

	# --- LMB / Touch Input Handling ---
	if event is InputEventMouseButton and event.button_index == BUTTON_LEFT:
		if event.pressed:
			_lmb_pressed = true
			_is_dragging = false
			_lmb_press_pos = event.position
			_lmb_press_time = OS.get_ticks_msec()
			# Don't handle yet
		else:  # Released
			if _lmb_pressed:
				_lmb_pressed = false
				var time_now = OS.get_ticks_msec()
				if _is_dragging:
					# End of Drag
					if (
						is_instance_valid(_main_camera)
						and _main_camera.has_method("set_is_rotating")
					):
						_main_camera.set_is_rotating(false)
					input_handled = true  # CONSUME event
				else:
					# End of Tap/Click
					if time_now - _last_tap_time <= DOUBLE_CLICK_TIME_MS:
						_handle_double_click(event.position)
						_last_tap_time = 0
					else:
						_handle_single_click(event.position)
						_last_tap_time = time_now
					input_handled = true  # CONSUME event
				_is_dragging = false

	# --- Mouse Motion / Touch Drag ---
	elif event is InputEventMouseMotion and _lmb_pressed and not _is_dragging:
		if event.position.distance_squared_to(_lmb_press_pos) > DRAG_THRESHOLD_PX_SQ:
			# Start Drag
			_is_dragging = true
			_last_tap_time = 0
			if not _is_free_flight_mode:
				if is_instance_valid(_main_camera) and _main_camera.has_method("set_is_rotating"):
					_main_camera.set_is_rotating(true)
			# Let camera consume motion event if it uses it

	# --- Other Keyboard Commands (Only if not in free flight *unless* it's stop) --- # MODIFIED CONDITION
	# Stop command check is now handled separately inside the helper.
	elif not _is_free_flight_mode and is_instance_valid(agent_script):  # Original condition kept for other commands
		# Check only if event wasn't handled by LMB/Touch release
		if not input_handled:
			var command_action_key = ""
			if Input.is_action_just_pressed("command_approach"):
				command_action_key = "approach"
			elif Input.is_action_just_pressed("command_orbit"):
				command_action_key = "orbit"
			elif Input.is_action_just_pressed("command_flee"):
				command_action_key = "flee"
			# Stop key check moved below

			if command_action_key != "":
				input_handled = true  # CONSUME event if handled
				match command_action_key:
					"approach", "orbit", "flee":
						if is_instance_valid(_selected_target):
							match command_action_key:
								"approach":
									agent_script.command_approach(_selected_target)
								"orbit":
									agent_script.command_orbit(_selected_target)  # Assuming default distance/direction is ok here
								"flee":
									agent_script.command_flee(_selected_target)
							print(
								"Command Input: ",
								command_action_key.to_upper(),
								" ",
								_selected_target.name
							)
						else:
							print("Command Input: ", command_action_key, " failed - no target.")
							input_handled = false  # Don't consume if failed
					_:
						input_handled = false  # Don't consume unknown actions

	# --- Stop Command (Keyboard) - Checked Regardless of Free Flight Mode --- # NEW CHECK POSITION
	# Moved outside the !_is_free_flight_mode block
	if not input_handled and Input.is_action_just_pressed("command_stop"):
		_issue_stop_command()  # Call helper
		input_handled = true  # CONSUME event

	# --- Consume Input ---
	if input_handled:
		get_viewport().set_input_as_handled()


# --- Click Handling Logic ---
func _handle_single_click(click_pos: Vector2):
	# Process click only when mouse is visible
	if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE:
		var target = _raycast_for_target(click_pos)
		self._selected_target = target


func _handle_double_click(click_pos: Vector2):
	# Process double click only when mouse is visible
	if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE:
		if is_instance_valid(agent_script) and is_instance_valid(_main_camera):
			var ray_origin = _main_camera.project_ray_origin(click_pos)
			var ray_normal = _main_camera.project_ray_normal(click_pos)
			var target_point = ray_origin + ray_normal * DEFAULT_MOVE_TO_PROJECTION_DIST
			print("Input: Double-Click Move To ", target_point)
			agent_script.command_move_to(target_point)
		# else: print("Move To Failed")


# --- Signal Handling ---


# ---- From GUI ----
func _on_Player_Free_Flight_Toggled():
	_toggle_free_flight()


func _on_Player_Stop_Pressed():
	# agent_script.command_stop() # Replaced by helper call
	_issue_stop_command()  # Call helper


func _on_Player_Orbit_Pressed():
	# Check target validity before issuing command
	if is_instance_valid(_selected_target) and is_instance_valid(agent_script):
		agent_script.command_orbit(_selected_target)  # Assuming default distance/direction is okay
	else:
		print("PlayerController: Cannot Orbit - invalid target or agent.")


func _on_Player_Approach_Pressed():
	# Check target validity before issuing command
	if is_instance_valid(_selected_target) and is_instance_valid(agent_script):
		agent_script.command_approach(_selected_target)
	else:
		print("PlayerController: Cannot Approach - invalid target or agent.")


func _on_Player_Flee_Pressed():
	# Check target validity before issuing command
	if is_instance_valid(_selected_target) and is_instance_valid(agent_script):
		agent_script.command_flee(_selected_target)
	else:
		print("PlayerController: Cannot Flee - invalid target or agent.")


# --- Command Issuance Helpers --- # NEW SECTION
func _issue_stop_command():
	if not is_instance_valid(agent_script):
		printerr("PlayerController Error: AgentScript invalid, cannot issue stop command.")
		return

	print("Command Input: STOP")
	agent_script.command_stop()

	# Check if in free flight mode and disable it if necessary
	if _is_free_flight_mode:
		# Directly call the parts of _toggle_free_flight needed to exit the mode,
		# without toggling the state variable again.
		print("Stop command issued while in Free Flight. Exiting Free Flight...")
		_is_free_flight_mode = false  # Set state directly
		Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
		if is_instance_valid(_main_camera):
			if _main_camera.has_method("set_rotation_input_active"):
				_main_camera.set_rotation_input_active(false)
			if _main_camera.has_method("set_is_rotating"):
				_main_camera.set_is_rotating(false)
		# The stop command was already issued above, so agent_script.command_stop() from the original
		# _toggle_free_flight's exit logic is not needed here.
		_lmb_pressed = false
		_is_dragging = false


# --- Helper Raycast Function ---
func _raycast_for_target(screen_pos: Vector2) -> Spatial:
	if not is_instance_valid(agent_body):
		return null
	var camera = get_viewport().get_camera()
	if not is_instance_valid(camera):
		return null
	var ray_origin = camera.project_ray_origin(screen_pos)
	var ray_normal = camera.project_ray_normal(screen_pos)
	var ray_end = ray_origin + ray_normal * Constants.TARGETING_RAY_LENGTH
	var space_state = agent_body.get_world().direct_space_state
	var result = space_state.intersect_ray(ray_origin, ray_end, [agent_body], 1)
	if result and result.collider is Spatial:
		return result.collider
	else:
		return null


# --- Free Flight Toggle Logic ---
# Uses CAPTURED mode
func _toggle_free_flight():
	# We now only handle *entering* free flight here, or toggling when
	# triggered by its dedicated key/button. Exiting via Stop is handled separately.
	var intended_state = not _is_free_flight_mode

	print("Toggling Free Flight Mode. Intended State: ", "ON" if intended_state else "OFF")

	if intended_state == true:  # Entering Free Flight
		_is_free_flight_mode = true
		Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)  # Using CAPTURED
		if is_instance_valid(_main_camera) and _main_camera.has_method("set_rotation_input_active"):
			_main_camera.set_rotation_input_active(true)
		_is_dragging = false  # Clear drag state
		if is_instance_valid(_main_camera) and _main_camera.has_method("set_is_rotating"):
			_main_camera.set_is_rotating(false)
	elif _is_free_flight_mode == true:  # Explicitly toggling OFF (not via stop command)
		_is_free_flight_mode = false
		Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
		if is_instance_valid(_main_camera):
			if _main_camera.has_method("set_rotation_input_active"):
				_main_camera.set_rotation_input_active(false)
			if _main_camera.has_method("set_is_rotating"):
				_main_camera.set_is_rotating(false)
		# If toggling off normally, issue a stop command as well.
		if is_instance_valid(agent_script):
			# Call the helper to ensure consistency, though it won't toggle free flight again
			_issue_stop_command()
		_lmb_pressed = false
		_is_dragging = false

--- Start of ./modules/piloting/scripts/ship_controller_ai.gd ---

# File: modules/piloting/scripts/ship_controller_ai.gd
# Attach to Node child of AgentBody in npc_agent.tscn
# Version 2.1 - Simplified for agent command execution model

extends Node

# --- References ---
# Set in _ready()
var agent_script: Node = null  # Reference to the parent agent.gd script instance


# --- Initialization ---
func _ready():
	# Get reference to parent agent script
	var parent = get_parent()
	# Check if parent is the correct type and has the command methods
	if parent is KinematicBody and parent.has_method("command_move_to"):
		agent_script = parent
		# print("AI Controller ready for: ", agent_script.agent_name) # Optional Debug
	else:
		printerr(
			"AI Controller Error: Parent node is not an Agent KinematicBody with command methods!"
		)
		# If setup fails, this controller can't function.
		# We can disable physics process (though it's empty now)
		# or even detach the script to prevent errors.
		set_physics_process(false)
		set_script(null)  # Detach script if parent is wrong


# Called by WorldManager's spawn_agent function (via initialize dictionary in agent.gd)
# The 'config' dictionary here is the 'overrides' passed to spawn_agent
func initialize(config: Dictionary):
	# Ensure agent script reference is valid before issuing command
	if not is_instance_valid(agent_script):
		printerr("AI Initialize Error: Agent script invalid. Cannot issue command.")
		return

	# Read necessary parameters from config dictionary if present
	var stopping_dist = config.get("stopping_distance", 10.0)  # May not be needed by AI now
	# TODO: Agent's MOVE_TO command should probably use its own internal stopping distance logic

	# Immediately issue the initial command based on 'initial_target' in config
	if config.has("initial_target") and config.initial_target is Vector3:
		var target_pos = config.initial_target
		print(agent_script.agent_name, " AI issuing command: MOVE_TO ", target_pos)
		# Call the command method on the agent script
		agent_script.command_move_to(target_pos)
	else:
		# If no target, the agent remains IDLE (its default state)
		if is_instance_valid(agent_script):  # Check again just in case
			print(
				"AI Controller Warning: No initial target provided for ",
				agent_script.agent_name,
				". Agent will remain idle."
			)

# --- No Physics Update Needed ---
# For this simple "go-to" AI, the agent itself executes the command issued
# during initialize. This controller doesn't need to do anything frame-by-frame.
# More complex AI would have state machines here, checking conditions and
# issuing different commands (approach, orbit, flee, etc.) as needed.
# func _physics_process(delta):
#     pass

# --- No Event Handling Needed Here ---
# The agent itself now emits "agent_reached_destination" via EventBus
# when its relevant command (MOVE_TO -> STOPPING -> IDLE) completes.
# WorldManager listens for that signal to trigger the despawn.
# func _handle_target_reached(): # Removed
# func _on_Agent_Reached_Destination(agent_body): # Removed

# --- No Public Functions Needed Here ---
# func set_target(new_target: Vector3): # Removed - command issued once at init

--- Start of ./scenes/camera/orbit_camera.gd ---

# File: scenes/camera/orbit_camera.gd
# Version 1.26 - Added rotation acceleration based on mouse input intensity. Rotation speed adjusted, pitch reversed.

extends Camera

# --- Configuration ---
var distance: float = 55.0
var min_distance_multiplier: float = 2.0
var max_distance_multiplier: float = 15.0
var preferred_distance_multiplier: float = 2.0
const MIN_ABSOLUTE_DISTANCE = 1.0
const MAX_ABSOLUTE_DISTANCE = 500.0
var zoom_speed: float = 1.0

# var rotation_speed: float = 0.004 # REMOVED - Replaced by acceleration logic
var pitch_min: float = -1.55
var pitch_max: float = 1.55
var position_smoothing_speed: float = 17.0
var rotation_smoothing_speed: float = 22.0  # Now affects how fast camera *looks at* target
var bob_frequency: float = 0.06
var bob_amplitude: float = 0.06

# --- FoV Configuration ---
var _min_fov_deg: float = 40.0
var _max_fov_deg: float = 100.0

# --- Rotation Acceleration Config --- (Internal, set via initialize)
var _rotation_max_speed: float = 0.10  # Max angular speed (radians/sec) from full mouse motion
var _rotation_acceleration: float = 15.0  # How quickly speed changes towards target
var _rotation_damping: float = 10.0  # How quickly speed decays when no input (higher = faster stop)
var _rotation_input_curve: float = 1.5  # Power curve for mouse input (1 = linear, >1 = faster ramp-up)

# --- Internal State ---
var _target: Spatial = null
var _target_radius: float = 15.0
var _yaw: float = PI
var _pitch: float = 0.25
var _current_distance: float = 55.0
var _rotation_input_active: bool = false  # Free flight flag
var _is_externally_rotating: bool = false  # LMB/Touch drag flag
var _bob_timer: float = 0.0

# --- Rotation Acceleration State ---
var _target_yaw_speed: float = 0.0
var _target_pitch_speed: float = 0.0
var _current_yaw_speed: float = 0.0
var _current_pitch_speed: float = 0.0


# --- Initialization ---
func _ready():
	_current_distance = distance
	_yaw = PI
	_pitch = 0.25
	set_as_toplevel(true)
	GlobalRefs.main_camera = self

	# Connect signals... (same as before)
	if EventBus:
		if not EventBus.is_connected(
			"camera_set_target_requested", self, "_on_Camera_Set_Target_Requested"
		):
			var err = EventBus.connect(
				"camera_set_target_requested", self, "_on_Camera_Set_Target_Requested"
			)
			if err != OK:
				printerr("Camera Error: Failed connect signal! Code: ", err)
	else:
		printerr("Camera Error: EventBus not available!")

	# Proactive player check... (same as before)
	if not is_instance_valid(_target):
		if is_instance_valid(GlobalRefs.player_agent_body):
			set_target_node(GlobalRefs.player_agent_body)
	_update_fov()


func initialize(config: Dictionary):
	# Initialize standard config... (same as before)
	if config.has("distance"):
		self.distance = config.distance
	# ... other standard params ...
	if config.has("bob_amplitude"):
		self.bob_amplitude = config.bob_amplitude

	# Initialize FoV limits... (same as before)
	if config.has("min_fov_deg"):
		self._min_fov_deg = config.min_fov_deg
	if config.has("max_fov_deg"):
		self._max_fov_deg = config.max_fov_deg

	# --- ADDED: Initialize Rotation Acceleration limits from config ---
	if config.has("rotation_max_speed"):
		self._rotation_max_speed = config.rotation_max_speed
	if config.has("rotation_acceleration"):
		self._rotation_acceleration = config.rotation_acceleration
	if config.has("rotation_damping"):
		self._rotation_damping = config.rotation_damping
	if config.has("rotation_input_curve"):
		self._rotation_input_curve = config.rotation_input_curve
	# --- End Added ---

	self._yaw = deg2rad(config.get("initial_yaw_deg", 180.0))
	self._pitch = clamp(deg2rad(config.get("initial_pitch_deg", 15.0)), pitch_min, pitch_max)
	_current_distance = self.distance

	print("OrbitCamera initialized.")


# --- Input Handling ---
func _unhandled_input(event):
	# Rotation Input (Mouse Motion) - Now sets TARGET speed
	if event is InputEventMouseMotion:
		if _rotation_input_active or _is_externally_rotating:
			# Calculate input strength (normalize relative motion magnitude, maybe clamp)
			# Note: event.relative can be large, might need scaling factor if uncapped
			var input_strength_x = abs(event.relative.x)  # Normalize roughly? Or use fixed divisor?
			var input_strength_y = abs(event.relative.y)

			# Apply power curve for non-linear response
			input_strength_x = pow(input_strength_x, _rotation_input_curve)
			input_strength_y = pow(input_strength_y, _rotation_input_curve)

			# Set target speed based on direction and scaled strength
			_target_yaw_speed = -sign(event.relative.x) * input_strength_x * _rotation_max_speed
			_target_pitch_speed = -sign(event.relative.y) * input_strength_y * _rotation_max_speed  # Note: Pitch might feel inverted, adjust sign if needed

			# Consume the event so other UI elements don't process drag motion
			get_viewport().set_input_as_handled()

	# Zoom Input (Wheel) - Unchanged
	elif event is InputEventMouseButton and is_instance_valid(_target):
		var dyn_min_dist = _get_dynamic_min_distance()
		var dyn_max_dist = _get_dynamic_max_distance()
		var zoom_factor = 1.0 + (zoom_speed * 0.1)
		var input_handled = false
		if event.button_index == BUTTON_WHEEL_UP and event.pressed:
			_current_distance = max(dyn_min_dist, _current_distance / zoom_factor)
			input_handled = true
		elif event.button_index == BUTTON_WHEEL_DOWN and event.pressed:
			_current_distance = min(dyn_max_dist, _current_distance * zoom_factor)
			input_handled = true
		if input_handled:
			get_viewport().set_input_as_handled()


# --- Physics Update ---
func _physics_process(delta):
	_bob_timer += delta

	# --- Update FoV --- (Unchanged)
	if is_instance_valid(_target):
		_update_fov()

	# --- Update Rotation based on Speed --- ADDED ---
	var rot_active = _rotation_input_active or _is_externally_rotating
	# If rotation isn't active, force target speed to 0 to ensure damping works
	if not rot_active:
		_target_yaw_speed = 0.0
		_target_pitch_speed = 0.0

	# Interpolate current speed towards target speed (Acceleration)
	_current_yaw_speed = lerp(_current_yaw_speed, _target_yaw_speed, _rotation_acceleration * delta)
	_current_pitch_speed = lerp(
		_current_pitch_speed, _target_pitch_speed, _rotation_acceleration * delta
	)

	# Apply damping (always active, brings speed back to 0)
	var damp_factor = 1.0 - (_rotation_damping * delta)  # Needs delta adjustment for frame independence
	# Clamp damp_factor to prevent reversal if delta is large or damping is high
	damp_factor = max(0.0, damp_factor)
	_current_yaw_speed *= damp_factor
	_current_pitch_speed *= damp_factor

	# Apply calculated rotation speeds to angles
	_yaw += _current_yaw_speed * delta
	_pitch -= _current_pitch_speed * delta
	_pitch = clamp(_pitch, pitch_min, pitch_max)  # Keep pitch within limits

	# Reset target speed for next frame (input will overwrite if motion occurs)
	# This ensures damping takes over if input stops suddenly
	_target_yaw_speed = 0.0
	_target_pitch_speed = 0.0
	# --- End Rotation Update ---

	# --- Update Position and LookAt ---
	if not is_instance_valid(_target):
		# Detached Mode (Apply only rotation)
		var new_basis = Basis().rotated(Vector3.UP, _yaw).rotated(
			Basis().rotated(Vector3.UP, _yaw).x, _pitch
		)
		global_transform.basis = global_transform.basis.slerp(
			new_basis.orthonormalized(), rotation_smoothing_speed * delta
		)
		return

	# --- Attached Mode --- (Position + LookAt)
	var target_pos = _target.global_transform.origin
	var bob_offset = (
		global_transform.basis.y
		* sin(_bob_timer * bob_frequency * TAU)
		* bob_amplitude
	)
	# Calculate desired orientation first based on yaw/pitch
	var desired_basis = Basis().rotated(Vector3.UP, _yaw).rotated(
		Basis().rotated(Vector3.UP, _yaw).x, _pitch
	)
	# Calculate desired position based on orientation and distance
	var position_offset = -desired_basis.z * _current_distance
	var desired_position = target_pos + position_offset + bob_offset

	# Interpolate Position
	global_transform.origin = global_transform.origin.linear_interpolate(
		desired_position, position_smoothing_speed * delta
	)

	# Interpolate Look At (still smoothly look at target even while manually rotating)
	var target_look_transform = global_transform.looking_at(target_pos, Vector3.UP)
	global_transform.basis = global_transform.basis.slerp(
		target_look_transform.basis.orthonormalized(), rotation_smoothing_speed * delta
	)


# --- Dynamic FoV Update Logic --- (Unchanged from v1.24)
func _update_fov():
	var dyn_min_dist = _get_dynamic_min_distance()
	var dyn_max_dist = _get_dynamic_max_distance()
	if is_equal_approx(dyn_max_dist, dyn_min_dist):
		self.fov = _max_fov_deg
		return
	var t = clamp((_current_distance - dyn_min_dist) / (dyn_max_dist - dyn_min_dist), 0.0, 1.0)
	self.fov = lerp(_min_fov_deg, _max_fov_deg, t)


# --- Helper functions for dynamic distances --- (Unchanged from v1.24)
func _get_dynamic_min_distance() -> float:
	if not is_instance_valid(_target):
		return MIN_ABSOLUTE_DISTANCE
	_target_radius = _get_target_effective_radius(_target)
	return max(MIN_ABSOLUTE_DISTANCE, _target_radius * min_distance_multiplier)


func _get_dynamic_max_distance() -> float:
	if not is_instance_valid(_target):
		return MAX_ABSOLUTE_DISTANCE
	var dyn_min_dist = _get_dynamic_min_distance()
	var dyn_max_calc = max(dyn_min_dist + 1.0, _target_radius * max_distance_multiplier)
	return min(MAX_ABSOLUTE_DISTANCE, dyn_max_calc)


# --- Signal Handler & Public Functions --- (External control functions unchanged)
func _on_Camera_Set_Target_Requested(target_node):
	set_target_node(target_node)


func set_rotation_input_active(is_active: bool):
	_rotation_input_active = is_active
	if is_active:
		_is_externally_rotating = false


func set_is_rotating(rotating: bool):
	if not _rotation_input_active:
		_is_externally_rotating = rotating


# --- set_target_node, _get_target_effective_radius, get_current_target, _notification ---
# (Unchanged from v1.24)
func set_target_node(new_target: Spatial):
	var target_changed = false
	if is_instance_valid(new_target):
		if _target != new_target:
			_target = new_target
			_target_radius = _get_target_effective_radius(_target)
			print("OrbitCamera target set to: ", new_target.name, " | Eff Radius: ", _target_radius)
			var dyn_min_dist = _get_dynamic_min_distance()
			var dyn_max_dist = _get_dynamic_max_distance()
			var preferred_dist = max(dyn_min_dist, _target_radius * preferred_distance_multiplier)
			_current_distance = clamp(preferred_dist, dyn_min_dist, dyn_max_dist)
			print("  Reset distance to: ", _current_distance)
			target_changed = true
	else:
		if _target != null:
			print("OrbitCamera target cleared.")
			target_changed = true
		_target = null
		_target_radius = 10.0
	if target_changed:
		_update_fov()


func _get_target_effective_radius(target_node: Spatial) -> float:
	var default_radius = 10.0
	if not is_instance_valid(target_node):
		return default_radius
	if target_node.has_method("get_interaction_radius"):
		var radius = target_node.get_interaction_radius()
		if (radius is float or radius is int) and radius > 0.0:
			return max(radius, 1.0)
	return default_radius


func get_current_target() -> Spatial:
	if is_instance_valid(_target):
		return _target
	else:
		return null


func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		if (
			EventBus
			and EventBus.is_connected(
				"camera_set_target_requested", self, "_on_Camera_Set_Target_Requested"
			)
		):
			EventBus.disconnect(
				"camera_set_target_requested", self, "_on_Camera_Set_Target_Requested"
			)
		if GlobalRefs and GlobalRefs.main_camera == self:
			GlobalRefs.main_camera = null

--- Start of ./scenes/game_world/world_manager.gd ---

# File: scenes/game_world/world_manager.gd
# Version 2.3 - Code style cleanup (Tabs, Line Length, If/Else)

extends Node

# --- NodePaths ---
const ACTIVE_MODULE_CONTAINER_PATH = "../" + Constants.CURRENT_ZONE_CONTAINER_NAME

# --- State ---
var current_zone_instance: Node = null
var _spawned_agent_bodies = []
var _player_agent_body: KinematicBody = null


# --- Initialization ---
func _ready():
	GlobalRefs.world_manager = self
	if EventBus:
		var err1 = EventBus.connect(
			"agent_reached_destination", self, "_on_Agent_Reached_Destination"
		)
		var err2 = EventBus.connect("agent_despawning", self, "_on_Agent_Despawning")
		var err3 = EventBus.connect("zone_loaded", self, "_on_Zone_Loaded_WorldManager")
		if err1 != OK or err2 != OK or err3 != OK:
			printerr("WM _ready Error: Failed connect EventBus signals!")
	else:
		printerr("WM _ready Error: EventBus not available!")

	randomize()
	print("WM: 1/13 - _ready started.")
	print("WM _ready Debug: Checking Constant value...")
	print("- Constants.INITIAL_ZONE_SCENE_PATH = '", Constants.INITIAL_ZONE_SCENE_PATH, "'")
	print("- Type = ", typeof(Constants.INITIAL_ZONE_SCENE_PATH))

	print("WM: 2/13 - Attempting load_zone...")
	load_zone(Constants.INITIAL_ZONE_SCENE_PATH)
	print("WM: 9/13 - Returned from initial load_zone call.")
	print("WM: 10/13 - _ready finished (Player spawn handled by signal).")


# --- Zone Management ---
func load_zone(zone_scene_path: String):
	print("WM: 3/13 - load_zone starting for path: ", zone_scene_path)

	if not zone_scene_path or zone_scene_path.empty():
		printerr("WM Error: Invalid zone path provided.")
		return

	# 1. Cleanup Previous Zone
	if is_instance_valid(current_zone_instance):
		EventBus.emit_signal("zone_unloading", current_zone_instance)
		_spawned_agent_bodies.clear()
		_player_agent_body = null
		GlobalRefs.player_agent_body = null
		GlobalRefs.current_zone = null
		GlobalRefs.agent_container = null
		current_zone_instance.queue_free()
		current_zone_instance = null

	# 2. Find Parent Container Node
	var parent_node = get_parent()
	if not is_instance_valid(parent_node):
		printerr("WM Error: Could not get valid parent node!")
		return
	var zone_holder = parent_node.get_node_or_null(Constants.CURRENT_ZONE_CONTAINER_NAME)

	if not zone_holder:
		printerr(
			"WM Error: Node '",
			Constants.CURRENT_ZONE_CONTAINER_NAME,
			"' missing as child of parent '",
			parent_node.name,
			"'"
		)
		return
	print("WM: 4/13 - Found zone holder: ", zone_holder.name)

	# 3. Load and Instance the Zone Scene
	var zone_scene = load(zone_scene_path)
	if not zone_scene:
		printerr("WM Error: Failed load Zone Scene Resource: ", zone_scene_path)
		return

	current_zone_instance = zone_scene.instance()
	if not current_zone_instance:
		printerr("WM Error: Failed instance Zone Scene: ", zone_scene_path)
		return

	print("WM: 5/13 - Instanced Zone Scene: ", current_zone_instance.name)

	# 4. Add Zone to Tree & Update GlobalRefs for Zone
	zone_holder.add_child(current_zone_instance)
	GlobalRefs.current_zone = current_zone_instance

	# 5. Find Agent Container *within* the Zone & Update GlobalRef
	if not is_instance_valid(current_zone_instance):
		printerr("WM Error: current_zone_instance invalid after add_child?")
		return

	var agent_cont_ref = current_zone_instance.find_node(
		Constants.AGENT_CONTAINER_NAME, true, false
	)
	GlobalRefs.agent_container = agent_cont_ref
	print("WM: 6/13 - Found Agent Container: ", agent_cont_ref)
	if not agent_cont_ref:
		printerr(
			"WM Warning: Agent container '", Constants.AGENT_CONTAINER_NAME, "' not found in zone."
		)

	# 6. Emit Loaded Signal
	print("WM: 7/13 - Emitting zone_loaded signal.")
	EventBus.emit_signal(
		"zone_loaded", current_zone_instance, zone_scene_path, GlobalRefs.agent_container
	)
	print("WM: 8/13 - load_zone finished.")


# --- Agent Spawning & Management ---
# Called by handler for zone_loaded signal
func spawn_player():
	print("WM: 12/13 - spawn_player called.")
	var container = GlobalRefs.agent_container
	if not is_instance_valid(container):
		printerr("WM spawn_player Error: GlobalRefs.agent_container invalid.")
		return

	var player_template = load(Constants.PLAYER_DEFAULT_TEMPLATE_PATH)
	if not player_template is AgentTemplate:
		printerr("WM Error: Failed load Player AgentTemplate")
		return

	var player_spawn_pos = Vector3.ZERO
	var env_instance = GlobalRefs.current_zone
	if is_instance_valid(env_instance):
		var entry_node = null
		if Constants.ENTRY_POINT_NAMES.size() > 0:
			entry_node = env_instance.find_node(Constants.ENTRY_POINT_NAMES[0], true, false)
		if entry_node is Spatial:
			player_spawn_pos = entry_node.global_transform.origin + Vector3(0, 5, 15)

	var player_overrides = {"name": "PlayerShip", "faction": "Player"}
	_player_agent_body = spawn_agent(
		Constants.PLAYER_AGENT_SCENE_PATH, player_spawn_pos, player_template, player_overrides
	)

	if is_instance_valid(_player_agent_body):
		GlobalRefs.player_agent_body = _player_agent_body
		EventBus.emit_signal("camera_set_target_requested", _player_agent_body)
		EventBus.emit_signal("player_spawned", _player_agent_body)
	else:
		printerr("WorldManager Error: Failed to spawn player agent body!")
	print("WM: 13/13 - spawn_player finished.")


# Generic function CALLED BY EXTERNAL systems
func spawn_agent(
	agent_scene_path: String,
	position: Vector3,
	agent_template: Resource,
	overrides: Dictionary = {}
) -> KinematicBody:
	var container = GlobalRefs.agent_container
	if not is_instance_valid(container):
		printerr("WM Spawn Error: Invalid GlobalRefs.agent_container.")
		return null
	if not agent_template is AgentTemplate:
		printerr("WM Spawn Error: Invalid AgentTemplate Resource.")
		return null
	if not agent_scene_path or agent_scene_path.empty():
		printerr("WM Spawn Error: Invalid scene path.")
		return null

	var agent_scene = load(agent_scene_path)
	if not agent_scene:
		printerr("WM Spawn Error: Failed load agent scene: ", agent_scene_path)
		return null
	var agent_root_instance = agent_scene.instance()
	if not agent_root_instance:
		printerr("WM Spawn Error: Failed instance agent scene!")
		return null

	var agent_node = agent_root_instance.get_node_or_null(Constants.AGENT_BODY_NODE_NAME)
	if not agent_node or not agent_node is KinematicBody:
		var error_msg = str(
			"WM Spawn Error: Invalid node '",
			Constants.AGENT_BODY_NODE_NAME,
			"' in scene: ",
			agent_scene_path
		)
		printerr(error_msg)
		agent_root_instance.queue_free()
		return null

	var instance_name = overrides.get(
		"name", agent_template.default_agent_name + "_" + str(agent_root_instance.get_instance_id())
	)
	agent_root_instance.name = instance_name

	container.add_child(agent_root_instance)
	agent_node.global_transform.origin = position

	if agent_node.has_method("initialize"):
		agent_node.initialize(agent_template, overrides)

	_spawned_agent_bodies.append(agent_node)
	var name_to_print = instance_name
	# Expanded check using 'in' for property existence
	if "agent_name" in agent_node:
		name_to_print = agent_node.agent_name
	print("Spawned agent '", name_to_print, "' core node.")

	EventBus.emit_signal(
		"agent_spawned", agent_node, {"template": agent_template, "overrides": overrides}
	)

	var controller = agent_node.get_node_or_null(Constants.AI_CONTROLLER_NODE_NAME)
	if controller and controller.has_method("initialize"):
		controller.initialize(overrides)
	elif controller and controller.has_method("set_target") and ("initial_target" in overrides):
		controller.set_target(overrides.initial_target)

	return agent_node


# --- Signal Handlers ---
func _on_Agent_Reached_Destination(agent_body):
	if is_instance_valid(agent_body) and agent_body != _player_agent_body:
		if agent_body.has_method("despawn"):
			agent_body.despawn()
		else:
			agent_body.queue_free()  # Fallback
	elif is_instance_valid(agent_body) and agent_body == _player_agent_body:
		pass  # Player reached destination, do nothing here


func _on_Agent_Despawning(agent_body):
	call_deferred("_cleanup_despawned_agent_from_list", agent_body)


func _cleanup_despawned_agent_from_list(agent_instance):
	if _spawned_agent_bodies.has(agent_instance):
		_spawned_agent_bodies.erase(agent_instance)
	# Expanded check
	if _player_agent_body == agent_instance:
		print("Player agent reference cleared during cleanup.")
		_player_agent_body = null
		GlobalRefs.player_agent_body = null


func _on_Zone_Loaded_WorldManager(_zone_instance, _zone_path, agent_container_node):
	print("WM: 11/13 - Reacting to zone_loaded signal.")
	if is_instance_valid(agent_container_node):
		if not is_instance_valid(_player_agent_body):
			# Try direct call again now that other issues might be fixed
			spawn_player()
	else:
		printerr("WM _on_Zone_Loaded Error: Agent container invalid. Cannot spawn player.")


# --- Cleanup ---
func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		print("!!! WM: RECEIVED NOTIFICATION_PREDELETE !!!")
		if EventBus:
			# Expanded disconnect checks
			if EventBus.is_connected(
				"agent_reached_destination", self, "_on_Agent_Reached_Destination"
			):
				EventBus.disconnect(
					"agent_reached_destination", self, "_on_Agent_Reached_Destination"
				)
			if EventBus.is_connected("agent_despawning", self, "_on_Agent_Despawning"):
				EventBus.disconnect("agent_despawning", self, "_on_Agent_Despawning")
			if EventBus.is_connected("zone_loaded", self, "_on_Zone_Loaded_WorldManager"):
				EventBus.disconnect("zone_loaded", self, "_on_Zone_Loaded_WorldManager")
		# Expanded GlobalRefs check
		if GlobalRefs and GlobalRefs.world_manager == self:
			GlobalRefs.world_manager = null
		# Expanded instance check
		if is_instance_valid(current_zone_instance):
			current_zone_instance.queue_free()

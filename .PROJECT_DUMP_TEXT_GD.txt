--- Start of ./autoload/Constants.gd ---

# File: autoload/Constants.gd
# Autoload Singleton: Constants
# Version: 1.3 - Reverted paths/names for Complete Zone Scene architecture

extends Node

# --- Scene Paths ---
const PLAYER_AGENT_SCENE_PATH = "res://core/agents/player_agent.tscn"
const NPC_AGENT_SCENE_PATH = "res://core/agents/npc_agent.tscn"

# Complete Zone Scene Paths (Self-contained environments with AgentContainer etc.)
const INITIAL_ZONE_SCENE_PATH = "res://scenes/zones/basic_flight_zone.tscn"
# Example future zones:
# const ZONE_ASTEROID_BELT_BETA_PATH = "res://scenes/zones/asteroid_belt_beta.tscn"
# const ZONE_SCRAPYARD_STATION_PATH = "res://scenes/zones/scrapyard_station.tscn"

# Agent Template Resource Paths
const PLAYER_DEFAULT_TEMPLATE_PATH = "res://assets/data/templates/agents/player_default.tres"
const NPC_TRAFFIC_TEMPLATE_PATH = "res://assets/data/templates/agents/npc_traffic_base.tres"

# Base UI Scenes
const MAIN_HUD_SCENE_PATH = "res://core/ui/main_hud.tscn"
const MAIN_MENU_SCENE_PATH = "res://scenes/main_menu/main_menu.tscn"

# --- Common Node Names ---
# Inside main_game_scene.tscn
const CURRENT_ZONE_CONTAINER_NAME = "CurrentZoneContainer" # Node holding the loaded zone instance

# Inside Zone Scenes (e.g., basic_flight_zone.tscn)
const AGENT_CONTAINER_NAME = "AgentContainer" # Child node for housing agents
const AGENT_MODEL_CONTAINER_NAME = "Model"
const ENTRY_POINT_NAMES = ["EntryPointA", "EntryPointB", "EntryPointC"] # Expected Position3D/Spatial nodes

# Inside Agent Scenes (e.g., agent.tscn, npc_agent.tscn)
const AGENT_BODY_NODE_NAME = "AgentBody"     # The KinematicBody root in agent scenes
# MOVEMENT_COMPONENT_NAME removed as component was merged
const AI_CONTROLLER_NODE_NAME = "AIController"
const PLAYER_INPUT_HANDLER_NAME = "PlayerInputHandler"

# --- Core Mechanics Thresholds ---
const ACTION_CHECK_FAIL_THRESHOLD = 10
const ACTION_CHECK_SWC_THRESHOLD = 10
const ACTION_CHECK_CRIT_THRESHOLD = 14

# --- Core Mechanics Parameters ---
const FOCUS_MAX_DEFAULT = 3
const FOCUS_BOOST_PER_POINT = 1

# --- Default Simulation Values ---
const DEFAULT_MAX_MOVE_SPEED = 50.0
const DEFAULT_ACCELERATION = 10.0
const DEFAULT_DECELERATION = 15.0
const DEFAULT_MAX_TURN_SPEED = 2.0

# --- System Defaults (Examples - Used by placeholder systems) ---
const MAX_NPCS_DEFAULT = 10
const SPAWN_INTERVAL_DEFAULT = 2.0
const TRAFFIC_SPEED_MULT_DEFAULT = 0.2
const TARGETING_RAY_LENGTH = 1e4

--- Start of ./autoload/CoreMechanicsAPI.gd ---

# File: autoload/CoreMechanicsAPI.gd
# Autoload Singleton: CoreMechanicsAPI
# Purpose: Provides globally accessible functions for core mechanic resolutions,
#          ensuring consistency across the game.
# Version: 1.0

extends Node

# Random Number Generator for dice rolls
var _rng = RandomNumberGenerator.new()

func _ready():
	# Seed the random number generator once when the game starts
	_rng.randomize()
	print("CoreMechanicsAPI Ready.")

# --- Core Action Resolution ---

# Performs the standard 3d6+Mod Action Check based on passed parameters.
# Returns a Dictionary containing the detailed results of the check.
# - module_modifier: The calculated modifier for the current action context (Skill + Asset Diff).
# - focus_points_spent: How many FP the player chose to spend (0-3) *before* the roll.
# Return Dictionary keys:
#   "roll_total": int (Final result after mods/FP)
#   "dice_sum": int (Result of 3d6 only)
#   "modifier": int (Module modifier passed in)
#   "focus_spent": int (FP spent)
#   "focus_bonus": int (Bonus gained from FP)
#   "result_tier": String ("CritSuccess", "SwC", "Failure")
#   "focus_gain": int (FP gained from this result, usually 1 on Crit)
#   "focus_loss_reset": bool (True if FP should be reset to 0 due to Failure)
func perform_action_check(module_modifier: int, focus_points_spent: int) -> Dictionary:
	# Ensure focus spent is within valid range (0 to Max FP defined in Constants)
	focus_points_spent = clamp(focus_points_spent, 0, Constants.FOCUS_MAX_DEFAULT)

	# --- Roll Dice ---
	var d1 = _rng.randi_range(1, 6)
	var d2 = _rng.randi_range(1, 6)
	var d3 = _rng.randi_range(1, 6)
	var dice_sum = d1 + d2 + d3

	# --- Calculate Bonuses ---
	var focus_bonus = focus_points_spent * Constants.FOCUS_BOOST_PER_POINT

	# --- Calculate Final Roll ---
	var total_roll = dice_sum + module_modifier + focus_bonus

	# --- Determine Outcome Tier & Focus Effects ---
	var result_tier = ""
	var focus_gain = 0
	var focus_loss_reset = false

	if total_roll >= Constants.ACTION_CHECK_CRIT_THRESHOLD:
		result_tier = "CritSuccess"
		focus_gain = 1 # Standard gain on Crit
		focus_loss_reset = false
	elif total_roll >= Constants.ACTION_CHECK_SWC_THRESHOLD: # e.g., 10-13
		result_tier = "SwC" # Success with Complication
		focus_gain = 0
		focus_loss_reset = false
	else: # e.g., < 10
		result_tier = "Failure"
		focus_gain = 0
		focus_loss_reset = true # Standard reset on Failure

	# --- Assemble Results Dictionary ---
	var results = {
		"roll_total": total_roll,
		"dice_sum": dice_sum,
		"modifier": module_modifier,
		"focus_spent": focus_points_spent,
		"focus_bonus": focus_bonus,
		"result_tier": result_tier,
		"focus_gain": focus_gain,
		"focus_loss_reset": focus_loss_reset
	}

	# --- Optional: Emit Global Signal ---
	# If many systems need to react directly to *every* check result,
	# emitting a signal here could be useful later. Requires passing agent + approach.
	# EventBus.emit_signal("action_check_resolved", agent_ref, results, approach_ref)
	# For now, let the calling script handle reactions and FP updates.

	# print("Action Check: %d (3d6=%d, Mod=%d, FP=%d(+%d)) -> %s" % [total_roll, dice_sum, module_modifier, focus_points_spent, focus_bonus, result_tier]) # Debug

	return results


# --- Potential Future Core Mechanic Functions ---

# func update_focus_state(agent_stats_ref, focus_change: int):
#     # Central logic for applying focus gain/loss, respecting cap
#     pass

# func calculate_upkeep_cost(agent_assets_ref):
#     # Central logic for determining periodic WP upkeep cost
#     return 0 # Placeholder WP cost

# func advance_time_clock(agent_stats_ref_or_global, tu_amount: int):
#     # Central logic for adding TU and checking for World Event Tick trigger
#     pass

--- Start of ./autoload/EventBus.gd ---

# File: autoload/EventBus.gd
# Version: 1.1 Added target picking.

extends Node

# --- Game State Signals ---
signal game_loaded(save_data)
# signal game_saving(slot_id)
# signal save_complete(slot_id, success)

# --- Agent Lifecycle Signals ---
# Emitted by WorldManager after agent initialized and added to tree
# init_data parameter is now Dictionary {"template": Res, "overrides": Dict}
signal agent_spawned(agent_body, init_data)
# Emitted by Agent's despawn() method via EventBus BEFORE queue_free
signal agent_despawning(agent_body)
# Emitted by AI Controller via EventBus when destination reached
signal agent_reached_destination(agent_body)
# Emitted by WorldManager after player specifically spawned
signal player_spawned(player_agent_body)

# --- Camera Control Signals ---
# Emitted by systems requesting camera target change
signal camera_set_target_requested(target_node)
# Emitted by input handlers requesting target cycle (KEEPING for potential future use)
signal camera_cycle_target_requested()

# --- Player Interaction Signals --- ADDED SECTION
signal player_target_selected(target_node)
signal player_target_deselected()
signal player_free_flight_toggled()
signal player_stop_pressed()
signal player_orbit_pressed()
signal player_approach_pressed()
signal player_flee_pressed()

# --- Zone Loading Signals ---
# Emitted by WorldManager before unloading current zone instance
signal zone_unloading(zone_node) # zone_node is the root of the scene being unloaded
# Emitted by WorldManager when starting to load a new zone path
signal zone_loading(zone_path) # zone_path is path to the complete zone scene
# Emitted by WorldManager after new zone is instanced, added, container found
# zone_node is root of the new zone instance, agent_container_node is ref inside it
signal zone_loaded(zone_node, zone_path, agent_container_node)

# --- Core Mechanics / Gameplay Events (Placeholders) ---
# signal action_check_resolved(agent_body, result_dictionary, action_approach)
# signal focus_changed(agent_body, new_focus_value)
# signal wealth_changed(agent_body, new_wealth_value)
# signal world_event_tick_triggered()

# --- Goal System Events (Placeholders) ---
# signal goal_progress_updated(agent_body, goal_id, new_progress)
# signal goal_completed(agent_body, goal_id, success_level)

# --- Module Specific Signals (Placeholders - Use sparingly) ---
# signal major_discovery_made(discovery_data)

func _ready():
	print("EventBus Ready.")

--- Start of ./autoload/GameStateManager.gd ---

# File: autoload/GameStateManager.gd
# Autoload Singleton: GameStateManager
# Purpose: Handles saving and loading game state.
# Version: 1.1 - Corrected ProjectSettings.get_setting for Godot 3

extends Node

const SAVE_DIR = "user://savegames/"
const SAVE_FILE_PREFIX = "save_"
const SAVE_FILE_EXT = ".sav" # Godot's variant storage format

func _ready():
	print("GameStateManager Ready.")
	# Ensure save directory exists on startup
	var dir = Directory.new()
	if not dir.dir_exists(SAVE_DIR):
		var err = dir.make_dir_recursive(SAVE_DIR)
		if err != OK:
			printerr("GameStateManager Error: Could not create save directory: ", SAVE_DIR, " Error: ", err)

# --- Save Game ---
# Returns true on success, false on failure
func save_game(slot_id: int) -> bool:
	print("Attempting to save game to slot ", slot_id)
	var save_data = {} # Dictionary to hold all save data

	# --- गैदरिंग डाटा (Gathering Data) ---
	# 1. Player Data
	if is_instance_valid(GlobalRefs.player_agent_body):
		var player_data = {}
		player_data["scene_path"] = Constants.PLAYER_AGENT_SCENE_PATH
		player_data["position_x"] = GlobalRefs.player_agent_body.global_transform.origin.x
		player_data["position_y"] = GlobalRefs.player_agent_body.global_transform.origin.y
		player_data["position_z"] = GlobalRefs.player_agent_body.global_transform.origin.z
		player_data["rotation_basis_cols"] = [
			GlobalRefs.player_agent_body.global_transform.basis.x,
			GlobalRefs.player_agent_body.global_transform.basis.y,
			GlobalRefs.player_agent_body.global_transform.basis.z
		]
		save_data["player_state"] = player_data
	else:
		printerr("Save Error: Player agent body not valid!")
		return false

	# 2. Character System Data (FP, WP, Skills, etc.) - Assumed Placeholder
	if is_instance_valid(GlobalRefs.character_system) and GlobalRefs.character_system.has_method("get_player_save_data"):
		 save_data["character_state"] = GlobalRefs.character_system.get_player_save_data()
	else:
		 print("Save Warning: CharacterSystem missing or no save method. FP/WP/Skills NOT saved.")

	# 3. World State
	var world_data = {}
	if is_instance_valid(GlobalRefs.current_zone):
		world_data["current_zone_path"] = GlobalRefs.current_zone.filename
	else:
		printerr("Save Error: Current zone reference invalid!")
		return false
	# TODO: Add Time Clock Value - Requires Time System/Manager reference
	# world_data["time_clock_tu"] = GlobalRefs.time_manager.get_current_tu()
	save_data["world_state"] = world_data

	# 4. Goal System State - Assumed Placeholder
	# if is_instance_valid(GlobalRefs.goal_system) and GlobalRefs.goal_system.has_method("get_save_data"):
	#     save_data["goal_system_state"] = GlobalRefs.goal_system.get_save_data()

	# 5. Add Metadata
	# *** CORRECTED for Godot 3 ***
	var game_version_setting = ProjectSettings.get_setting("application/config/version")
	var game_version = "0.0.1" # Default version
	if game_version_setting != null:
		game_version = str(game_version_setting) # Ensure it's a string if found
	# *** END CORRECTION ***

	save_data["metadata"] = {
		"save_time": OS.get_unix_time(),
		"game_version": game_version
	}

	# --- Writing File ---
	var file = File.new()
	var path = SAVE_DIR + SAVE_FILE_PREFIX + str(slot_id) + SAVE_FILE_EXT
	var err = file.open(path, File.WRITE)

	if err == OK:
		# Use true for share/compression - valid in Godot 3
		file.store_var(save_data, true)
		file.close()
		print("Game saved successfully to: ", path)
		return true
	else:
		printerr("Error saving game to path: ", path, " Error code: ", err)
		file.close() # Ensure file is closed even on error
		return false

# --- Load Game ---
# Returns true on success, false on failure
func load_game(slot_id: int) -> bool:
	print("Load attempt for slot ", slot_id)
	var path = get_save_slot_path(slot_id)
	print("Load path: ", path)

	var file = File.new()
	if not file.file_exists(path):
		 printerr("Load Error: Save file not found at path!")
		 return false

	print("Load Debug: File exists. Attempting to open...")
	var err = file.open(path, File.READ)
	if err != OK:
		printerr("Load Error: Failed to open file for reading! Error code: ", err)
		return false

	print("Load Debug: File opened. Attempting to get var...")
	# Use true if store_var used true
	var save_data = file.get_var(true)
	var file_err = file.get_error() # Check error *after* operation
	file.close() # Close file immediately

	if file_err != OK:
		printerr("Load Error: Error reading var from file! File Error code: ", file_err)
		return false

	print("Load Debug: Got var. Checking type...")
	if not save_data is Dictionary:
		printerr("Load Error: Save file data is not a Dictionary! Type is: ", typeof(save_data))
		return false

	print("Save file loaded successfully. Applying state...")
	# ... (Placeholder apply logic) ...
	EventBus.emit_signal("game_loaded", save_data)
	return true

	# --- Apply Loaded State ---
	# This section requires careful coordination with scene loading and initialization.
	# It might need to emit signals or use call_deferred extensively.
	# Placeholder logic - assumes this is called from a state where loading is safe (e.g., main menu)

	# 1. Request Zone Load (WorldManager listens for this?) - NEEDS A ROBUST WORKFLOW
	if save_data.has("world_state") and save_data.world_state.has("current_zone_path"):
		var zone_path = save_data.world_state.current_zone_path
		if is_instance_valid(GlobalRefs.world_manager) and GlobalRefs.world_manager.has_method("load_zone"):
			# Ideally, loading should happen via scene transition, not direct call here.
			# For now, just logging. Actual loading needs proper handling.
			print("Load Request: Need to load zone: ", zone_path)
			# GlobalRefs.world_manager.load_zone(zone_path) # Direct call here is usually problematic
			# Need a system to handle scene transition THEN player spawn/restore
			# Emit signal instead? EventBus.emit_signal("load_zone_requested", zone_path, save_data)
		else:
			printerr("Load Error: Cannot request zone load, WorldManager invalid/missing method.")
			return false
	else:
		printerr("Load Error: Save data missing world state or zone path.")
		return false

	# 2. Restore Player State (Should happen AFTER zone is loaded)
	# This logic needs to be triggered *after* the scene transition and player spawn.
	# Placeholder - This should be handled by CharacterSystem reacting to load event or player spawn
	if save_data.has("player_state"):
		var p_state = save_data.player_state
		var p_pos = Vector3(p_state.get("position_x", 0), p_state.get("position_y", 0), p_state.get("position_z", 0))
		var p_basis_cols = p_state.get("rotation_basis_cols", [Vector3.RIGHT, Vector3.UP, Vector3.BACK])
		var p_basis = Basis(p_basis_cols[0], p_basis_cols[1], p_basis_cols[2])
		# Need to apply pos/rot AFTER player is spawned in the new zone.
		print("Load Request: Player should spawn at ", p_pos, " with rotation")

	if save_data.has("character_state"):
		# CharacterSystem should listen for game_loaded or player_spawned signal
		# and apply this data to the player agent
		print("Load Request: Character state needs restore: ", save_data.character_state)
		# GlobalRefs.character_system.load_save_data(save_data.character_state)

	# 3. Restore Time Clock
	# print("Load Request: Time clock needs restore")
	# GlobalRefs.time_manager.load_save_data(...)

	# 4. Restore Goal System State
	# print("Load Request: Goals need restore")
	# GlobalRefs.goal_system.load_save_data(...)

	# 5. Restore Persistent NPCs (Later Phase)

	# 6. Emit signal that load data is ready (systems should listen and apply)
	print("Load Process: Emitting game_loaded signal...")
	EventBus.emit_signal("game_loaded", save_data) # Pass full data

	# IMPORTANT: Returning true here only means the file was read.
	# Actual game state restoration is asynchronous and depends on listeners.
	return true


# --- Helper Functions ---
func get_save_slot_path(slot_id: int) -> String:
	return SAVE_DIR + SAVE_FILE_PREFIX + str(slot_id) + SAVE_FILE_EXT

func save_exists(slot_id: int) -> bool:
	var file = File.new()
	return file.file_exists(get_save_slot_path(slot_id))

# Gets only the metadata part of a save file, if possible
func get_save_metadata(slot_id: int) -> Dictionary:
	var path = get_save_slot_path(slot_id)
	var file = File.new()
	if not file.file_exists(path): return {}
	var err = file.open(path, File.READ)
	if err != OK: return {}
	# Use false here if we ONLY want the top-level dict, not full object parsing
	# Depends if metadata is stored simply at top level
	var data = file.get_var(true)
	file.close()
	if data is Dictionary and data.has("metadata"):
		return data.metadata
	# Try parsing non-shared if metadata is simple? Might fail on complex saves.
	# var file2 = File.new(); file2.open(path, File.READ); var data2 = file2.get_var(false); file2.close()
	# if data2 is Dictionary and data2.has("metadata"): return data2.metadata
	print("Warning: Could not read metadata from save slot ", slot_id)
	return {}

--- Start of ./autoload/GlobalRefs.gd ---

# File: autoload/GlobalRefs.gd
# Autoload Singleton: GlobalRefs
# Purpose: Holds easily accessible references to unique global nodes/managers.
# Nodes register themselves here via setter functions during their _ready() phase.
# Version: 1.0

extends Node

# --- Key Node References ---
# Other scripts access these directly (e.g., GlobalRefs.player_agent_body)
# but should ALWAYS check if is_instance_valid() first!

var player_agent_body = null setget set_player_agent_body
var main_camera = null setget set_main_camera
var world_manager = null setget set_world_manager
var event_system = null setget set_event_system      # If EventSystem is a Node, not Autoload
var goal_system = null setget set_goal_system        # If GoalSystem is a Node
var character_system = null setget set_character_system  # If CharacterSystem is a Node
var asset_system = null setget set_asset_system      # If AssetSystem is a Node
# Add other core system node references as needed...

var current_zone = null setget set_current_zone          # Reference to the root node of the loaded zone scene
var agent_container = null setget set_agent_container    # Reference to the node *within* the zone where agents are parented

func _ready():
	print("GlobalRefs Ready.")
	# This script typically doesn't do much itself, it just holds references set by others.

# --- Setters (Provide controlled way to update references & add validation) ---
# Using setget ensures these are called automatically on assignment.

func set_player_agent_body(new_ref):
	if new_ref == player_agent_body: return # No change
	if new_ref == null or is_instance_valid(new_ref):
		player_agent_body = new_ref
		print("GlobalRefs: Player Agent reference ", "set to ", new_ref.name if new_ref else "null")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Player Agent reference: ", new_ref)

func set_main_camera(new_ref):
	if new_ref == main_camera: return
	if new_ref == null or is_instance_valid(new_ref):
		main_camera = new_ref
		print("GlobalRefs: Main Camera reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Main Camera reference: ", new_ref)

func set_world_manager(new_ref):
	if new_ref == world_manager: return
	if new_ref == null or is_instance_valid(new_ref):
		world_manager = new_ref
		print("GlobalRefs: World Manager reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid World Manager reference: ", new_ref)

func set_event_system(new_ref):
	if new_ref == event_system: return
	if new_ref == null or is_instance_valid(new_ref):
		event_system = new_ref
		print("GlobalRefs: Event System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Event System reference: ", new_ref)

func set_goal_system(new_ref):
	if new_ref == goal_system: return
	if new_ref == null or is_instance_valid(new_ref):
		goal_system = new_ref
		print("GlobalRefs: Goal System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Goal System reference: ", new_ref)

func set_character_system(new_ref):
	if new_ref == character_system: return
	if new_ref == null or is_instance_valid(new_ref):
		character_system = new_ref
		print("GlobalRefs: Character System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Character System reference: ", new_ref)

func set_asset_system(new_ref):
	if new_ref == asset_system: return
	if new_ref == null or is_instance_valid(new_ref):
		asset_system = new_ref
		print("GlobalRefs: Asset System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Asset System reference: ", new_ref)

func set_current_zone(new_ref):
	if new_ref == current_zone: return
	if new_ref == null or is_instance_valid(new_ref):
		current_zone = new_ref
		print("GlobalRefs: Current Zone reference ", "set to ", new_ref.name if new_ref else "null")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Current Zone reference: ", new_ref)

func set_agent_container(new_ref):
	if new_ref == agent_container: return
	if new_ref == null or is_instance_valid(new_ref):
		agent_container = new_ref
		print("GlobalRefs: Agent Container reference ", "set to ", new_ref.name if new_ref else "null")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Agent Container reference: ", new_ref)

# --- Optional: Add simple getter functions if needed ---
# func get_player() -> KinematicBody:
#     return player_agent_body if is_instance_valid(player_agent_body) else null

--- Start of ./core/agents/agent.gd ---

# File: core/agents/agent.gd
# Version 3.19 - Uses Body's Model node global scale for distance calculation (as is).

extends KinematicBody

# --- Command Types Enumeration ---
enum CommandType {
	IDLE,         # Drifting, decelerating naturally
	STOPPING,     # Actively braking to a halt
	MOVE_TO,      # Move towards a specific Vector3 position
	MOVE_DIRECTION,# Move continuously in a specific direction vector
	APPROACH,     # Move towards a target node, stopping at a set distance
	ORBIT,        # Attempt to orbit a target node at a set distance
	FLEE,         # Move directly away from a target node
	ALIGN_TO      # Rotate to face a specific direction vector
}

# --- Agent Identification ---
var agent_name: String = "Default Agent"
var faction_id: String = "Neutral"
var template_id: String = "default"

# --- Movement Capabilities ---
var max_move_speed: float = 0.0
var acceleration: float = 0.0
var deceleration: float = 0.0
var brake_strength: float = 0.0
var max_turn_speed: float = 0.0

var interaction_radius: float = 0.0 # Can still be used as override via template/method

# --- Constants for Approach ---
const APPROACH_DISTANCE_MULTIPLIER = 1.5
const APPROACH_MIN_DISTANCE = 500.0 # Minimum distance regardless of target size

# --- Current State ---
var current_velocity: Vector3 = Vector3.ZERO
var _current_command = {} # Set in initialize
var _is_braking: bool = false

# --- Initialization ---
func initialize(template: AgentTemplate, overrides: Dictionary = {}):
	if not template is AgentTemplate:
		printerr("Agent Initialize Error: Invalid template for ", self.name)
		return

	# Load base stats from template, apply overrides
	self.template_id = template.template_id
	var default_name = template.default_agent_name + \
			"_" + str(get_instance_id())
	self.agent_name = overrides.get("name", default_name)
	self.faction_id = overrides.get("faction", template.default_faction_id)
	self.max_move_speed = overrides.get("max_move_speed",
		template.max_move_speed)
	self.acceleration = overrides.get("acceleration",
		template.acceleration)
	self.deceleration = overrides.get("deceleration",
		template.deceleration)
	self.max_turn_speed = overrides.get("max_turn_speed",
		template.max_turn_speed)
	var default_brake = self.deceleration * 1.5
	self.brake_strength = overrides.get("brake_strength", default_brake)
	self.name = self.agent_name # Set Node name
	self.interaction_radius = overrides.get("interaction_radius", template.interaction_radius)

	_set_command_idle() # Start idle
	print(self.name + " initialized template '", self.template_id, "'.")

# --- Godot Lifecycle ---
func _ready():
	add_to_group("Agents")
	set_physics_process(true)

func _physics_process(delta):
	_execute_current_command(delta)
	current_velocity = move_and_slide(current_velocity, Vector3.UP)

# --- Command Execution Logic ---
func _execute_current_command(delta):
	var cmd_type = _current_command.get("type", CommandType.IDLE)
	var target_node = _current_command.get("target_node", null)

	var is_target_cmd = cmd_type in [CommandType.APPROACH,
			CommandType.ORBIT, CommandType.FLEE]
	if is_target_cmd:
		if not is_instance_valid(target_node):
			command_stop()
			cmd_type = _current_command.get("type", CommandType.STOPPING)

	match cmd_type:
		CommandType.IDLE:
			_apply_deceleration(delta)

		CommandType.STOPPING:
			var stopped = _apply_braking(delta)
			if stopped:
				EventBus.emit_signal("agent_reached_destination", self)
				_set_command_idle()

		CommandType.MOVE_TO:
			var target_pos = _current_command.target_pos
			var vector_to_target = target_pos - global_transform.origin
			var distance_sq = vector_to_target.length_squared()
			var stopping_dist_sq = pow(10.0, 2)

			if distance_sq < stopping_dist_sq:
				command_stop()
			else:
				var direction = vector_to_target.normalized()
				_apply_rotation(delta, direction)
				_apply_acceleration(delta, direction)

		CommandType.MOVE_DIRECTION:
			var move_dir = _current_command.get("target_dir", Vector3.ZERO)
			if move_dir.length_squared() > 0.001:
				_apply_rotation(delta, move_dir)
				_apply_acceleration(delta, move_dir)
			else:
				_apply_deceleration(delta)

		CommandType.APPROACH:
			if not is_instance_valid(target_node): 
				command_stop()
				return

			var target_pos = target_node.global_transform.origin
			var target_size = _get_target_effective_size(target_node)
			var desired_stop_dist = max(APPROACH_MIN_DISTANCE,
					target_size * APPROACH_DISTANCE_MULTIPLIER)
			var upper_bound = desired_stop_dist * 1.10
			var lower_bound = desired_stop_dist

			var current_pos = global_transform.origin
			var vector_to_target = target_pos - current_pos
			var distance = vector_to_target.length()
			var direction = Vector3.ZERO
			if distance > 0.01: direction = vector_to_target / distance

			_apply_rotation(delta, direction)

			if distance > upper_bound: _apply_acceleration(delta, direction)
			elif distance <= lower_bound: command_stop()
			else: _apply_deceleration(delta)

		CommandType.ORBIT:
			if not is_instance_valid(target_node): 
				command_stop()
				return

			var target_pos = target_node.global_transform.origin
			var orbit_dist = _current_command.distance
			var vector_to_target = target_pos - global_transform.origin
			var distance = vector_to_target.length()
			var direction_to_target = -global_transform.basis.z
			if distance > 0.01: direction_to_target = vector_to_target / distance

			_apply_rotation(delta, direction_to_target)

			var target_up = Vector3.UP
			var tangent_dir = direction_to_target.cross(target_up).normalized()
			if tangent_dir.length_squared() < 0.1:
				tangent_dir = direction_to_target.cross(Vector3.RIGHT).normalized()

			var speed_factor = 1.0
			if distance < orbit_dist * 0.95: speed_factor = 0.7
			elif distance > orbit_dist * 1.05: speed_factor = 1.0

			_apply_acceleration(delta, tangent_dir * speed_factor)

		CommandType.FLEE:
			if not is_instance_valid(target_node): 
				command_stop()
				return

			var target_pos = target_node.global_transform.origin
			var vector_away = global_transform.origin - target_pos
			var direction_away = -global_transform.basis.z
			if vector_away.length_squared() > 0.01: direction_away = vector_away.normalized()

			_apply_rotation(delta, direction_away)
			_apply_acceleration(delta, direction_away)

		CommandType.ALIGN_TO:
			var target_dir = _current_command.target_dir
			_apply_rotation(delta, target_dir)
			_apply_deceleration(delta)
			var current_fwd = -global_transform.basis.z
			if current_fwd.dot(target_dir) > 0.998: _set_command_idle()


# --- Internal Movement Helpers ---
func _apply_acceleration(delta, direction):
	if direction.length_squared() < 0.001:
		_apply_deceleration(delta)
		return

	var target_velocity = direction.normalized() * max_move_speed
	current_velocity = current_velocity.linear_interpolate(target_velocity, acceleration * delta)
	_is_braking = false

func _apply_deceleration(delta):
	current_velocity = current_velocity.linear_interpolate(Vector3.ZERO, deceleration * delta)
	_is_braking = false

func _apply_braking(delta) -> bool:
	current_velocity = current_velocity.linear_interpolate(Vector3.ZERO, brake_strength * delta)
	_is_braking = true
	return current_velocity.length_squared() < 0.5

func _apply_rotation(delta, target_look_dir):
	if target_look_dir.length_squared() < 0.001: return

	var target_dir = target_look_dir.normalized()
	var current_basis = global_transform.basis.orthonormalized()
	var up_vector = Vector3.UP
	if abs(target_dir.dot(Vector3.UP)) > 0.999: up_vector = Vector3.FORWARD

	var target_basis = Transform(Basis(), Vector3.ZERO).looking_at(target_dir, up_vector).basis.orthonormalized()

	if current_basis.is_equal_approx(target_basis): return

	if max_turn_speed > 0.001:
		var turn_step = max_turn_speed * delta
		var new_basis = current_basis.slerp(target_basis, turn_step)
		global_transform.basis = new_basis


# --- Public Getter for Explicit Interaction Radius ---
func get_interaction_radius() -> float:
	# This can be overridden by specific agent types or use value from AgentTemplate.
	return interaction_radius


# --- Target Size Helper --- REFACTORED
# Version 3.19 - Returns max extent/size based on "Model" node global scale.
func _get_target_effective_size(target_node: Spatial) -> float:
	var calculated_size = 1.0 # Default minimum size
	var default_size = 50.0   # Fallback size if nothing else found (was default_radius)
	var found_source = false

	# print("--- Calculating Size for: ", target_node.name, " ---") # Keep for debug if needed

	if not is_instance_valid(target_node):
		# print("Debug Size: Target node invalid.")
		return default_size

	# --- PRIORITY 1: Check for explicit method on the target ---
	# Use get_interaction_radius, but interpret as size/extent now
	if target_node.has_method("get_interaction_radius"):
		var explicit_size = target_node.get_interaction_radius() # Treat value as size
		if (explicit_size is float or explicit_size is int) and explicit_size > 0:
			# print("Debug Size: Using get_interaction_radius() as size: ", explicit_size)
			calculated_size = explicit_size
			found_source = true
		# else: print("Debug Size: get_interaction_radius() invalid: ", explicit_size)

	# --- PRIORITY 2: Find DIRECT CHILD node named "Model" (only if not found via method)---
	if not found_source:
		var model_node = target_node.get_node_or_null("Model")
		# print("Debug Size: Result of get_node_or_null('Model'): ", model_node)

		if is_instance_valid(model_node) and model_node is Spatial:
			var model_scale_vector = model_node.global_transform.basis.get_scale()
			# print("Debug Size: Model Global Scale Vector: ", model_scale_vector)

			# --- Use the maximum scale value directly as the size ---
			var max_scale_value = max(model_scale_vector.x, max(model_scale_vector.y, model_scale_vector.z))
			# print("Debug Size: Model Max Scale Value: ", max_scale_value)

			calculated_size = max_scale_value # REMOVED / 2.0
			# print("Debug Size: Calculated Size (Before 0 Check): ", calculated_size)

			# Ensure size is not zero or negative
			if calculated_size <= 0:
				# print("Debug Size: Calculated size was <= 0, setting to 1.0")
				calculated_size = 1.0 # Fallback to minimum size 1.0

			found_source = true
		# else: print("Debug Size: No valid direct child 'Model' node found.")

	# --- Fallback if no source found ---
	if not found_source:
		# print("Debug Size: No source found, using default size: ", default_size)
		calculated_size = default_size

	# Final minimum check (size must be at least 1.0)
	var final_size = max(calculated_size, 1.0)
	# print("Debug Size: Final Size Returned: ", final_size)
	# print("-----------------------------------------------")
	return final_size



# --- Public Command Methods ---
# (No changes to command methods from v3.16)
func command_stop():
	_current_command = { "type": CommandType.STOPPING }

func command_move_to(position: Vector3):
	_current_command = { "type": CommandType.MOVE_TO, "target_pos": position }

func command_move_direction(direction: Vector3):
	if direction.length_squared() < 0.001:
		printerr("MoveDirection command: Invalid direction vector.")
		command_stop(); return
	_current_command = { "type": CommandType.MOVE_DIRECTION, "target_dir": direction.normalized() }

func command_approach(target: Spatial):
	if not is_instance_valid(target):
		printerr("Approach command: Invalid target node.")
		command_stop(); return
	_current_command = { "type": CommandType.APPROACH, "target_node": target }

func command_orbit(target: Spatial, distance: float):
	if not is_instance_valid(target):
		printerr("Orbit command: Invalid target node.")
		command_stop(); return
	_current_command = { "type": CommandType.ORBIT, "target_node": target, "distance": max(10.0, distance) }

func command_flee(target: Spatial):
	if not is_instance_valid(target):
		printerr("Flee command: Invalid target node.")
		command_stop(); return
	_current_command = { "type": CommandType.FLEE, "target_node": target }

func command_align_to(direction: Vector3):
	if direction.length_squared() < 0.001:
		printerr("AlignTo command: Invalid direction vector.")
		_set_command_idle(); return
	_current_command = { "type": CommandType.ALIGN_TO, "target_dir": direction.normalized() }

# Internal helper to set state to Idle
func _set_command_idle():
	var last_look = -global_transform.basis.z
	if _current_command and "target_dir" in _current_command: last_look = _current_command.target_dir
	_current_command = { "type": CommandType.IDLE, "target_dir": last_look }
	_is_braking = false

# --- Despawn ---
func despawn():
	print("Agent ", self.name, " despawning...")
	EventBus.emit_signal("agent_despawning", self)
	set_physics_process(false)
	call_deferred("queue_free")

--- Start of ./core/agents/agent_template.gd ---

# File: core/agents/agent_template.gd
# Resource Definition for Agent Stats/Config
# Version: 1.0

extends Resource
class_name AgentTemplate # Allows type hinting and creating this resource type in editor

# --- Identification ---
export var template_id : String = "default_template" # Unique ID for this template type
export var default_agent_name : String = "Agent"     # Base name for agents using this
export var default_faction_id : String = "Neutral"   # Default faction

# --- Base Movement Capabilities (Reads defaults from Constants) ---
export var max_move_speed : float = Constants.DEFAULT_MAX_MOVE_SPEED
export var acceleration : float = Constants.DEFAULT_ACCELERATION
export var deceleration : float = Constants.DEFAULT_DECELERATION
export var max_turn_speed : float = Constants.DEFAULT_MAX_TURN_SPEED

# --- Interaction Size ---
# Used by camera targeting, docking, etc. Represents effective size.
export var interaction_radius : float = 15.0 # Default reasonable size

# --- Base Combat Stats (Placeholders - Link to Combat Module/Character System later) ---
# export var base_hull : int = 100
# export var base_shields : int = 0

# --- Base Skills (Placeholders - Link to Character System later) ---
# These represent the inherent skill level associated with this *type* of agent
# export var base_piloting_skill : int = 0
# export var base_tech_skill : int = 0
# export var base_social_skill : int = 0

# --- AI Behavior Hint (Optional) ---
# export var default_ai_behavior : String = "idle" # Hint for AI controller selection/init

# --- Visuals / Asset Links (Placeholders) ---
# Optional: Could link to default ship model path, visual effects, etc.
# export (String, FILE, "*.tscn,*.glb,*.gltf") var default_model_path = ""

--- Start of ./core/systems/asset_system.gd ---

extends Node


# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/character_system.gd ---

extends Node


# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/chronicle_system.gd ---

extends Node


# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/event_system.gd ---

extends Node


# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/goal_system.gd ---

extends Node


# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/progression_system.gd ---

extends Node


# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/traffic_system_placeholder.gd ---

extends Node


# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/world_map_system.gd ---

extends Node


# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/ui/main_hud.gd ---

# File: res://core/ui/main_hud.gd
# Script for the main HUD container. Handles displaying targeting info, etc.
# Version: 1.1 - Fixed targeting indicator visibility restoration

extends Control

# --- Nodes ---
onready var targeting_indicator: Control = $TargetingIndicator

# --- State ---
var _current_target: Spatial = null
var _main_camera: Camera = null

# --- Initialization ---
func _ready():
	# Ensure indicator starts hidden
	targeting_indicator.visible = false

	# Get camera reference once
	_main_camera = get_viewport().get_camera() # Initial attempt
	if not is_instance_valid(_main_camera) and is_instance_valid(GlobalRefs.main_camera):
		_main_camera = GlobalRefs.main_camera # Fallback via GlobalRefs

	if not is_instance_valid(_main_camera):
		printerr("MainHUD Error: Could not get a valid camera reference!")
		set_process(false) # Disable processing if no camera

	# Connect to EventBus signals
	if EventBus:
		if not EventBus.is_connected("player_target_selected", self, "_on_Player_Target_Selected"):
			EventBus.connect("player_target_selected", self, "_on_Player_Target_Selected")
		if not EventBus.is_connected("player_target_deselected", self, "_on_Player_Target_Deselected"):
			EventBus.connect("player_target_deselected", self, "_on_Player_Target_Deselected")
	else:
		printerr("MainHUD Error: EventBus not available!")

	# Connect draw signal for custom drawing (optional, but good for style)
	targeting_indicator.connect("draw", self, "_draw_targeting_indicator")


# --- Process Update ---
func _process(delta):
	# Only update position if a target is selected and valid
	if is_instance_valid(_current_target) and is_instance_valid(_main_camera):
		# Project the target's 3D origin position to 2D screen coordinates
		var screen_pos: Vector2 = _main_camera.unproject_position(_current_target.global_transform.origin)

		# Check if the target is behind the camera
		var target_dir = (_current_target.global_transform.origin - _main_camera.global_transform.origin).normalized()
		var camera_fwd = -_main_camera.global_transform.basis.z.normalized()
		var is_in_front = target_dir.dot(camera_fwd) >= 0 # Use >= 0 to include exactly perpendicular

		# --- MODIFIED Visibility Logic ---
		# Set visibility based on whether the target is in front
		targeting_indicator.visible = is_in_front

		# Only update position and redraw if it's actually visible
		if targeting_indicator.visible:
			# Update the indicator's position
			targeting_indicator.rect_position = screen_pos - (targeting_indicator.rect_size / 2.0)
			targeting_indicator.update() # Trigger redraw if using _draw
	else:
		# Ensure indicator is hidden if target becomes invalid or camera is invalid
		if targeting_indicator.visible:
			targeting_indicator.visible = false


# --- Signal Handlers ---
func _on_Player_Target_Selected(target_node: Spatial):
	print(target_node)
	if is_instance_valid(target_node):
		_current_target = target_node
		# Visibility is now primarily handled in _process,
		# but we still need to ensure _process runs.
		# targeting_indicator.visible = true # This line can be removed or kept, _process will override
		set_process(true) # Ensure _process runs
	else:
		_on_Player_Target_Deselected()

func _on_Player_Target_Deselected():
	_current_target = null
	targeting_indicator.visible = false
	set_process(false) # Can disable processing if target is deselected


# --- Custom Drawing (Optional but Recommended) ---
func _draw_targeting_indicator():
	# Example: Draw a simple white rectangle outline
	var rect = Rect2(Vector2.ZERO, targeting_indicator.rect_size)
	var line_color = Color.white
	var line_width = 1.0 # Adjust thickness as needed
	#targeting_indicator.draw_rect(rect, line_color, false, line_width)

	# Example: Draw simple corner brackets
	var size = targeting_indicator.rect_size
	var corner_len = size.x * 0.25 # Length of corner lines
	var color = Color.cyan
	var width = 2.0
	# # Top-left
	targeting_indicator.draw_line(Vector2(0,0), Vector2(corner_len, 0), color, width)
	targeting_indicator.draw_line(Vector2(0,0), Vector2(0, corner_len), color, width)
	# # Top-right
	targeting_indicator.draw_line(Vector2(size.x, 0), Vector2(size.x - corner_len, 0), color, width)
	targeting_indicator.draw_line(Vector2(size.x, 0), Vector2(size.x, corner_len), color, width)
	# # Bottom-left
	targeting_indicator.draw_line(Vector2(0, size.y), Vector2(corner_len, size.y), color, width)
	targeting_indicator.draw_line(Vector2(0, size.y), Vector2(0, size.y - corner_len), color, width)
	# # Bottom-right
	targeting_indicator.draw_line(Vector2(size.x, size.y), Vector2(size.x - corner_len, size.y), color, width)
	targeting_indicator.draw_line(Vector2(size.x, size.y), Vector2(size.x, size.y - corner_len), color, width)


# --- Cleanup ---
func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		if EventBus:
			if EventBus.is_connected("player_target_selected", self, "_on_Player_Target_Selected"):
				EventBus.disconnect("player_target_selected", self, "_on_Player_Target_Selected")
			if EventBus.is_connected("player_target_deselected", self, "_on_Player_Target_Deselected"):
				EventBus.disconnect("player_target_deselected", self, "_on_Player_Target_Deselected")


func _on_ButtonFreeFlight_pressed():
	if EventBus: 
		EventBus.emit_signal("player_free_flight_toggled")

func _on_ButtonStop_pressed():
	if EventBus: 
		EventBus.emit_signal("player_stop_pressed")


func _on_ButtonOrbit_pressed():
	if EventBus: 
		EventBus.emit_signal("player_orbit_pressed")


func _on_ButtonApproach_pressed():
	if EventBus: 
		EventBus.emit_signal("player_approach_pressed")


func _on_ButtonFlee_pressed():
	if EventBus: 
		EventBus.emit_signal("player_flee_pressed")

--- Start of ./modules/piloting/scripts/player_controller_ship.gd ---

# File: modules/piloting/scripts/player_controller_ship.gd
# Version 3.6 - Re-enabled input consumption, triggers toggle via signal.

extends Node

# --- References ---
var agent_script: Node = null
var agent_body: KinematicBody = null
var _main_camera: Camera = null

# --- State ---
var _target_under_cursor: Spatial = null # Updated in _physics_process
var _selected_target: Spatial = null setget _set_selected_target
var _is_free_flight_mode: bool = false

# --- Input Tracking State ---
var _lmb_pressed: bool = false
var _lmb_press_pos: Vector2 = Vector2.ZERO
var _lmb_press_time: int = 0 # Using OS.get_ticks_msec()
var _is_dragging: bool = false
var _last_tap_time: int = 0
# Removed _potential_double_click flag

# --- Constants ---
const DEFAULT_ORBIT_DIST = 3000.0
const DEFAULT_MOVE_TO_PROJECTION_DIST = 1e6
const DRAG_THRESHOLD_PX_SQ = 10 * 10 # Squared distance threshold to start drag
const DOUBLE_CLICK_TIME_MS = 400   # Max milliseconds between taps for double-click

# --- Initialization ---
func _ready():
	# Connect to EventBus signals
	if EventBus:
		# Ensure signal name matches exactly what's emitted
		if not EventBus.is_connected("player_free_flight_toggled", self, "_on_Player_Free_Flight_Toggled"):
			var err = EventBus.connect("player_free_flight_toggled", self, "_on_Player_Free_Flight_Toggled")
			if err != OK: printerr("PlayerController Error: Failed connect player_free_flight_toggled signal! Code: ", err)
			
		if not EventBus.is_connected("player_stop_pressed", self, "_on_Player_Stop_Pressed"):
			var err = EventBus.connect("player_stop_pressed", self, "_on_Player_Stop_Pressed")
			if err != OK: printerr("PlayerController Error: Failed connect player_stop_pressed signal! Code: ", err)
			
		if not EventBus.is_connected("player_orbit_pressed", self, "_on_Player_Orbit_Pressed"):
			var err = EventBus.connect("player_orbit_pressed", self, "_on_Player_Orbit_Pressed")
			if err != OK: printerr("PlayerController Error: Failed connect player_orbit_pressed signal! Code: ", err)

		if not EventBus.is_connected("player_approach_pressed", self, "_on_Player_Approach_Pressed"):
			var err = EventBus.connect("player_approach_pressed", self, "_on_Player_Approach_Pressed")
			if err != OK: printerr("PlayerController Error: Failed connect player_orbit_pressed signal! Code: ", err)

		if not EventBus.is_connected("player_flee_pressed", self, "_on_Player_Flee_Pressed"):
			var err = EventBus.connect("player_flee_pressed", self, "_on_Player_Flee_Pressed")
			if err != OK: printerr("PlayerController Error: Failed connect player_orbit_pressed signal! Code: ", err)
	
	
	else:
		printerr("PlayerController Error: EventBus not available!")

	var parent = get_parent()
	if parent is KinematicBody and parent.has_method("command_stop"):
		agent_body = parent
		agent_script = parent
		print("Player Controller ready for: ", agent_script.agent_name)
		call_deferred("_get_camera_reference")
		Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
	else:
		printerr("Player Controller Error: Parent invalid or missing command methods!")
		set_physics_process(false); set_process_input(false); return

func _get_camera_reference():
	yield(get_tree(), "idle_frame")
	if is_instance_valid(GlobalRefs.main_camera) and GlobalRefs.main_camera is Camera:
		_main_camera = GlobalRefs.main_camera
		print("Player Controller obtained camera reference.")
	else:
		printerr("Player Controller Error: Could not find valid Main Camera in GlobalRefs.")

# --- Physics Update ---
func _physics_process(delta):
	# Always update target under cursor when mouse is visible, might be needed for hover effects later
	if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE:
		_update_target_under_cursor()
	else:
		_target_under_cursor = null # Clear if mouse not visible (e.g., free flight)

	# Free Flight Movement (Unchanged)
	if _is_free_flight_mode:
		if is_instance_valid(_main_camera) and is_instance_valid(agent_script):
			var move_dir = -_main_camera.global_transform.basis.z.normalized()
			agent_script.command_move_direction(move_dir)
		elif is_instance_valid(agent_script):
			agent_script.command_stop()
		# Removed warping logic

# --- Target Raycast ---
func _update_target_under_cursor():
	# Reset first
	_target_under_cursor = null
	if not is_instance_valid(agent_body): return
	var camera = get_viewport().get_camera() # Use viewport camera for UI interaction
	if not is_instance_valid(camera): return

	var mouse_pos = get_viewport().get_mouse_position()
	var ray_origin = camera.project_ray_origin(mouse_pos)
	var ray_normal = camera.project_ray_normal(mouse_pos)
	var ray_end = ray_origin + ray_normal * Constants.TARGETING_RAY_LENGTH

	var space_state = agent_body.get_world().direct_space_state
	var result = space_state.intersect_ray(ray_origin, ray_end, [agent_body], 1) # Mask 1

	if result and result.collider is Spatial:
		_target_under_cursor = result.collider
		# TODO: Highlight _target_under_cursor (visual feedback)

# --- Target Selection Setter ---
func _set_selected_target(new_target: Spatial):
	if _selected_target == new_target: return

	_selected_target = new_target

	if is_instance_valid(_selected_target):
		if EventBus: EventBus.emit_signal("player_target_selected", _selected_target)
		print("Player selected target: ", _selected_target.name)
	else:
		# Handle deselection explicitly via signal
		if EventBus: EventBus.emit_signal("player_target_deselected")
		print("Player de-selected target.")

# --- Public Deselect Function --- (For UI Button)
func deselect_current_target():
	if is_instance_valid(_selected_target):
		self._selected_target = null # Will trigger deselection signal via setter

# --- Input Event Handling ---
func _unhandled_input(event):
	var input_handled = false

		# --- Free Flight Toggle (Keyboard - Direct Check Re-added) ---
	if Input.is_action_just_pressed("toggle_free_flight"):
		_toggle_free_flight()
		input_handled = true # CONSUME the input event
		

	# --- LMB / Touch Input Handling ---
	if event is InputEventMouseButton and event.button_index == BUTTON_LEFT:
		if event.pressed:
			_lmb_pressed = true; _is_dragging = false
			_lmb_press_pos = event.position; _lmb_press_time = OS.get_ticks_msec()
			# Don't handle yet
		else: # Released
			if _lmb_pressed:
				_lmb_pressed = false; var time_now = OS.get_ticks_msec()
				if _is_dragging:
					# End of Drag
					if is_instance_valid(_main_camera) and _main_camera.has_method("set_is_rotating"):
						_main_camera.set_is_rotating(false)
					input_handled = true # CONSUME event
				else:
					# End of Tap/Click
					if time_now - _last_tap_time <= DOUBLE_CLICK_TIME_MS:
						_handle_double_click(event.position); _last_tap_time = 0
					else:
						_handle_single_click(event.position); _last_tap_time = time_now
					input_handled = true # CONSUME event
				_is_dragging = false

	# --- Mouse Motion / Touch Drag ---
	elif event is InputEventMouseMotion and _lmb_pressed and not _is_dragging:
		if event.position.distance_squared_to(_lmb_press_pos) > DRAG_THRESHOLD_PX_SQ:
			# Start Drag
			_is_dragging = true; _last_tap_time = 0
			if not _is_free_flight_mode:
				if is_instance_valid(_main_camera) and _main_camera.has_method("set_is_rotating"):
					_main_camera.set_is_rotating(true)
			# Let camera consume motion event if it uses it

	# --- Other Keyboard Commands (Only if not in free flight) ---
	elif not _is_free_flight_mode and is_instance_valid(agent_script):
		# Check only if event wasn't handled by LMB/Touch release
		if not input_handled:
			var command_action_key = ""
			if Input.is_action_just_pressed("command_approach"): command_action_key = "approach"
			elif Input.is_action_just_pressed("command_orbit"): command_action_key = "orbit"
			elif Input.is_action_just_pressed("command_flee"): command_action_key = "flee"
			elif Input.is_action_just_pressed("command_stop"): command_action_key = "stop"

			if command_action_key != "":
				input_handled = true # CONSUME event if handled
				match command_action_key:
					"approach", "orbit", "flee":
						if is_instance_valid(_selected_target):
							match command_action_key:
								"approach": agent_script.command_approach(_selected_target)
								"orbit": agent_script.command_orbit(_selected_target, DEFAULT_ORBIT_DIST)
								"flee": agent_script.command_flee(_selected_target)
							print("Command Input: ", command_action_key.to_upper()," ", _selected_target.name)
						else:
							print("Command Input: ", command_action_key," failed - no target.")
							input_handled = false # Don't consume if failed
					"stop":
						print("Command Input: STOP"); agent_script.command_stop()
					_:
						input_handled = false # Don't consume unknown actions

	# --- Consume Input ---
	if input_handled:
		get_viewport().set_input_as_handled()

# --- Click Handling Logic ---
func _handle_single_click(click_pos: Vector2):
	# Process click only when mouse is visible
	if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE:
		var target = _raycast_for_target(click_pos)
		self._selected_target = target

func _handle_double_click(click_pos: Vector2):
	# Process double click only when mouse is visible
	if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE:
		if is_instance_valid(agent_script) and is_instance_valid(_main_camera):
			var ray_origin = _main_camera.project_ray_origin(click_pos)
			var ray_normal = _main_camera.project_ray_normal(click_pos)
			var target_point = ray_origin + ray_normal * DEFAULT_MOVE_TO_PROJECTION_DIST
			print("Input: Double-Click Move To ", target_point)
			agent_script.command_move_to(target_point)
		# else: print("Move To Failed")

# --- Signal Handling ---

# ---- From GUI ----
func _on_Player_Free_Flight_Toggled():
	_toggle_free_flight()
	
func _on_Player_Stop_Pressed():
	agent_script.command_stop()
	
func _on_Player_Orbit_Pressed():
	agent_script.command_orbit(_selected_target, DEFAULT_ORBIT_DIST)
	
func _on_Player_Approach_Pressed():
	agent_script.command_approach(_selected_target)

func _on_Player_Flee_Pressed():
	agent_script.command_flee(_selected_target)

# --- Helper Raycast Function ---
func _raycast_for_target(screen_pos: Vector2) -> Spatial:
	if not is_instance_valid(agent_body): return null
	var camera = get_viewport().get_camera()
	if not is_instance_valid(camera): return null
	var ray_origin = camera.project_ray_origin(screen_pos)
	var ray_normal = camera.project_ray_normal(screen_pos)
	var ray_end = ray_origin + ray_normal * Constants.TARGETING_RAY_LENGTH
	var space_state = agent_body.get_world().direct_space_state
	var result = space_state.intersect_ray(ray_origin, ray_end, [agent_body], 1)
	if result and result.collider is Spatial: return result.collider
	else: return null

# --- Free Flight Toggle Logic ---
# Uses CAPTURED mode
func _toggle_free_flight():
	_is_free_flight_mode = not _is_free_flight_mode
	print("Free Flight Mode: ", "ON" if _is_free_flight_mode else "OFF")

	if _is_free_flight_mode:
		Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED) # Using CAPTURED
		if is_instance_valid(_main_camera) and _main_camera.has_method("set_rotation_input_active"):
			_main_camera.set_rotation_input_active(true)
		_is_dragging = false # Clear drag state
		if is_instance_valid(_main_camera) and _main_camera.has_method("set_is_rotating"):
			_main_camera.set_is_rotating(false)
	else: # Exiting free flight
		Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
		if is_instance_valid(_main_camera):
			if _main_camera.has_method("set_rotation_input_active"):
				_main_camera.set_rotation_input_active(false)
			if _main_camera.has_method("set_is_rotating"):
				_main_camera.set_is_rotating(false)
		if is_instance_valid(agent_script): 
			agent_script.command_stop()
		_lmb_pressed = false
		_is_dragging = false

--- Start of ./modules/piloting/scripts/ship_controller_ai.gd ---

# File: modules/piloting/scripts/ship_controller_ai.gd
# Attach to Node child of AgentBody in npc_agent.tscn
# Version 2.1 - Simplified for agent command execution model

extends Node

# --- References ---
# Set in _ready()
var agent_script: Node = null # Reference to the parent agent.gd script instance

# --- Initialization ---
func _ready():
	# Get reference to parent agent script
	var parent = get_parent()
	# Check if parent is the correct type and has the command methods
	if parent is KinematicBody and parent.has_method("command_move_to"):
		agent_script = parent
		# print("AI Controller ready for: ", agent_script.agent_name) # Optional Debug
	else:
		printerr("AI Controller Error: Parent node is not an Agent KinematicBody with command methods!")
		# If setup fails, this controller can't function.
		# We can disable physics process (though it's empty now)
		# or even detach the script to prevent errors.
		set_physics_process(false)
		set_script(null) # Detach script if parent is wrong

# Called by WorldManager's spawn_agent function (via initialize dictionary in agent.gd)
# The 'config' dictionary here is the 'overrides' passed to spawn_agent
func initialize(config: Dictionary):
	# Ensure agent script reference is valid before issuing command
	if not is_instance_valid(agent_script):
		printerr("AI Initialize Error: Agent script invalid. Cannot issue command.")
		return

	# Read necessary parameters from config dictionary if present
	var stopping_dist = config.get("stopping_distance", 10.0) # May not be needed by AI now
	# TODO: Agent's MOVE_TO command should probably use its own internal stopping distance logic

	# Immediately issue the initial command based on 'initial_target' in config
	if config.has("initial_target") and config.initial_target is Vector3:
		var target_pos = config.initial_target
		print(agent_script.agent_name, " AI issuing command: MOVE_TO ", target_pos)
		# Call the command method on the agent script
		agent_script.command_move_to(target_pos)
	else:
		# If no target, the agent remains IDLE (its default state)
		if is_instance_valid(agent_script): # Check again just in case
			 print("AI Controller Warning: No initial target provided for ",
					agent_script.agent_name, ". Agent will remain idle.")


# --- No Physics Update Needed ---
# For this simple "go-to" AI, the agent itself executes the command issued
# during initialize. This controller doesn't need to do anything frame-by-frame.
# More complex AI would have state machines here, checking conditions and
# issuing different commands (approach, orbit, flee, etc.) as needed.
# func _physics_process(delta):
#     pass


# --- No Event Handling Needed Here ---
# The agent itself now emits "agent_reached_destination" via EventBus
# when its relevant command (MOVE_TO -> STOPPING -> IDLE) completes.
# WorldManager listens for that signal to trigger the despawn.
# func _handle_target_reached(): # Removed
# func _on_Agent_Reached_Destination(agent_body): # Removed

# --- No Public Functions Needed Here ---
# func set_target(new_target: Vector3): # Removed - command issued once at init

--- Start of ./scenes/camera/orbit_camera.gd ---

# File: scenes/camera/orbit_camera.gd
# Version 1.26 - Added rotation acceleration based on mouse input intensity. Rotation speed adjusted, pitch reversed.

extends Camera

# --- Configuration ---
var distance: float = 55.0
var min_distance_multiplier: float = 2.0
var max_distance_multiplier: float = 15.0
var preferred_distance_multiplier: float = 2.0
const MIN_ABSOLUTE_DISTANCE = 1.0
const MAX_ABSOLUTE_DISTANCE = 500.0
var zoom_speed: float = 1.0

# var rotation_speed: float = 0.004 # REMOVED - Replaced by acceleration logic
var pitch_min: float = -1.55
var pitch_max: float = 1.55
var position_smoothing_speed: float = 17.0
var rotation_smoothing_speed: float = 22.0 # Now affects how fast camera *looks at* target
var bob_frequency: float = 0.06
var bob_amplitude: float = 0.06

# --- FoV Configuration ---
var _min_fov_deg: float = 40.0
var _max_fov_deg: float = 100.0

# --- Rotation Acceleration Config --- (Internal, set via initialize)
var _rotation_max_speed: float = 2000.0  # Max angular speed (radians/sec) from full mouse motion
var _rotation_acceleration: float = 15.0 # How quickly speed changes towards target
var _rotation_damping: float = 10.0   # How quickly speed decays when no input (higher = faster stop)
var _rotation_input_curve: float = 1.5 # Power curve for mouse input (1 = linear, >1 = faster ramp-up)

# --- Internal State ---
var _target: Spatial = null
var _target_radius: float = 15.0
var _yaw: float = PI
var _pitch: float = 0.25
var _current_distance: float = 55.0
var _rotation_input_active: bool = false # Free flight flag
var _is_externally_rotating: bool = false # LMB/Touch drag flag
var _bob_timer: float = 0.0

# --- Rotation Acceleration State ---
var _target_yaw_speed: float = 0.0
var _target_pitch_speed: float = 0.0
var _current_yaw_speed: float = 0.0
var _current_pitch_speed: float = 0.0

# --- Initialization ---
func _ready():
	_current_distance = distance
	_yaw = PI
	_pitch = 0.25
	set_as_toplevel(true)
	GlobalRefs.main_camera = self

	# Connect signals... (same as before)
	if EventBus:
		if not EventBus.is_connected("camera_set_target_requested", self, "_on_Camera_Set_Target_Requested"):
			var err = EventBus.connect("camera_set_target_requested", self, "_on_Camera_Set_Target_Requested")
			if err != OK: printerr("Camera Error: Failed connect signal! Code: ", err)
	else: printerr("Camera Error: EventBus not available!")

	# Proactive player check... (same as before)
	if not is_instance_valid(_target):
		if is_instance_valid(GlobalRefs.player_agent_body): set_target_node(GlobalRefs.player_agent_body)
	_update_fov()

func initialize(config: Dictionary):
	# Initialize standard config... (same as before)
	if config.has("distance"): self.distance = config.distance
	# ... other standard params ...
	if config.has("bob_amplitude"): self.bob_amplitude = config.bob_amplitude

	# Initialize FoV limits... (same as before)
	if config.has("min_fov_deg"): self._min_fov_deg = config.min_fov_deg
	if config.has("max_fov_deg"): self._max_fov_deg = config.max_fov_deg

	# --- ADDED: Initialize Rotation Acceleration limits from config ---
	if config.has("rotation_max_speed"): self._rotation_max_speed = config.rotation_max_speed
	if config.has("rotation_acceleration"): self._rotation_acceleration = config.rotation_acceleration
	if config.has("rotation_damping"): self._rotation_damping = config.rotation_damping
	if config.has("rotation_input_curve"): self._rotation_input_curve = config.rotation_input_curve
	# --- End Added ---

	self._yaw = deg2rad(config.get("initial_yaw_deg", 180.0))
	self._pitch = clamp(deg2rad(config.get("initial_pitch_deg", 15.0)), pitch_min, pitch_max)
	_current_distance = self.distance

	print("OrbitCamera initialized.")


# --- Input Handling ---
func _unhandled_input(event):
	# Rotation Input (Mouse Motion) - Now sets TARGET speed
	if event is InputEventMouseMotion:
		if _rotation_input_active or _is_externally_rotating:
			# Calculate input strength (normalize relative motion magnitude, maybe clamp)
			# Note: event.relative can be large, might need scaling factor if uncapped
			var input_strength_x = abs(event.relative.x) / get_viewport().size.x # Normalize roughly? Or use fixed divisor?
			var input_strength_y = abs(event.relative.y) / get_viewport().size.y
			
			# Apply power curve for non-linear response
			input_strength_x = pow(input_strength_x, _rotation_input_curve)
			input_strength_y = pow(input_strength_y, _rotation_input_curve)

			# Set target speed based on direction and scaled strength
			_target_yaw_speed = -sign(event.relative.x) * input_strength_x * _rotation_max_speed
			_target_pitch_speed = -sign(event.relative.y) * input_strength_y * _rotation_max_speed # Note: Pitch might feel inverted, adjust sign if needed

			# Consume the event so other UI elements don't process drag motion
			get_viewport().set_input_as_handled()

	# Zoom Input (Wheel) - Unchanged
	elif event is InputEventMouseButton and is_instance_valid(_target):
		var dyn_min_dist = _get_dynamic_min_distance()
		var dyn_max_dist = _get_dynamic_max_distance()
		var zoom_factor = 1.0 + (zoom_speed * 0.1)
		var input_handled = false
		if event.button_index == BUTTON_WHEEL_UP and event.pressed:
			_current_distance = max(dyn_min_dist, _current_distance / zoom_factor)
			input_handled = true
		elif event.button_index == BUTTON_WHEEL_DOWN and event.pressed:
			_current_distance = min(dyn_max_dist, _current_distance * zoom_factor)
			input_handled = true
		if input_handled: 
			get_viewport().set_input_as_handled()

# --- Physics Update ---
func _physics_process(delta):
	_bob_timer += delta

	# --- Update FoV --- (Unchanged)
	if is_instance_valid(_target): _update_fov()

	# --- Update Rotation based on Speed --- ADDED ---
	var rot_active = _rotation_input_active or _is_externally_rotating
	# If rotation isn't active, force target speed to 0 to ensure damping works
	if not rot_active:
		_target_yaw_speed = 0.0
		_target_pitch_speed = 0.0

	# Interpolate current speed towards target speed (Acceleration)
	_current_yaw_speed = lerp(_current_yaw_speed, _target_yaw_speed, _rotation_acceleration * delta)
	_current_pitch_speed = lerp(_current_pitch_speed, _target_pitch_speed, _rotation_acceleration * delta)

	# Apply damping (always active, brings speed back to 0)
	var damp_factor = 1.0 - (_rotation_damping * delta) # Needs delta adjustment for frame independence
	# Clamp damp_factor to prevent reversal if delta is large or damping is high
	damp_factor = max(0.0, damp_factor)
	_current_yaw_speed *= damp_factor
	_current_pitch_speed *= damp_factor

	# Apply calculated rotation speeds to angles
	_yaw += _current_yaw_speed * delta
	_pitch -= _current_pitch_speed * delta
	_pitch = clamp(_pitch, pitch_min, pitch_max) # Keep pitch within limits

	# Reset target speed for next frame (input will overwrite if motion occurs)
	# This ensures damping takes over if input stops suddenly
	_target_yaw_speed = 0.0
	_target_pitch_speed = 0.0
	# --- End Rotation Update ---


	# --- Update Position and LookAt ---
	if not is_instance_valid(_target):
		# Detached Mode (Apply only rotation)
		var new_basis = Basis().rotated(Vector3.UP, _yaw).rotated(Basis().rotated(Vector3.UP, _yaw).x, _pitch)
		global_transform.basis = global_transform.basis.slerp(new_basis.orthonormalized(), rotation_smoothing_speed * delta)
		return

	# --- Attached Mode --- (Position + LookAt)
	var target_pos = _target.global_transform.origin
	var bob_offset = global_transform.basis.y * sin(_bob_timer * bob_frequency * TAU) * bob_amplitude
	# Calculate desired orientation first based on yaw/pitch
	var desired_basis = Basis().rotated(Vector3.UP, _yaw).rotated(Basis().rotated(Vector3.UP, _yaw).x, _pitch)
	# Calculate desired position based on orientation and distance
	var position_offset = -desired_basis.z * _current_distance
	var desired_position = target_pos + position_offset + bob_offset

	# Interpolate Position
	global_transform.origin = global_transform.origin.linear_interpolate(desired_position, position_smoothing_speed * delta)

	# Interpolate Look At (still smoothly look at target even while manually rotating)
	var target_look_transform = global_transform.looking_at(target_pos, Vector3.UP)
	global_transform.basis = global_transform.basis.slerp(target_look_transform.basis.orthonormalized(), rotation_smoothing_speed * delta)


# --- Dynamic FoV Update Logic --- (Unchanged from v1.24)
func _update_fov():
	var dyn_min_dist = _get_dynamic_min_distance()
	var dyn_max_dist = _get_dynamic_max_distance()
	if is_equal_approx(dyn_max_dist, dyn_min_dist):
		self.fov = _max_fov_deg; return
	var t = clamp((_current_distance - dyn_min_dist) / (dyn_max_dist - dyn_min_dist), 0.0, 1.0)
	self.fov = lerp(_min_fov_deg, _max_fov_deg, t)

# --- Helper functions for dynamic distances --- (Unchanged from v1.24)
func _get_dynamic_min_distance() -> float:
	if not is_instance_valid(_target): return MIN_ABSOLUTE_DISTANCE
	_target_radius = _get_target_effective_radius(_target)
	return max(MIN_ABSOLUTE_DISTANCE, _target_radius * min_distance_multiplier)

func _get_dynamic_max_distance() -> float:
	if not is_instance_valid(_target): return MAX_ABSOLUTE_DISTANCE
	var dyn_min_dist = _get_dynamic_min_distance()
	var dyn_max_calc = max(dyn_min_dist + 1.0, _target_radius * max_distance_multiplier)
	return min(MAX_ABSOLUTE_DISTANCE, dyn_max_calc)

# --- Signal Handler & Public Functions --- (External control functions unchanged)
func _on_Camera_Set_Target_Requested(target_node): set_target_node(target_node)
func set_rotation_input_active(is_active: bool):
	_rotation_input_active = is_active
	if is_active: _is_externally_rotating = false
func set_is_rotating(rotating: bool):
	if not _rotation_input_active: _is_externally_rotating = rotating

# --- set_target_node, _get_target_effective_radius, get_current_target, _notification ---
# (Unchanged from v1.24)
func set_target_node(new_target: Spatial):
	var target_changed = false
	if is_instance_valid(new_target):
		if _target != new_target:
			_target = new_target; _target_radius = _get_target_effective_radius(_target)
			print("OrbitCamera target set to: ", new_target.name, " | Eff Radius: ", _target_radius)
			var dyn_min_dist = _get_dynamic_min_distance(); var dyn_max_dist = _get_dynamic_max_distance()
			var preferred_dist = max(dyn_min_dist, _target_radius * preferred_distance_multiplier)
			_current_distance = clamp(preferred_dist, dyn_min_dist, dyn_max_dist)
			print("  Reset distance to: ", _current_distance); target_changed = true
	else:
		if _target != null: print("OrbitCamera target cleared."); target_changed = true
		_target = null; _target_radius = 10.0
	if target_changed: _update_fov()

func _get_target_effective_radius(target_node: Spatial) -> float:
	var default_radius = 10.0
	if not is_instance_valid(target_node): return default_radius
	if target_node.has_method("get_interaction_radius"):
		var radius = target_node.get_interaction_radius()
		if (radius is float or radius is int) and radius > 0.0: return max(radius, 1.0)
	return default_radius

func get_current_target() -> Spatial:
	if is_instance_valid(_target): return _target; else: return null

func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		if EventBus and EventBus.is_connected("camera_set_target_requested", self, "_on_Camera_Set_Target_Requested"):
				EventBus.disconnect("camera_set_target_requested", self, "_on_Camera_Set_Target_Requested")
		if GlobalRefs and GlobalRefs.main_camera == self:
				GlobalRefs.main_camera = null 

--- Start of ./scenes/game_world/world_manager.gd ---

# File: scenes/game_world/world_manager.gd
# Version 2.3 - Code style cleanup (Tabs, Line Length, If/Else)

extends Node

# --- NodePaths ---
const ACTIVE_MODULE_CONTAINER_PATH = "../" + Constants.CURRENT_ZONE_CONTAINER_NAME

# --- State ---
var current_zone_instance: Node = null
var _spawned_agent_bodies = []
var _player_agent_body: KinematicBody = null

# --- Initialization ---
func _ready():
	GlobalRefs.world_manager = self
	if EventBus:
		var err1 = EventBus.connect("agent_reached_destination", self,
				"_on_Agent_Reached_Destination")
		var err2 = EventBus.connect("agent_despawning", self,
				"_on_Agent_Despawning")
		var err3 = EventBus.connect("zone_loaded", self,
				"_on_Zone_Loaded_WorldManager")
		if err1 != OK or err2 != OK or err3 != OK:
			printerr("WM _ready Error: Failed connect EventBus signals!")
	else:
		printerr("WM _ready Error: EventBus not available!")

	randomize()
	print("WM: 1/13 - _ready started.")
	print("WM _ready Debug: Checking Constant value...")
	print("- Constants.INITIAL_ZONE_SCENE_PATH = '",
			Constants.INITIAL_ZONE_SCENE_PATH, "'")
	print("- Type = ", typeof(Constants.INITIAL_ZONE_SCENE_PATH))

	print("WM: 2/13 - Attempting load_zone...")
	load_zone(Constants.INITIAL_ZONE_SCENE_PATH)
	print("WM: 9/13 - Returned from initial load_zone call.")
	print("WM: 10/13 - _ready finished (Player spawn handled by signal).")


# --- Zone Management ---
func load_zone(zone_scene_path: String):
	print("WM: 3/13 - load_zone starting for path: ", zone_scene_path)

	if not zone_scene_path or zone_scene_path.empty():
		printerr("WM Error: Invalid zone path provided.")
		return

	# 1. Cleanup Previous Zone
	if is_instance_valid(current_zone_instance):
		EventBus.emit_signal("zone_unloading", current_zone_instance)
		_spawned_agent_bodies.clear()
		_player_agent_body = null
		GlobalRefs.player_agent_body = null
		GlobalRefs.current_zone = null
		GlobalRefs.agent_container = null
		current_zone_instance.queue_free()
		current_zone_instance = null

	# 2. Find Parent Container Node
	var parent_node = get_parent()
	if not is_instance_valid(parent_node):
		printerr("WM Error: Could not get valid parent node!")
		return
	var zone_holder = parent_node.get_node_or_null(
			Constants.CURRENT_ZONE_CONTAINER_NAME)

	if not zone_holder:
		printerr("WM Error: Node '", Constants.CURRENT_ZONE_CONTAINER_NAME,
				"' missing as child of parent '", parent_node.name, "'")
		return
	print("WM: 4/13 - Found zone holder: ", zone_holder.name)

	# 3. Load and Instance the Zone Scene
	var zone_scene = load(zone_scene_path)
	if not zone_scene:
		printerr("WM Error: Failed load Zone Scene Resource: ", zone_scene_path)
		return

	current_zone_instance = zone_scene.instance()
	if not current_zone_instance:
		printerr("WM Error: Failed instance Zone Scene: ", zone_scene_path)
		return

	print("WM: 5/13 - Instanced Zone Scene: ", current_zone_instance.name)

	# 4. Add Zone to Tree & Update GlobalRefs for Zone
	zone_holder.add_child(current_zone_instance)
	GlobalRefs.current_zone = current_zone_instance

	# 5. Find Agent Container *within* the Zone & Update GlobalRef
	if not is_instance_valid(current_zone_instance):
		printerr("WM Error: current_zone_instance invalid after add_child?")
		return

	var agent_cont_ref = current_zone_instance.find_node(
			Constants.AGENT_CONTAINER_NAME, true, false)
	GlobalRefs.agent_container = agent_cont_ref
	print("WM: 6/13 - Found Agent Container: ", agent_cont_ref)
	if not agent_cont_ref:
		printerr("WM Warning: Agent container '",
				Constants.AGENT_CONTAINER_NAME, "' not found in zone.")

	# 6. Emit Loaded Signal
	print("WM: 7/13 - Emitting zone_loaded signal.")
	EventBus.emit_signal("zone_loaded", current_zone_instance,
			zone_scene_path, GlobalRefs.agent_container)
	print("WM: 8/13 - load_zone finished.")


# --- Agent Spawning & Management ---
# Called by handler for zone_loaded signal
func spawn_player():
	print("WM: 12/13 - spawn_player called.")
	var container = GlobalRefs.agent_container
	if not is_instance_valid(container):
		printerr("WM spawn_player Error: GlobalRefs.agent_container invalid.")
		return

	var player_template = load(Constants.PLAYER_DEFAULT_TEMPLATE_PATH)
	if not player_template is AgentTemplate:
		printerr("WM Error: Failed load Player AgentTemplate")
		return

	var player_spawn_pos = Vector3.ZERO
	var env_instance = GlobalRefs.current_zone
	if is_instance_valid(env_instance):
		var entry_node = null
		if Constants.ENTRY_POINT_NAMES.size() > 0:
			entry_node = env_instance.find_node(
					Constants.ENTRY_POINT_NAMES[0], true, false)
		if entry_node is Spatial:
			player_spawn_pos = entry_node.global_transform.origin + Vector3(0,5,15)

	var player_overrides = { "name": "PlayerShip", "faction": "Player" }
	_player_agent_body = spawn_agent(Constants.PLAYER_AGENT_SCENE_PATH,
			player_spawn_pos, player_template, player_overrides)

	if is_instance_valid(_player_agent_body):
		GlobalRefs.player_agent_body = _player_agent_body
		EventBus.emit_signal("camera_set_target_requested", _player_agent_body)
		EventBus.emit_signal("player_spawned", _player_agent_body)
	else:
		printerr("WorldManager Error: Failed to spawn player agent body!")
	print("WM: 13/13 - spawn_player finished.")


# Generic function CALLED BY EXTERNAL systems
func spawn_agent(agent_scene_path: String, position: Vector3,
		agent_template: Resource, overrides: Dictionary = {}) -> KinematicBody:

	var container = GlobalRefs.agent_container
	if not is_instance_valid(container):
		printerr("WM Spawn Error: Invalid GlobalRefs.agent_container.")
		return null
	if not agent_template is AgentTemplate:
		printerr("WM Spawn Error: Invalid AgentTemplate Resource.")
		return null
	if not agent_scene_path or agent_scene_path.empty():
		printerr("WM Spawn Error: Invalid scene path.")
		return null

	var agent_scene = load(agent_scene_path)
	if not agent_scene:
		printerr("WM Spawn Error: Failed load agent scene: ", agent_scene_path)
		return null
	var agent_root_instance = agent_scene.instance()
	if not agent_root_instance:
		printerr("WM Spawn Error: Failed instance agent scene!")
		return null

	var agent_node = agent_root_instance.get_node_or_null(
			Constants.AGENT_BODY_NODE_NAME)
	if not agent_node or not agent_node is KinematicBody:
		var error_msg = str("WM Spawn Error: Invalid node '",
				Constants.AGENT_BODY_NODE_NAME, "' in scene: ", agent_scene_path)
		printerr(error_msg)
		agent_root_instance.queue_free()
		return null

	var instance_name = overrides.get("name",
			agent_template.default_agent_name + "_" + str(agent_root_instance.get_instance_id()))
	agent_root_instance.name = instance_name

	container.add_child(agent_root_instance)
	agent_node.global_transform.origin = position

	if agent_node.has_method("initialize"):
		agent_node.initialize(agent_template, overrides)

	_spawned_agent_bodies.append(agent_node)
	var name_to_print = instance_name
	# Expanded check using 'in' for property existence
	if "agent_name" in agent_node:
		name_to_print = agent_node.agent_name
	print("Spawned agent '", name_to_print, "' core node.")

	EventBus.emit_signal("agent_spawned", agent_node,
			{"template": agent_template, "overrides": overrides})

	var controller = agent_node.get_node_or_null(Constants.AI_CONTROLLER_NODE_NAME)
	if controller and controller.has_method("initialize"):
		controller.initialize(overrides)
	elif controller and controller.has_method("set_target") and ("initial_target" in overrides):
		controller.set_target(overrides.initial_target)

	return agent_node


# --- Signal Handlers ---
func _on_Agent_Reached_Destination(agent_body):
	if is_instance_valid(agent_body) and agent_body != _player_agent_body:
		if agent_body.has_method("despawn"):
			agent_body.despawn()
		else:
			agent_body.queue_free() # Fallback
	elif is_instance_valid(agent_body) and agent_body == _player_agent_body:
		pass # Player reached destination, do nothing here


func _on_Agent_Despawning(agent_body):
	call_deferred("_cleanup_despawned_agent_from_list", agent_body)

func _cleanup_despawned_agent_from_list(agent_instance):
	if _spawned_agent_bodies.has(agent_instance):
		_spawned_agent_bodies.erase(agent_instance)
	# Expanded check
	if _player_agent_body == agent_instance:
		print("Player agent reference cleared during cleanup.")
		_player_agent_body = null
		GlobalRefs.player_agent_body = null

func _on_Zone_Loaded_WorldManager(_zone_instance, _zone_path, agent_container_node):
	print("WM: 11/13 - Reacting to zone_loaded signal.")
	if is_instance_valid(agent_container_node):
		if not is_instance_valid(_player_agent_body):
			# Try direct call again now that other issues might be fixed
			spawn_player()
	else:
		printerr("WM _on_Zone_Loaded Error: Agent container invalid. Cannot spawn player.")


# --- Cleanup ---
func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		print("!!! WM: RECEIVED NOTIFICATION_PREDELETE !!!")
		if EventBus:
			# Expanded disconnect checks
			if EventBus.is_connected("agent_reached_destination", self, "_on_Agent_Reached_Destination"):
				EventBus.disconnect("agent_reached_destination", self, "_on_Agent_Reached_Destination")
			if EventBus.is_connected("agent_despawning", self, "_on_Agent_Despawning"):
				EventBus.disconnect("agent_despawning", self, "_on_Agent_Despawning")
			if EventBus.is_connected("zone_loaded", self, "_on_Zone_Loaded_WorldManager"):
				EventBus.disconnect("zone_loaded", self, "_on_Zone_Loaded_WorldManager")
		# Expanded GlobalRefs check
		if GlobalRefs and GlobalRefs.world_manager == self:
			GlobalRefs.world_manager = null
		# Expanded instance check
		if is_instance_valid(current_zone_instance):
			current_zone_instance.queue_free()

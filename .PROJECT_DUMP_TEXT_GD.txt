--- Start of ./autoload/Constants.gd ---

# File: autoload/Constants.gd
# Autoload Singleton: Constants
# Version: 1.3 - Reverted paths/names for Complete Zone Scene architecture

extends Node

# --- Scene Paths ---
const PLAYER_AGENT_SCENE_PATH = "res://core/agents/player_agent.tscn"
const NPC_AGENT_SCENE_PATH = "res://core/agents/npc_agent.tscn"

# Complete Zone Scene Paths (Self-contained environments with AgentContainer etc.)
const INITIAL_ZONE_SCENE_PATH = "res://scenes/zones/basic_flight_zone.tscn"
# Example future zones:
# const ZONE_ASTEROID_BELT_BETA_PATH = "res://scenes/zones/asteroid_belt_beta.tscn"
# const ZONE_SCRAPYARD_STATION_PATH = "res://scenes/zones/scrapyard_station.tscn"

# Agent Template Resource Paths
const PLAYER_DEFAULT_TEMPLATE_PATH = "res://assets/data/templates/agents/player_default.tres"
const NPC_TRAFFIC_TEMPLATE_PATH = "res://assets/data/templates/agents/npc_traffic.tres"

# Base UI Scenes
const MAIN_HUD_SCENE_PATH = "res://core/ui/main_hud.tscn"
const MAIN_MENU_SCENE_PATH = "res://scenes/main_menu/main_menu.tscn"

# --- Common Node Names ---
# Inside main_game_scene.tscn
const CURRENT_ZONE_CONTAINER_NAME = "CurrentZoneContainer"  # Node holding the loaded zone instance

# Inside Zone Scenes (e.g., basic_flight_zone.tscn)
const AGENT_CONTAINER_NAME = "AgentContainer"  # Child node for housing agents
const AGENT_MODEL_CONTAINER_NAME = "Model"
const ENTRY_POINT_NAMES = ["EntryPointA", "EntryPointB", "EntryPointC"]  # Expected Position3D/Spatial nodes

# Inside Agent Scenes (e.g., agent.tscn, npc_agent.tscn)
const AGENT_BODY_NODE_NAME = "AgentBody"  # The KinematicBody root in agent scenes
# MOVEMENT_COMPONENT_NAME removed as component was merged
const AI_CONTROLLER_NODE_NAME = "AIController"
const PLAYER_INPUT_HANDLER_NAME = "PlayerInputHandler"

# --- Core Mechanics Thresholds ---
const ACTION_CHECK_FAIL_THRESHOLD = 10
const ACTION_CHECK_SWC_THRESHOLD = 10
const ACTION_CHECK_CRIT_THRESHOLD = 14

# --- Core Mechanics Parameters ---
const FOCUS_MAX_DEFAULT = 3
const FOCUS_BOOST_PER_POINT = 1

# --- Default Simulation Values ---
const DEFAULT_MAX_MOVE_SPEED = 300.0 # m/s
const DEFAULT_ACCELERATION = 0.5 # NOT m/s^2
const DEFAULT_DECELERATION = 0.5 # NOT m/s^2
const DEFAULT_MAX_TURN_SPEED = 0.75

# --- Gameplay / Physics Approximations ---
const ORBIT_FULL_SPEED_RADIUS = 2000.0 

# --- System Defaults (Examples - Used by placeholder systems) ---
const MAX_NPCS_DEFAULT = 10
const SPAWN_INTERVAL_DEFAULT = 2.0
const TRAFFIC_SPEED_MULT_DEFAULT = 0.2
const TARGETING_RAY_LENGTH = 1e7

--- Start of ./autoload/CoreMechanicsAPI.gd ---

# File: autoload/CoreMechanicsAPI.gd
# Autoload Singleton: CoreMechanicsAPI
# Purpose: Provides globally accessible functions for core mechanic resolutions,
#          ensuring consistency across the game.
# Version: 1.0

extends Node

# Random Number Generator for dice rolls
var _rng = RandomNumberGenerator.new()


func _ready():
	# Seed the random number generator once when the game starts
	_rng.randomize()
	print("CoreMechanicsAPI Ready.")


# --- Core Action Resolution ---


# Performs the standard 3d6+Mod Action Check based on passed parameters.
# Returns a Dictionary containing the detailed results of the check.
# - module_modifier: The calculated modifier for the current action context (Skill + Asset Diff).
# - focus_points_spent: How many FP the player chose to spend (0-3) *before* the roll.
# Return Dictionary keys:
#   "roll_total": int (Final result after mods/FP)
#   "dice_sum": int (Result of 3d6 only)
#   "modifier": int (Module modifier passed in)
#   "focus_spent": int (FP spent)
#   "focus_bonus": int (Bonus gained from FP)
#   "result_tier": String ("CritSuccess", "SwC", "Failure")
#   "focus_gain": int (FP gained from this result, usually 1 on Crit)
#   "focus_loss_reset": bool (True if FP should be reset to 0 due to Failure)
func perform_action_check(module_modifier: int, focus_points_spent: int) -> Dictionary:
	# Ensure focus spent is within valid range (0 to Max FP defined in Constants)
	focus_points_spent = clamp(focus_points_spent, 0, Constants.FOCUS_MAX_DEFAULT)

	# --- Roll Dice ---
	var d1 = _rng.randi_range(1, 6)
	var d2 = _rng.randi_range(1, 6)
	var d3 = _rng.randi_range(1, 6)
	var dice_sum = d1 + d2 + d3

	# --- Calculate Bonuses ---
	var focus_bonus = focus_points_spent * Constants.FOCUS_BOOST_PER_POINT

	# --- Calculate Final Roll ---
	var total_roll = dice_sum + module_modifier + focus_bonus

	# --- Determine Outcome Tier & Focus Effects ---
	var result_tier = ""
	var focus_gain = 0
	var focus_loss_reset = false

	if total_roll >= Constants.ACTION_CHECK_CRIT_THRESHOLD:
		result_tier = "CritSuccess"
		focus_gain = 1  # Standard gain on Crit
		focus_loss_reset = false
	elif total_roll >= Constants.ACTION_CHECK_SWC_THRESHOLD:  # e.g., 10-13
		result_tier = "SwC"  # Success with Complication
		focus_gain = 0
		focus_loss_reset = false
	else:  # e.g., < 10
		result_tier = "Failure"
		focus_gain = 0
		focus_loss_reset = true  # Standard reset on Failure

	# --- Assemble Results Dictionary ---
	var results = {
		"roll_total": total_roll,
		"dice_sum": dice_sum,
		"modifier": module_modifier,
		"focus_spent": focus_points_spent,
		"focus_bonus": focus_bonus,
		"result_tier": result_tier,
		"focus_gain": focus_gain,
		"focus_loss_reset": focus_loss_reset
	}

	# --- Optional: Emit Global Signal ---
	# If many systems need to react directly to *every* check result,
	# emitting a signal here could be useful later. Requires passing agent + approach.
	# EventBus.emit_signal("action_check_resolved", agent_ref, results, approach_ref)
	# For now, let the calling script handle reactions and FP updates.

	# print("Action Check: %d (3d6=%d, Mod=%d, FP=%d(+%d)) -> %s" % [total_roll, dice_sum, module_modifier, focus_points_spent, focus_bonus, result_tier]) # Debug

	return results

# --- Potential Future Core Mechanic Functions ---

# func update_focus_state(agent_stats_ref, focus_change: int):
#     # Central logic for applying focus gain/loss, respecting cap
#     pass

# func calculate_upkeep_cost(agent_assets_ref):
#     # Central logic for determining periodic WP upkeep cost
#     return 0 # Placeholder WP cost

# func advance_time_clock(agent_stats_ref_or_global, tu_amount: int):
#     # Central logic for adding TU and checking for World Event Tick trigger
#     pass

--- Start of ./autoload/EventBus.gd ---

# File: autoload/EventBus.gd
# Version: 1.1 Added target picking.

extends Node

# --- Game State Signals ---
signal game_loaded(save_data)
# signal game_saving(slot_id)
# signal save_complete(slot_id, success)

# --- Agent Lifecycle Signals ---
# Emitted by WorldManager after agent initialized and added to tree
# init_data parameter is now Dictionary {"template": Res, "overrides": Dict}
signal agent_spawned(agent_body, init_data)
# Emitted by Agent's despawn() method via EventBus BEFORE queue_free
signal agent_despawning(agent_body)
# Emitted by AI Controller via EventBus when destination reached
signal agent_reached_destination(agent_body)
# Emitted by WorldManager after player specifically spawned
signal player_spawned(player_agent_body)

# --- Camera Control Signals ---
# Emitted by systems requesting camera target change
signal camera_set_target_requested(target_node)
# Emitted by input handlers requesting target cycle (KEEPING for potential future use)
signal camera_cycle_target_requested

# --- Player Interaction Signals --- ADDED SECTION
signal player_target_selected(target_node)
signal player_target_deselected
signal player_free_flight_toggled
signal player_stop_pressed
signal player_orbit_pressed
signal player_approach_pressed
signal player_flee_pressed
signal player_camera_zoom_changed(value)
signal player_ship_speed_changed(value)

# --- Zone Loading Signals ---
# Emitted by WorldManager before unloading current zone instance
signal zone_unloading(zone_node)  # zone_node is the root of the scene being unloaded
# Emitted by WorldManager when starting to load a new zone path
signal zone_loading(zone_path)  # zone_path is path to the complete zone scene
# Emitted by WorldManager after new zone is instanced, added, container found
# zone_node is root of the new zone instance, agent_container_node is ref inside it
signal zone_loaded(zone_node, zone_path, agent_container_node)

# --- Core Mechanics / Gameplay Events (Placeholders) ---
# signal action_check_resolved(agent_body, result_dictionary, action_approach)
# signal focus_changed(agent_body, new_focus_value)
# signal wealth_changed(agent_body, new_wealth_value)
# signal world_event_tick_triggered()

# --- Goal System Events (Placeholders) ---
# signal goal_progress_updated(agent_body, goal_id, new_progress)
# signal goal_completed(agent_body, goal_id, success_level)

# --- Module Specific Signals (Placeholders - Use sparingly) ---
# signal major_discovery_made(discovery_data)


func _ready():
	print("EventBus Ready.")

--- Start of ./autoload/GameStateManager.gd ---

# File: autoload/GameStateManager.gd
# Autoload Singleton: GameStateManager
# Purpose: Handles saving and loading game state.
# Version: 1.1 - Corrected ProjectSettings.get_setting for Godot 3

extends Node

const SAVE_DIR = "user://savegames/"
const SAVE_FILE_PREFIX = "save_"
const SAVE_FILE_EXT = ".sav"  # Godot's variant storage format


func _ready():
	print("GameStateManager Ready.")
	# Ensure save directory exists on startup
	var dir = Directory.new()
	if not dir.dir_exists(SAVE_DIR):
		var err = dir.make_dir_recursive(SAVE_DIR)
		if err != OK:
			printerr(
				"GameStateManager Error: Could not create save directory: ",
				SAVE_DIR,
				" Error: ",
				err
			)


# --- Save Game ---
# Returns true on success, false on failure
func save_game(slot_id: int) -> bool:
	print("Attempting to save game to slot ", slot_id)
	var save_data = {}  # Dictionary to hold all save data

	# --- (Gathering Data) ---
	# 1. Player Data
	if is_instance_valid(GlobalRefs.player_agent_body):
		var player_data = {}
		player_data["scene_path"] = Constants.PLAYER_AGENT_SCENE_PATH
		player_data["position_x"] = GlobalRefs.player_agent_body.global_transform.origin.x
		player_data["position_y"] = GlobalRefs.player_agent_body.global_transform.origin.y
		player_data["position_z"] = GlobalRefs.player_agent_body.global_transform.origin.z
		player_data["rotation_basis_cols"] = [
			GlobalRefs.player_agent_body.global_transform.basis.x,
			GlobalRefs.player_agent_body.global_transform.basis.y,
			GlobalRefs.player_agent_body.global_transform.basis.z
		]
		player_data["position_z"] = GlobalRefs.player_agent_body.global_transform.origin.z
		save_data["player_state"] = player_data
	else:
		printerr("Save Error: Player agent body not valid!")
		return false

	# 2. Character System Data (FP, WP, Skills, etc.) - Assumed Placeholder
	if (
		is_instance_valid(GlobalRefs.character_system)
		and GlobalRefs.character_system.has_method("get_player_save_data")
	):
		save_data["character_state"] = GlobalRefs.character_system.get_player_save_data()
	else:
		print("Save Warning: CharacterSystem missing or no save method. FP/WP/Skills NOT saved.")

	# 3. World State
	var world_data = {}
	if is_instance_valid(GlobalRefs.current_zone):
		world_data["current_zone_path"] = GlobalRefs.current_zone.filename
	else:
		printerr("Save Error: Current zone reference invalid!")
		return false
	# TODO: Add Time Clock Value - Requires Time System/Manager reference
	# world_data["time_clock_tu"] = GlobalRefs.time_manager.get_current_tu()
	save_data["world_state"] = world_data

	# 4. Goal System State - Assumed Placeholder
	# if is_instance_valid(GlobalRefs.goal_system) and GlobalRefs.goal_system.has_method("get_save_data"):
	#     save_data["goal_system_state"] = GlobalRefs.goal_system.get_save_data()

	# 5. Add Metadata
	# *** CORRECTED for Godot 3 ***
	var game_version_setting = ProjectSettings.get_setting("application/config/version")
	var game_version = "0.0.1"  # Default version
	if game_version_setting != null:
		game_version = str(game_version_setting)  # Ensure it's a string if found
	# *** END CORRECTION ***

	save_data["metadata"] = {"save_time": OS.get_unix_time(), "game_version": game_version}

	# --- Writing File ---
	var file = File.new()
	var path = SAVE_DIR + SAVE_FILE_PREFIX + str(slot_id) + SAVE_FILE_EXT
	var err = file.open(path, File.WRITE)

	if err == OK:
		# Use true for share/compression - valid in Godot 3
		file.store_var(save_data, true)
		file.close()
		print("Game saved successfully to: ", path)
		return true
	else:
		printerr("Error saving game to path: ", path, " Error code: ", err)
		file.close()  # Ensure file is closed even on error
		return false


# --- Load Game ---
# Returns true on success, false on failure
func load_game(slot_id: int) -> bool:
	print("Load attempt for slot ", slot_id)
	var path = get_save_slot_path(slot_id)
	print("Load path: ", path)

	var file = File.new()
	if not file.file_exists(path):
		printerr("Load Error: Save file not found at path!")
		return false

	print("Load Debug: File exists. Attempting to open...")
	var err = file.open(path, File.READ)
	if err != OK:
		printerr("Load Error: Failed to open file for reading! Error code: ", err)
		return false

	print("Load Debug: File opened. Attempting to get var...")
	# Use true if store_var used true
	var save_data = file.get_var(true)
	var file_err = file.get_error()  # Check error *after* operation
	file.close()  # Close file immediately

	if file_err != OK:
		printerr("Load Error: Error reading var from file! File Error code: ", file_err)
		return false

	print("Load Debug: Got var. Checking type...")
	if not save_data is Dictionary:
		printerr("Load Error: Save file data is not a Dictionary! Type is: ", typeof(save_data))
		return false

	print("Save file loaded successfully. Applying state...")
	# ... (Placeholder apply logic) ...
	EventBus.emit_signal("game_loaded", save_data)
	return true

	# --- Apply Loaded State ---
	# This section requires careful coordination with scene loading and initialization.
	# It might need to emit signals or use call_deferred extensively.
	# Placeholder logic - assumes this is called from a state where loading is safe (e.g., main menu)

	# 1. Request Zone Load (WorldManager listens for this?) - NEEDS A ROBUST WORKFLOW
	if save_data.has("world_state") and save_data.world_state.has("current_zone_path"):
		var zone_path = save_data.world_state.current_zone_path
		if (
			is_instance_valid(GlobalRefs.world_manager)
			and GlobalRefs.world_manager.has_method("load_zone")
		):
			# Ideally, loading should happen via scene transition, not direct call here.
			# For now, just logging. Actual loading needs proper handling.
			print("Load Request: Need to load zone: ", zone_path)
			# GlobalRefs.world_manager.load_zone(zone_path) # Direct call here is usually problematic
			# Need a system to handle scene transition THEN player spawn/restore
			# Emit signal instead? EventBus.emit_signal("load_zone_requested", zone_path, save_data)
		else:
			printerr("Load Error: Cannot request zone load, WorldManager invalid/missing method.")
			return false
	else:
		printerr("Load Error: Save data missing world state or zone path.")
		return false

	# 2. Restore Player State (Should happen AFTER zone is loaded)
	# This logic needs to be triggered *after* the scene transition and player spawn.
	# Placeholder - This should be handled by CharacterSystem reacting to load event or player spawn
	if save_data.has("player_state"):
		var p_state = save_data.player_state
		var p_pos = Vector3(
			p_state.get("position_x", 0), p_state.get("position_y", 0), p_state.get("position_z", 0)
		)
		var p_basis_cols = p_state.get(
			"rotation_basis_cols", [Vector3.RIGHT, Vector3.UP, Vector3.BACK]
		)
		var p_basis = Basis(p_basis_cols[0], p_basis_cols[1], p_basis_cols[2])
		# Need to apply pos/rot AFTER player is spawned in the new zone.
		print("Load Request: Player should spawn at ", p_pos, " with rotation")

	if save_data.has("character_state"):
		# CharacterSystem should listen for game_loaded or player_spawned signal
		# and apply this data to the player agent
		print("Load Request: Character state needs restore: ", save_data.character_state)
		# GlobalRefs.character_system.load_save_data(save_data.character_state)

	# 3. Restore Time Clock
	# print("Load Request: Time clock needs restore")
	# GlobalRefs.time_manager.load_save_data(...)

	# 4. Restore Goal System State
	# print("Load Request: Goals need restore")
	# GlobalRefs.goal_system.load_save_data(...)

	# 5. Restore Persistent NPCs (Later Phase)

	# 6. Emit signal that load data is ready (systems should listen and apply)
	print("Load Process: Emitting game_loaded signal...")
	EventBus.emit_signal("game_loaded", save_data)  # Pass full data

	# IMPORTANT: Returning true here only means the file was read.
	# Actual game state restoration is asynchronous and depends on listeners.
	return true


# --- Helper Functions ---
func get_save_slot_path(slot_id: int) -> String:
	return SAVE_DIR + SAVE_FILE_PREFIX + str(slot_id) + SAVE_FILE_EXT


func save_exists(slot_id: int) -> bool:
	var file = File.new()
	return file.file_exists(get_save_slot_path(slot_id))


# Gets only the metadata part of a save file, if possible
func get_save_metadata(slot_id: int) -> Dictionary:
	var path = get_save_slot_path(slot_id)
	var file = File.new()
	if not file.file_exists(path):
		return {}
	var err = file.open(path, File.READ)
	if err != OK:
		return {}
	# Use false here if we ONLY want the top-level dict, not full object parsing
	# Depends if metadata is stored simply at top level
	var data = file.get_var(true)
	file.close()
	if data is Dictionary and data.has("metadata"):
		return data.metadata
	# Try parsing non-shared if metadata is simple? Might fail on complex saves.
	# var file2 = File.new(); file2.open(path, File.READ); var data2 = file2.get_var(false); file2.close()
	# if data2 is Dictionary and data2.has("metadata"): return data2.metadata
	print("Warning: Could not read metadata from save slot ", slot_id)
	return {}

--- Start of ./autoload/GlobalRefs.gd ---

# File: autoload/GlobalRefs.gd
# Autoload Singleton: GlobalRefs
# Purpose: Holds easily accessible references to unique global nodes/managers.
# Nodes register themselves here via setter functions during their _ready() phase.
# Version: 1.0

extends Node

# --- Key Node References ---
# Other scripts access these directly (e.g., GlobalRefs.player_agent_body)
# but should ALWAYS check if is_instance_valid() first!

var player_agent_body = null setget set_player_agent_body #KinematicBody, spawned by WM
var main_camera = null setget set_main_camera
var world_manager = null setget set_world_manager
var event_system = null setget set_event_system  # If EventSystem is a Node, not Autoload
var goal_system = null setget set_goal_system  # If GoalSystem is a Node
var character_system = null setget set_character_system  # If CharacterSystem is a Node
var asset_system = null setget set_asset_system  # If AssetSystem is a Node

# Add other core system node references as needed...
var current_zone = null setget set_current_zone  # Reference to the root node of the loaded zone scene
var agent_container = null setget set_agent_container  # Reference to the node *within* the zone where agents are parented
var main_hud = null setget set_main_hud 

func _ready():
	print("GlobalRefs Ready.")
	# This script typically doesn't do much itself, it just holds references set by others.


# --- Setters (Provide controlled way to update references & add validation) ---
# Using setget ensures these are called automatically on assignment.


func set_player_agent_body(new_ref):
	if new_ref == player_agent_body:
		return  # No change
	if new_ref == null or is_instance_valid(new_ref):
		player_agent_body = new_ref
		print("GlobalRefs: Player Agent reference ", "set to ", new_ref.name if new_ref else "null")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Player Agent reference: ", new_ref)


func set_main_camera(new_ref):
	if new_ref == main_camera:
		return
	if new_ref == null or is_instance_valid(new_ref):
		main_camera = new_ref
		print("GlobalRefs: Main Camera reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Main Camera reference: ", new_ref)


func set_world_manager(new_ref):
	if new_ref == world_manager:
		return
	if new_ref == null or is_instance_valid(new_ref):
		world_manager = new_ref
		print("GlobalRefs: World Manager reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid World Manager reference: ", new_ref)


func set_event_system(new_ref):
	if new_ref == event_system:
		return
	if new_ref == null or is_instance_valid(new_ref):
		event_system = new_ref
		print("GlobalRefs: Event System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Event System reference: ", new_ref)


func set_goal_system(new_ref):
	if new_ref == goal_system:
		return
	if new_ref == null or is_instance_valid(new_ref):
		goal_system = new_ref
		print("GlobalRefs: Goal System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Goal System reference: ", new_ref)


func set_character_system(new_ref):
	if new_ref == character_system:
		return
	if new_ref == null or is_instance_valid(new_ref):
		character_system = new_ref
		print("GlobalRefs: Character System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Character System reference: ", new_ref)


func set_asset_system(new_ref):
	if new_ref == asset_system:
		return
	if new_ref == null or is_instance_valid(new_ref):
		asset_system = new_ref
		print("GlobalRefs: Asset System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Asset System reference: ", new_ref)


func set_current_zone(new_ref):
	if new_ref == current_zone:
		return
	if new_ref == null or is_instance_valid(new_ref):
		current_zone = new_ref
		print("GlobalRefs: Current Zone reference ", "set to ", new_ref.name if new_ref else "null")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Current Zone reference: ", new_ref)


func set_agent_container(new_ref):
	if new_ref == agent_container:
		return
	if new_ref == null or is_instance_valid(new_ref):
		agent_container = new_ref
		print(
			"GlobalRefs: Agent Container reference ", "set to ", new_ref.name if new_ref else "null"
		)
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Agent Container reference: ", new_ref)


func set_main_hud(new_ref):
	if new_ref == main_hud:
		return
	if new_ref == null or is_instance_valid(new_ref):
		main_hud = new_ref
		print(
			"GlobalRefs: Main HUD reference ", "set to ", new_ref.name if new_ref else "null"
		)
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Main HUD reference: ", new_ref)

# --- Optional: Add simple getter functions if needed ---
# func get_player() -> KinematicBody:
#     return player_agent_body if is_instance_valid(player_agent_body) else null

--- Start of ./core/agents/agent.gd ---

# File: res://core/agents/agent.gd (Attached to AgentBody KinematicBody)
# Version: 3.33 - Fetched component nodes inside initialize() due to execution order.
extends KinematicBody

# --- Core State & Identity ---
var agent_name: String = "Default Agent"
var faction_id: String = "Neutral"
var template_id: String = "default"
var interaction_radius: float = 15.0

# --- Physics State ---
var current_velocity: Vector3 = Vector3.ZERO

# --- Component References ---
# Declare vars, assign them in initialize() now
var movement_system: Node = null
var navigation_system: Node = null


# --- Initialization ---
# Called externally (e.g., by WorldManager) after instancing and adding to tree
func initialize(template: AgentTemplate, overrides: Dictionary = {}):
	# 1. Basic AgentBody Initialization
	if not template is AgentTemplate:
		printerr("AgentBody Initialize Error: Invalid template for ", self.name)
		return

	self.template_id = template.template_id
	var default_name = template.default_agent_name + "_" + str(get_instance_id())
	self.agent_name = overrides.get("name", default_name)
	self.faction_id = overrides.get("faction", template.default_faction_id)
	self.name = self.agent_name  # Set Node name
	self.interaction_radius = overrides.get("interaction_radius", template.interaction_radius)

	# *** Fetch Component Nodes HERE inside initialize ***
	movement_system = get_node_or_null("MovementSystem")
	navigation_system = get_node_or_null("NavigationSystem")

	# *** Check if references were successfully obtained NOW ***
	if not is_instance_valid(movement_system) or not is_instance_valid(navigation_system):
		printerr(
			"AgentBody Initialize Error: Failed to get required component nodes (MovementSystem or NavigationSystem) for '",
			self.name,
			"'. Check node names and scene structure."
		)
		set_physics_process(false)  # Disable physics if components are missing
		return  # Stop initialization

	# If we got here, components were found successfully.

	# 2. Prepare Params for Components
	var move_params = {
		"max_move_speed": overrides.get("max_move_speed", template.max_move_speed),
		"acceleration": overrides.get("acceleration", template.acceleration),
		"deceleration": overrides.get("deceleration", template.deceleration),
		"max_turn_speed": overrides.get("max_turn_speed", template.max_turn_speed),
		"brake_strength": overrides.get("brake_strength", template.deceleration * 1.5),
		"alignment_threshold_angle_deg":
		overrides.get("alignment_threshold_angle_deg", template.alignment_threshold_angle_deg)
	}
	var nav_params = {
		"orbit_kp": overrides.get("orbit_kp", 3.0),
		"orbit_ki": overrides.get("orbit_ki", 0.1),
		"orbit_kd": overrides.get("orbit_kd", 0.5)
	}

	# 3. Initialize Components
	movement_system.initialize_movement_params(move_params)
	navigation_system.initialize_navigation(nav_params, movement_system)  # Pass ref to movement_system

	print(
		"AgentBody '",
		self.name,
		"' initialized WITH COMPONENTS successfully using template '",
		self.template_id,
		"'."
	)


# --- Godot Lifecycle ---
func _ready():
	add_to_group("Agents")
	# No need to fetch nodes here anymore, moved to initialize()
	set_physics_process(true)  # Enable physics processing


func _physics_process(delta: float):
	# Check components validity just in case something weird happens after init
	if not is_instance_valid(navigation_system) or not is_instance_valid(movement_system):
		# If components somehow became invalid after successful init, stop processing.
		if delta > 0:  # Avoid printing flood if physics is disabled
			printerr("AgentBody _physics_process Error: Components invalid for '", self.name, "'!")
		set_physics_process(false)
		return

	if delta <= 0.0001:
		return

	# 1. Update Navigation & Movement Logic
	navigation_system.update_navigation(delta)

	# 2. Apply Physics Engine Movement
	current_velocity = move_and_slide(current_velocity, Vector3.UP)

	# 3. Apply Post-Movement Corrections (e.g., PID)
	navigation_system.apply_orbit_pid_correction(delta)

	# 4. Final Velocity Clamping
	var max_speed = movement_system.max_move_speed
	if current_velocity.length_squared() > max_speed * max_speed:
		current_velocity = current_velocity.normalized() * max_speed


# --- Public Command API (Delegates to NavigationSystem) ---
# (Command functions remain the same as v3.32)
# ...
func command_stop():
	if is_instance_valid(navigation_system):
		navigation_system.set_command_stopping()
	else:
		printerr("AgentBody: Cannot command_stop - NavigationSystem invalid.")


func command_move_to(position: Vector3):
	if is_instance_valid(navigation_system):
		navigation_system.set_command_move_to(position)
	else:
		printerr("AgentBody: Cannot command_move_to - NavigationSystem invalid.")


func command_move_direction(direction: Vector3):
	if is_instance_valid(navigation_system):
		navigation_system.set_command_move_direction(direction)
	else:
		printerr("AgentBody: Cannot command_move_direction - NavigationSystem invalid.")


func command_approach(target: Spatial):
	if is_instance_valid(navigation_system):
		navigation_system.set_command_approach(target)
	else:
		printerr("AgentBody: Cannot command_approach - NavigationSystem invalid.")


func command_orbit(target: Spatial):
	if not is_instance_valid(target):
		printerr("AgentBody: command_orbit - Invalid target node provided.")
		if is_instance_valid(navigation_system):
			navigation_system.set_command_stopping()
		return

	if is_instance_valid(navigation_system):
		var vec_to_target_local = to_local(target.global_transform.origin)
		var orbit_clockwise = vec_to_target_local.x > 0.01
		var target_size = navigation_system._get_target_effective_size(target)
		var current_dist = global_transform.origin.distance_to(target.global_transform.origin)
		var min_orbit_dist = target_size + 1.0
		var captured_orbit_dist = max(current_dist, min_orbit_dist)
		navigation_system.set_command_orbit(target, captured_orbit_dist, orbit_clockwise)
	else:
		printerr("AgentBody: Cannot command_orbit - NavigationSystem invalid.")


func command_flee(target: Spatial):
	if is_instance_valid(navigation_system):
		navigation_system.set_command_flee(target)
	else:
		printerr("AgentBody: Cannot command_flee - NavigationSystem invalid.")


func command_align_to(direction: Vector3):
	if is_instance_valid(navigation_system):
		navigation_system.set_command_align_to(direction)
	else:
		printerr("AgentBody: Cannot command_align_to - NavigationSystem invalid.")


# --- Public Getters ---
func get_interaction_radius() -> float:
	return interaction_radius


# --- Despawn ---
func despawn():
	print("AgentBody '", self.name, "' despawning...")
	EventBus.emit_signal("agent_despawning", self)
	set_physics_process(false)
	call_deferred("queue_free")
# ...

--- Start of ./core/agents/agent_template.gd ---

# File: core/agents/agent_template.gd
# Resource Definition for Agent Stats/Config
# Version: 1.1 - Added alignment threshold export

extends Resource
class_name AgentTemplate  # Allows type hinting and creating this resource type in editor

# --- Identification ---
export var template_id: String = "default_template"  # Unique ID for this template type
export var default_agent_name: String = "Agent"  # Base name for agents using this
export var default_faction_id: String = "Neutral"  # Default faction

# --- Base Movement Capabilities (Reads defaults from Constants) ---
export var max_move_speed: float = Constants.DEFAULT_MAX_MOVE_SPEED
export var acceleration: float = Constants.DEFAULT_ACCELERATION
export var deceleration: float = Constants.DEFAULT_DECELERATION
export var max_turn_speed: float = Constants.DEFAULT_MAX_TURN_SPEED

# --- Interaction Size ---
# Used by camera targeting, docking, etc. Represents effective size.
export var interaction_radius: float = 15.0  # Default reasonable size

# --- NEW: Alignment Threshold ---
# Agent will only accelerate forward if facing within this angle (degrees) of the target direction.
# Relevant for MOVE_TO, MOVE_DIRECTION, APPROACH, FLEE commands.
export var alignment_threshold_angle_deg: float = 45.0

# --- Base Combat Stats (Placeholders - Link to Combat Module/Character System later) ---
# export var base_hull : int = 100
# export var base_shields : int = 0

# --- Base Skills (Placeholders - Link to Character System later) ---
# These represent the inherent skill level associated with this *type* of agent
# export var base_piloting_skill : int = 0
# export var base_tech_skill : int = 0
# export var base_social_skill : int = 0

# --- AI Behavior Hint (Optional) ---
# export var default_ai_behavior : String = "idle" # Hint for AI controller selection/init

# --- Visuals / Asset Links (Placeholders) ---
# Optional: Could link to default ship model path, visual effects, etc.
# export (String, FILE, "*.tscn,*.glb,*.gltf") var default_model_path = ""

--- Start of ./core/agents/components/movement_system.gd ---

# File: res://core/agents/components/movement_system.gd
# Version: 1.0
# Purpose: Handles the low-level execution of agent movement and rotation physics.
# Called by NavigationSystem.

extends Node

# --- Movement Capabilities (Set by AgentBody during initialize) ---
var max_move_speed: float = Constants.DEFAULT_MAX_MOVE_SPEED
var acceleration: float = Constants.DEFAULT_ACCELERATION
var deceleration: float = Constants.DEFAULT_DECELERATION
var brake_strength: float = Constants.DEFAULT_DECELERATION * 1.5  # Default derived value
var max_turn_speed: float = Constants.DEFAULT_MAX_TURN_SPEED
var alignment_threshold_angle_deg: float = 45.0
var _alignment_threshold_rad: float = deg2rad(alignment_threshold_angle_deg)

# Reference to the parent AgentBody KinematicBody
var agent_body: KinematicBody = null


func _ready():
	# Get reference to parent body ONCE. Assumes this node is direct child.
	agent_body = get_parent()
	if not agent_body is KinematicBody:
		printerr("MovementSystem Error: Parent is not a KinematicBody!")
		agent_body = null  # Invalidate if wrong type
		set_process(false)  # Disable if setup fails


# Called by AgentBody's initialize method
func initialize_movement_params(params: Dictionary):
	max_move_speed = params.get("max_move_speed", max_move_speed)
	acceleration = params.get("acceleration", acceleration)
	deceleration = params.get("deceleration", deceleration)
	brake_strength = params.get("brake_strength", deceleration * 1.5)  # Use provided or derive default
	max_turn_speed = params.get("max_turn_speed", max_turn_speed)
	alignment_threshold_angle_deg = params.get(
		"alignment_threshold_angle_deg", alignment_threshold_angle_deg
	)
	_alignment_threshold_rad = deg2rad(alignment_threshold_angle_deg)
	print(
		(
			"MovementSystem Initialized: Speed=%.1f, Accel=%.1f, Decel=%.1f, Turn=%.1f, Align=%.1f"
			% [
				max_move_speed,
				acceleration,
				deceleration,
				max_turn_speed,
				alignment_threshold_angle_deg
			]
		)
	)


# --- Public Methods Called by NavigationSystem ---


# Applies acceleration towards max_move_speed ONLY if aligned within threshold.
# Modifies agent_body.current_velocity directly.
func apply_acceleration(target_direction: Vector3, delta: float):
	if not is_instance_valid(agent_body):
		return

	if target_direction.length_squared() < 0.001:
		# If target direction is zero, just decelerate
		apply_deceleration(delta)
		return

	var target_dir_norm = target_direction.normalized()
	var current_forward = -agent_body.global_transform.basis.z.normalized()
	# Calculate the angle between current forward and target direction
	var angle = current_forward.angle_to(target_dir_norm)

	# Check if angle is within the alignment threshold
	if angle <= _alignment_threshold_rad:
		# Aligned: Interpolate towards target velocity
		var target_velocity = target_dir_norm * max_move_speed
		agent_body.current_velocity = agent_body.current_velocity.linear_interpolate(
			target_velocity, acceleration * delta
		)
		# agent_body._is_braking = false # State managed by NavigationSystem or AgentBody now
	else:
		# Not aligned: Apply natural deceleration while turning continues
		apply_deceleration(delta)


# Applies natural deceleration (drag). Modifies agent_body.current_velocity.
func apply_deceleration(delta: float):
	if not is_instance_valid(agent_body):
		return
	agent_body.current_velocity = agent_body.current_velocity.linear_interpolate(
		Vector3.ZERO, deceleration * delta
	)
	# agent_body._is_braking = false


# Applies active braking force. Modifies agent_body.current_velocity.
# Returns true if velocity is considered stopped.
func apply_braking(delta: float) -> bool:
	if not is_instance_valid(agent_body):
		return true  # Assume stopped if no body
	agent_body.current_velocity = agent_body.current_velocity.linear_interpolate(
		Vector3.ZERO, brake_strength * delta
	)
	# agent_body._is_braking = true
	# Return true if velocity is very close to zero
	return agent_body.current_velocity.length_squared() < 0.5


# Handles rotation towards a target look direction using Slerp.
# Modifies agent_body.global_transform.basis directly.
func apply_rotation(target_look_dir: Vector3, delta: float):
	if not is_instance_valid(agent_body):
		return

	if target_look_dir.length_squared() < 0.001:
		return  # Ignore zero vector

	var target_dir = target_look_dir.normalized()
	# --- IMPORTANT: Operate on the PARENT's basis ---
	var current_basis = agent_body.global_transform.basis.orthonormalized()

	# Determine the 'up' vector for looking_at, avoiding gimbal lock
	var up_vector = Vector3.UP
	if abs(target_dir.dot(Vector3.UP)) > 0.999:
		up_vector = Vector3.FORWARD  # Use Forward as fallback up vector

	# Calculate the target basis using looking_at
	var target_basis = Transform(Basis(), Vector3.ZERO).looking_at(target_dir, up_vector).basis.orthonormalized()

	# Check if already aligned (approximately)
	if current_basis.is_equal_approx(target_basis):
		return

	# Rotate towards the target basis using Slerp if turn speed is positive
	if max_turn_speed > 0.001:
		var turn_step = max_turn_speed * delta  # Rotation amount this frame
		var new_basis = current_basis.slerp(target_basis, turn_step)
		# --- IMPORTANT: Apply result back to PARENT's basis ---
		agent_body.global_transform.basis = new_basis
	else:
		# If turn speed is zero, snap instantly
		agent_body.global_transform.basis = target_basis

--- Start of ./core/agents/components/navigation_system.gd ---

# File: res://core/agents/components/navigation_system.gd
# Version: 1.4.3 - Reworked size calculation to prioritize combined Model AABB radius.
extends Node

# --- Enums and Constants ---
enum CommandType { IDLE, STOPPING, MOVE_TO, MOVE_DIRECTION, APPROACH, ORBIT, FLEE, ALIGN_TO }
const APPROACH_DISTANCE_MULTIPLIER = 1.3  # Factor of target size for stopping distance
const APPROACH_MIN_DISTANCE = 50.0  # Minimum stopping distance regardless of size
const APPROACH_DECELERATION_START_DISTANCE_FACTOR = 50.0  # Start PID deceleration when distance <= this * desired_stop_dist

# Thresholds for considering PID-controlled arrival complete (tune these)
const ARRIVAL_DISTANCE_THRESHOLD = 5.0
const ARRIVAL_SPEED_THRESHOLD_SQ = 1.0  # Squared speed (1 m/s)^2
# Threshold for considering an orbit "close" to suppress strong outward push
const CLOSE_ORBIT_DISTANCE_THRESHOLD_FACTOR = 1.5  # Multiplier for APPROACH_MIN_DISTANCE

# --- References (Set by AgentBody) ---
var agent_body: KinematicBody = null
var movement_system: Node = null  # Reference to the MovementSystem sibling node

# --- State ---
var _current_command = {}  # Holds the active command dictionary

# --- PID Controller Instances --- # DECLARED HERE, INSTANTIATED IN initialize_navigation
var _orbit_pid: PIDController = null  # For maintaining orbit distance
var _approach_pid: PIDController = null  # For controlling approach speed based on distance
var _move_to_pid: PIDController = null  # For controlling move speed based on distance

# --- Initialization ---


func _ready():
	# Initial state is typically set via AgentBody calling a command method
	# Ensure a default state if nothing else is called *after* initialization
	if not _current_command:
		set_command_idle()


# Called by AgentBody's initialize method
func initialize_navigation(nav_params: Dictionary, move_sys_ref: Node):
	# Store references provided by AgentBody
	movement_system = move_sys_ref
	agent_body = get_parent()  # Assume NavigationSystem is a direct child of AgentBody

	# Safety check references BEFORE using them
	if not is_instance_valid(agent_body):
		printerr("NavigationSystem Error: Parent AgentBody is not valid!")
		return
	if not is_instance_valid(movement_system):
		printerr("NavigationSystem Error: MovementSystem reference is not valid!")
		return

	# --- Instantiate PID Controllers HERE ---
	var PIDControllerScript = load("res://core/utils/pid_controller.gd")
	if PIDControllerScript:
		_orbit_pid = PIDControllerScript.new()
		_approach_pid = PIDControllerScript.new()
		_move_to_pid = PIDControllerScript.new()
		#print("NavigationSystem: PID Controllers instantiated.")
	else:
		printerr(
			"NavigationSystem Error: Failed to load PIDController script! Cannot initialize PIDs."
		)

	# --- Initialize PID controllers ---
	# Orbit PID
	if is_instance_valid(_orbit_pid):
		var pid_kp = nav_params.get("orbit_kp", 0.5)
		var pid_ki = nav_params.get("orbit_ki", 0.001)
		var pid_kd = nav_params.get("orbit_kd", 1.0)
		var pid_i_limit = nav_params.get("orbit_pid_integral_limit", 1000.0)
		var pid_o_limit = nav_params.get("orbit_pid_output_limit", 75.0)
		_orbit_pid.initialize(pid_kp, pid_ki, pid_kd, pid_i_limit, pid_o_limit)
		#print("  Orbit PID Initialized (Kp=%.2f, Ki=%.2f, Kd=%.2f)" % [pid_kp, pid_ki, pid_kd])
	else:
		printerr(
			"NavigationSystem Error: _orbit_pid instance is not valid during initialization (Instantiation likely failed)."
		)

	# Approach PID (**NEEDS TUNING**)
	if is_instance_valid(_approach_pid):
		var ap_kp = nav_params.get("approach_kp", 0.5)
		var ap_ki = nav_params.get("approach_ki", 0.001)
		var ap_kd = nav_params.get("approach_kd", 1.0)
		var ap_o_limit = movement_system.max_move_speed
		_approach_pid.initialize(ap_kp, ap_ki, ap_kd, 1000.0, ap_o_limit)
		#print(
		#	(
		#		"  Approach PID Initialized (**TUNE ME**: Kp=%.3f, Ki=%.3f, Kd=%.3f)"
		#		% [ap_kp, ap_ki, ap_kd]
		#	)
		#)
	else:
		printerr(
			"NavigationSystem Error: _approach_pid instance not valid during init (Instantiation likely failed)."
		)

	# Move To PID (**NEEDS TUNING**)
	if is_instance_valid(_move_to_pid):
		var mt_kp = nav_params.get("move_to_kp", 0.5)
		var mt_ki = nav_params.get("move_to_ki", 0.001)
		var mt_kd = nav_params.get("move_to_kd", 1.0)
		var mt_o_limit = movement_system.max_move_speed
		_move_to_pid.initialize(mt_kp, mt_ki, mt_kd, 1000.0, mt_o_limit)
		#print(
		#	(
		#		"  MoveTo PID Initialized (**TUNE ME**: Kp=%.3f, Ki=%.3f, Kd=%.3f)"
		#		% [mt_kp, mt_ki, mt_kd]
		#	)
		#)
	else:
		printerr(
			"NavigationSystem Error: _move_to_pid instance not valid during init (Instantiation likely failed)."
		)

	print("NavigationSystem Initialized.")
	if not _current_command:
		set_command_idle()


# --- Public Command Setting Methods (Called by AgentBody) ---


func set_command_idle():
	var last_look = (
		-agent_body.global_transform.basis.z
		if is_instance_valid(agent_body)
		else Vector3.BACK
	)
	if _current_command:
		if "target_dir" in _current_command:
			last_look = _current_command.target_dir
		elif "target_node" in _current_command:
			var cmd_target = _current_command.get("target_node")
			if is_instance_valid(cmd_target) and is_instance_valid(agent_body):
				last_look = (cmd_target.global_transform.origin - agent_body.global_transform.origin).normalized()

	_current_command = {"type": CommandType.IDLE, "target_dir": last_look}


func set_command_stopping():
	_current_command = {"type": CommandType.STOPPING}
	if is_instance_valid(_orbit_pid):
		_orbit_pid.reset()
	if is_instance_valid(_approach_pid):
		_approach_pid.reset()
	if is_instance_valid(_move_to_pid):
		_move_to_pid.reset()


func set_command_move_to(position: Vector3):
	_current_command = {"type": CommandType.MOVE_TO, "target_pos": position}
	if is_instance_valid(_orbit_pid):
		_orbit_pid.reset()
	if is_instance_valid(_approach_pid):
		_approach_pid.reset()
	if is_instance_valid(_move_to_pid):
		_move_to_pid.reset()


func set_command_move_direction(direction: Vector3):
	if direction.length_squared() < 0.001:
		printerr("NavigationSystem: Invalid direction vector for MOVE_DIRECTION.")
		set_command_stopping()
		return
	_current_command = {"type": CommandType.MOVE_DIRECTION, "target_dir": direction.normalized()}
	if is_instance_valid(_orbit_pid):
		_orbit_pid.reset()
	if is_instance_valid(_approach_pid):
		_approach_pid.reset()
	if is_instance_valid(_move_to_pid):
		_move_to_pid.reset()


func set_command_approach(target: Spatial):
	if not is_instance_valid(target):
		printerr("NavigationSystem: Invalid target node for APPROACH.")
		set_command_stopping()
		return

	if is_instance_valid(agent_body):
		var target_pos = target.global_transform.origin
		var target_size = _get_target_effective_size(target)  # This now returns radius
		# desired_stop_dist is distance from center, so use radius directly
		var desired_stop_dist = max(
			APPROACH_MIN_DISTANCE, target_size * APPROACH_DISTANCE_MULTIPLIER
		)
		var current_distance = agent_body.global_transform.origin.distance_to(target_pos)

		if current_distance < (desired_stop_dist + ARRIVAL_DISTANCE_THRESHOLD):
			#print("Agent ", agent_body.name, " already within approach range. Switching to IDLE.")
			EventBus.emit_signal("agent_reached_destination", agent_body)
			set_command_idle()
			return

	_current_command = {"type": CommandType.APPROACH, "target_node": target}
	if is_instance_valid(_orbit_pid):
		_orbit_pid.reset()
	if is_instance_valid(_approach_pid):
		_approach_pid.reset()
	if is_instance_valid(_move_to_pid):
		_move_to_pid.reset()


# Accepts the calculated/captured distance from the caller (e.g., agent.gd)
func set_command_orbit(target: Spatial, distance: float, clockwise: bool):
	if (
		_current_command.get("type") == CommandType.ORBIT
		and _current_command.get("target_node") == target
		and is_equal_approx(_current_command.get("distance"), distance)
		and _current_command.get("clockwise") == clockwise
	):
		return

	if not is_instance_valid(target):
		printerr("NavigationSystem: Invalid target node for ORBIT.")
		set_command_stopping()
		return

	#print(distance)

	_current_command = {
		"type": CommandType.ORBIT,
		"target_node": target,
		"distance": distance,  # Uses the distance passed in
		"clockwise": clockwise
	}
	if is_instance_valid(_orbit_pid):
		_orbit_pid.reset()
	if is_instance_valid(_approach_pid):
		_approach_pid.reset()
	if is_instance_valid(_move_to_pid):
		_move_to_pid.reset()


func set_command_flee(target: Spatial):
	if not is_instance_valid(target):
		printerr("NavigationSystem: Invalid target node for FLEE.")
		set_command_stopping()
		return
	_current_command = {"type": CommandType.FLEE, "target_node": target}
	if is_instance_valid(_orbit_pid):
		_orbit_pid.reset()
	if is_instance_valid(_approach_pid):
		_approach_pid.reset()
	if is_instance_valid(_move_to_pid):
		_move_to_pid.reset()


func set_command_align_to(direction: Vector3):
	if direction.length_squared() < 0.001:
		printerr("NavigationSystem: Invalid direction vector for ALIGN_TO.")
		set_command_idle()
		return
	_current_command = {"type": CommandType.ALIGN_TO, "target_dir": direction.normalized()}
	if is_instance_valid(_orbit_pid):
		_orbit_pid.reset()
	if is_instance_valid(_approach_pid):
		_approach_pid.reset()
	if is_instance_valid(_move_to_pid):
		_move_to_pid.reset()


# --- Main Update Logic (Called by AgentBody._physics_process before move_and_slide) ---
func update_navigation(delta: float):
	# Check basic validity early
	if not is_instance_valid(agent_body) or not is_instance_valid(movement_system):
		return

	var cmd_type = _current_command.get("type", CommandType.IDLE)
	var target_node = _current_command.get("target_node", null)

	# --- Target Validity Check ---
	var is_target_cmd = cmd_type in [CommandType.APPROACH, CommandType.ORBIT, CommandType.FLEE]
	if is_target_cmd and not is_instance_valid(target_node):
		printerr(
			(
				"NavigationSystem: Target node for command %s became invalid."
				% CommandType.keys()[cmd_type]
			)
		)
		set_command_stopping()
		cmd_type = CommandType.STOPPING

	# --- Command Execution Logic ---
	match cmd_type:
		CommandType.IDLE:
			movement_system.apply_deceleration(delta)

		CommandType.STOPPING:
			var stopped = movement_system.apply_braking(delta)
			if stopped and not _current_command.get("signaled_stop", false):
				EventBus.emit_signal("agent_reached_destination", agent_body)
				_current_command["signaled_stop"] = true

		CommandType.MOVE_TO:
			if not is_instance_valid(_move_to_pid):
				printerr("NavigationSystem Error: MOVE_TO requires a valid _move_to_pid instance.")
				set_command_stopping()
				return

			var target_pos = _current_command.target_pos
			var vector_to_target = target_pos - agent_body.global_transform.origin
			var distance = vector_to_target.length()
			var distance_error = distance
			var pid_target_speed = _move_to_pid.update(distance_error, delta)
			pid_target_speed = clamp(pid_target_speed, 0, movement_system.max_move_speed)

			var direction = Vector3.ZERO
			if distance > 0.01:
				direction = vector_to_target.normalized()

			movement_system.apply_rotation(direction, delta)

			var target_velocity = direction * pid_target_speed
			agent_body.current_velocity = agent_body.current_velocity.linear_interpolate(
				target_velocity, movement_system.acceleration * delta
			)

			if (
				distance < ARRIVAL_DISTANCE_THRESHOLD
				and agent_body.current_velocity.length_squared() < ARRIVAL_SPEED_THRESHOLD_SQ
			):
				if not _current_command.get("signaled_stop", false):
					#print("Agent ", agent_body.name, " reached move_to destination.")
					EventBus.emit_signal("agent_reached_destination", agent_body)
					_current_command["signaled_stop"] = true
				movement_system.apply_braking(delta)
			else:
				_current_command["signaled_stop"] = false

		CommandType.MOVE_DIRECTION:
			var move_dir = _current_command.get("target_dir", Vector3.ZERO)
			if move_dir.length_squared() > 0.001:
				movement_system.apply_rotation(move_dir, delta)
				movement_system.apply_acceleration(move_dir, delta)
			else:
				movement_system.apply_deceleration(delta)

		CommandType.APPROACH:
			if not is_instance_valid(_approach_pid):
				printerr(
					"NavigationSystem Error: APPROACH requires a valid _approach_pid instance."
				)
				set_command_stopping()
				return

			var target_pos = target_node.global_transform.origin
			var target_size = _get_target_effective_size(target_node)  # Returns radius now
			# desired_stop_dist is distance from center
			var desired_stop_dist = max(
				APPROACH_MIN_DISTANCE, target_size * APPROACH_DISTANCE_MULTIPLIER
			)
			var deceleration_start_distance = (
				desired_stop_dist
				* APPROACH_DECELERATION_START_DISTANCE_FACTOR
			)
			var vector_to_target = target_pos - agent_body.global_transform.origin
			var distance = vector_to_target.length()

			# Early Exit Check
			if distance < (desired_stop_dist + ARRIVAL_DISTANCE_THRESHOLD):
				if not _current_command.get("signaled_stop", false):
					#print(
					#	"Agent ", agent_body.name, " is within approach range. Switching to IDLE."
					#)
					EventBus.emit_signal("agent_reached_destination", agent_body)
					_current_command["signaled_stop"] = true
				set_command_idle()
				movement_system.apply_braking(delta)
				return

			var direction = Vector3.ZERO
			if distance > 0.01:
				direction = vector_to_target.normalized()

			movement_system.apply_rotation(direction, delta)

			var target_velocity: Vector3
			if distance > deceleration_start_distance:
				# Far from target
				target_velocity = direction * movement_system.max_move_speed
				if is_instance_valid(_approach_pid):
					_approach_pid.reset()
				agent_body.current_velocity = agent_body.current_velocity.linear_interpolate(
					target_velocity, movement_system.acceleration * delta
				)
				_current_command["signaled_stop"] = false
			else:
				# Close to target (PID zone)
				var distance_error = distance - desired_stop_dist
				var pid_target_speed = 0.0
				if is_instance_valid(_approach_pid):
					pid_target_speed = _approach_pid.update(distance_error, delta)

				pid_target_speed = clamp(
					pid_target_speed,
					-movement_system.max_move_speed * 0.1,
					movement_system.max_move_speed
				)

				target_velocity = direction * pid_target_speed
				agent_body.current_velocity = agent_body.current_velocity.linear_interpolate(
					target_velocity, movement_system.acceleration * delta
				)

				# Completion Check (only in PID zone)
				var final_distance_error = distance - desired_stop_dist
				if (
					abs(final_distance_error) < ARRIVAL_DISTANCE_THRESHOLD
					and agent_body.current_velocity.length_squared() < ARRIVAL_SPEED_THRESHOLD_SQ
				):
					if not _current_command.get("signaled_stop", false):
						#print("Agent ", agent_body.name, " reached approach destination.")
						EventBus.emit_signal("agent_reached_destination", agent_body)
						_current_command["signaled_stop"] = true
					movement_system.apply_braking(delta)
				else:
					_current_command["signaled_stop"] = false

		CommandType.ORBIT:
			if not is_instance_valid(_orbit_pid):
				printerr("NavigationSystem Error: ORBIT requires a valid _orbit_pid instance.")
				set_command_stopping()
				return

			var target_pos = target_node.global_transform.origin
			var orbit_dist = _current_command.get("distance", 100.0)  # The desired/captured distance
			var clockwise = _current_command.get("clockwise", false)

			var vector_to_target = target_pos - agent_body.global_transform.origin
			var distance = vector_to_target.length()  # Current distance
			if distance < 0.01:
				distance = 0.01
			var direction_to_target = vector_to_target / distance

			# Determine tangent direction
			var target_up = Vector3.UP
			var tangent_dir: Vector3
			var cross_fallback_axis = agent_body.global_transform.basis.x
			var cross_product = (
				direction_to_target.cross(target_up)
				if not clockwise
				else target_up.cross(direction_to_target)
			)
			if cross_product.length_squared() < 0.01:
				cross_product = (
					direction_to_target.cross(cross_fallback_axis)
					if not clockwise
					else cross_fallback_axis.cross(direction_to_target)
				)
			tangent_dir = cross_product.normalized()

			# Apply rotation towards the tangent direction
			movement_system.apply_rotation(tangent_dir, delta)

			# Calculate Target Tangential Speed based on desired orbit_dist
			var target_tangential_speed = 0.0
			var full_speed_radius = max(1.0, Constants.ORBIT_FULL_SPEED_RADIUS)
			if orbit_dist <= 0:
				target_tangential_speed = 0.0
			elif orbit_dist < full_speed_radius:
				target_tangential_speed = (
					movement_system.max_move_speed
					* (orbit_dist / full_speed_radius)
				)
			else:
				target_tangential_speed = movement_system.max_move_speed

			target_tangential_speed = clamp(
				target_tangential_speed, 0.0, movement_system.max_move_speed
			)

			# Interpolate velocity towards tangential target velocity
			var target_velocity = tangent_dir * target_tangential_speed
			agent_body.current_velocity = agent_body.current_velocity.linear_interpolate(
				target_velocity, movement_system.acceleration * delta
			)
			# PID correction for distance is applied separately

		CommandType.FLEE:
			var target_pos = target_node.global_transform.origin
			var vector_away = agent_body.global_transform.origin - target_pos
			var direction_away = Vector3.ZERO
			if vector_away.length_squared() > 0.01:
				direction_away = vector_away.normalized()
			else:
				direction_away = (
					-agent_body.global_transform.basis.z
					if agent_body.global_transform.basis.z.length_squared() > 0.01
					else Vector3.FORWARD
				)
			movement_system.apply_rotation(direction_away, delta)
			movement_system.apply_acceleration(direction_away, delta)

		CommandType.ALIGN_TO:
			var target_dir = _current_command.target_dir
			movement_system.apply_rotation(target_dir, delta)
			movement_system.apply_deceleration(delta)
			var current_fwd = -agent_body.global_transform.basis.z
			if current_fwd.dot(target_dir) > 0.999:
				set_command_idle()


# --- PID Correction Logic (Called by AgentBody._physics_process AFTER move_and_slide) ---
func apply_orbit_pid_correction(delta: float):
	# Only apply ORBIT PID correction here
	if _current_command.get("type") != CommandType.ORBIT:
		return
	# Check validity again
	if not is_instance_valid(agent_body) or not is_instance_valid(movement_system):
		return
	# Ensure the PID controller specifically needed is valid
	if not is_instance_valid(_orbit_pid):
		return

	var target_node = _current_command.get("target_node", null)
	if is_instance_valid(target_node):
		var desired_orbit_dist = _current_command.get("distance", 100.0)
		var target_pos = target_node.global_transform.origin
		var current_pos = agent_body.global_transform.origin
		var vector_to_target = target_pos - current_pos
		var current_distance = vector_to_target.length()

		if current_distance < 0.01:
			return  # Avoid division by zero

		# Error is how far we are from the desired orbit distance
		var distance_error = current_distance - desired_orbit_dist

		#print(desired_orbit_dist, " ", current_distance)

		var pid_output = _orbit_pid.update(distance_error, delta)

		# Dampen outward push for intentionally close orbits
		var close_orbit_threshold = APPROACH_MIN_DISTANCE * CLOSE_ORBIT_DISTANCE_THRESHOLD_FACTOR
		if distance_error < 0 and desired_orbit_dist < close_orbit_threshold:
			var max_outward_push_speed = movement_system.max_move_speed * 0.05
			pid_output = max(pid_output, -max_outward_push_speed)

		# Calculate the radial direction (points from agent towards target)
		var radial_direction = vector_to_target.normalized()

		# Apply correction velocity based on PID output
		var velocity_correction = radial_direction * pid_output

		# Apply the correction directly to the velocity
		agent_body.current_velocity += velocity_correction


# --- Helper Functions ---
# Calculates the effective radius of the target for interaction distances.
func _get_target_effective_size(target_node: Spatial) -> float:
	var calculated_size = 1.0  # Represents radius
	var default_radius = 10.0  # Fallback radius if nothing else works
	var found_source = "Default"  # Track where the size came from for debugging

	if not is_instance_valid(target_node):
		return default_radius

	# --- Priority 1: Explicit Interaction Radius Method ---
	if target_node.has_method("get_interaction_radius"):
		var explicit_radius = target_node.get_interaction_radius()
		if (explicit_radius is float or explicit_radius is int) and explicit_radius > 0:
			calculated_size = float(explicit_radius)  # Ensure it's a float
			found_source = "Method(get_interaction_radius)"
			# print("DEBUG Size Source: ", found_source, " | Value: ", calculated_size)
			return max(calculated_size, 1.0)  # Return early if found

	# --- Priority 2: Combined AABB of Visual Children under "Model" ---
	var model_node = target_node.get_node_or_null("Model")
	if is_instance_valid(model_node) and model_node is Spatial:
		var combined_aabb: AABB = AABB()  # Start with an empty AABB
		var first_visual_found = false

		# Iterate through all children of the "Model" node
		for child in model_node.get_children():
			if child is VisualInstance:  # Check if the child is renderable
				# Get the AABB in WORLD space
				var child_global_aabb = child.get_transformed_aabb()

				if not first_visual_found:
					# Initialize the combined AABB with the first visual child's AABB
					combined_aabb = child_global_aabb
					first_visual_found = true
				else:
					# Merge the current child's AABB with the combined AABB
					combined_aabb = combined_aabb.merge(child_global_aabb)

		# If we found at least one visual child and calculated a combined AABB
		if first_visual_found:
			# Calculate size based on the longest axis of the combined AABB
			var longest_axis_size = combined_aabb.get_longest_axis_size()
			# Divide by 2 to get the effective radius from the center
			calculated_size = longest_axis_size / 2.0
			if calculated_size > 0.01:
				found_source = "Combined Model AABB Radius"
				# print("DEBUG Size Source: ", found_source, " | Value: ", calculated_size)
				return max(calculated_size, 1.0)  # Return early if valid size found

	# --- Priority 3: Fallback to Target Node's Own Scale (if no method or valid Model AABB) ---
	var node_scale = target_node.global_transform.basis.get_scale()
	# Use the largest scale component as a rough radius estimate
	calculated_size = max(node_scale.x, max(node_scale.y, node_scale.z)) / 2.0  # Divide by 2 for radius
	if calculated_size <= 0.01:  # Check for zero or negative scale
		calculated_size = 1.0  # Use minimum radius if scale is invalid
	found_source = "Target Node Scale Radius"
	# print("DEBUG Size Source: ", found_source, " | Value: ", calculated_size)
	# Don't return early here, let final fallback check happen

	# --- Final Fallback: Default Radius ---
	if calculated_size < 1.0:  # If scale was tiny or zero
		calculated_size = default_radius
		found_source = "Default Fallback Radius"
		# print("DEBUG Size Source: ", found_source, " | Value: ", calculated_size)

	# Ensure radius is at least 1.0 before returning
	return max(calculated_size, 1.0)

--- Start of ./core/systems/asset_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/character_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/chronicle_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/event_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/goal_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/progression_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/traffic_system_placeholder.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/world_map_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/ui/CenteredGrowingLabel.gd ---

# File: res://ui_elements/CenteredGrowingLabel.gd (or your preferred path)

# class_name ClassName, path/to/icon.svg
class_name CenteredGrowingLabel, "res://assets/art/ui/class_labels/class_centered_growing_label.svg"
extends Label

# --- Static Group Name ---
const AUTO_GROUP_NAME = "centered_growing_labels"

# --- Internal ---
var _is_ready_for_recenter = false

func _enter_tree():
	if not is_in_group(AUTO_GROUP_NAME):
		add_to_group(AUTO_GROUP_NAME)
	if not is_connected("resized", self, "_on_self_resized"):
		connect("resized", self, "_on_self_resized")
	call_deferred("_initial_setup_and_recenter")

func _initial_setup_and_recenter():
	_is_ready_for_recenter = true
	_recenter_in_parent()
	self.focus_mode = Control.FOCUS_NONE

func _exit_tree():
	if is_in_group(AUTO_GROUP_NAME):
		remove_from_group(AUTO_GROUP_NAME)
	if is_connected("resized", self, "_on_self_resized"):
		disconnect("resized", self, "_on_self_resized")

func _on_self_resized():
	_recenter_in_parent()

func _recenter_in_parent():
	if not _is_ready_for_recenter:
		return
	var parent_control = get_parent_control()
	if parent_control:
		var current_label_size = self.rect_size
		var parent_size = parent_control.rect_size
		var new_pos_x = (parent_size.x - current_label_size.x) / 2.0
		var new_pos_y = (parent_size.y - current_label_size.y) / 2.0
		if not is_equal_approx(rect_position.x, new_pos_x) or \
		   not is_equal_approx(rect_position.y, new_pos_y):
			self.rect_position = Vector2(new_pos_x, new_pos_y)

func get_parent_control() -> Control:
	var p = get_parent()
	if p is Control:
		return p
	return null

--- Start of ./core/ui/main_hud.gd ---

# File: res://core/ui/main_hud.gd
# Script for the main HUD container. Handles displaying targeting info, etc.
# Version: 1.1 - Fixed targeting indicator visibility restoration

extends Control

# --- Nodes ---
onready var targeting_indicator: Control = $TargetingIndicator

# --- State ---
var _current_target: Spatial = null
var _main_camera: Camera = null


# --- Initialization ---
func _ready():
	GlobalRefs.set_main_hud(self)

	# Ensure indicator starts hidden
	targeting_indicator.visible = false

	# Get camera reference once
	_main_camera = get_viewport().get_camera()  # Initial attempt
	if not is_instance_valid(_main_camera) and is_instance_valid(GlobalRefs.main_camera):
		_main_camera = GlobalRefs.main_camera  # Fallback via GlobalRefs

	if not is_instance_valid(_main_camera):
		printerr("MainHUD Error: Could not get a valid camera reference!")
		set_process(false)  # Disable processing if no camera

	# Connect to EventBus signals
	if EventBus:
		if not EventBus.is_connected("player_target_selected", self, "_on_Player_Target_Selected"):
			EventBus.connect("player_target_selected", self, "_on_Player_Target_Selected")
		if not EventBus.is_connected(
			"player_target_deselected", self, "_on_Player_Target_Deselected"
		):
			EventBus.connect("player_target_deselected", self, "_on_Player_Target_Deselected")
	else:
		printerr("MainHUD Error: EventBus not available!")

	# Connect draw signal for custom drawing (optional, but good for style)
	targeting_indicator.connect("draw", self, "_draw_targeting_indicator")


# --- Process Update ---
func _process(delta):
	# Only update position if a target is selected and valid
	if is_instance_valid(_current_target) and is_instance_valid(_main_camera):
		# Project the target's 3D origin position to 2D screen coordinates
		var screen_pos: Vector2 = _main_camera.unproject_position(
			_current_target.global_transform.origin
		)

		# Check if the target is behind the camera
		var target_dir = (_current_target.global_transform.origin - _main_camera.global_transform.origin).normalized()
		var camera_fwd = -_main_camera.global_transform.basis.z.normalized()
		var is_in_front = target_dir.dot(camera_fwd) >= 0  # Use >= 0 to include exactly perpendicular

		# --- MODIFIED Visibility Logic ---
		# Set visibility based on whether the target is in front
		targeting_indicator.visible = is_in_front

		# Only update position and redraw if it's actually visible
		if targeting_indicator.visible:
			# Update the indicator's position
			targeting_indicator.rect_position = screen_pos - (targeting_indicator.rect_size / 2.0)
			targeting_indicator.update()  # Trigger redraw if using _draw
	else:
		# Ensure indicator is hidden if target becomes invalid or camera is invalid
		if targeting_indicator.visible:
			targeting_indicator.visible = false


# --- Signal Handlers ---
func _on_Player_Target_Selected(target_node: Spatial):
	print(target_node)
	if is_instance_valid(target_node):
		_current_target = target_node
		# Visibility is now primarily handled in _process,
		# but we still need to ensure _process runs.
		# targeting_indicator.visible = true # This line can be removed or kept, _process will override
		set_process(true)  # Ensure _process runs
	else:
		_on_Player_Target_Deselected()


func _on_Player_Target_Deselected():
	_current_target = null
	targeting_indicator.visible = false
	set_process(false)  # Can disable processing if target is deselected


# --- Custom Drawing (Optional but Recommended) ---
func _draw_targeting_indicator():
	# Example: Draw a simple white rectangle outline
	var rect = Rect2(Vector2.ZERO, targeting_indicator.rect_size)
	var line_color = Color.white
	var line_width = 1.0  # Adjust thickness as needed
	#targeting_indicator.draw_rect(rect, line_color, false, line_width)

	# Example: Draw simple corner brackets
	var size = targeting_indicator.rect_size
	var corner_len = size.x * 0.25  # Length of corner lines
	var color = Color.cyan
	var width = 2.0
	# # Top-left
	targeting_indicator.draw_line(Vector2(0, 0), Vector2(corner_len, 0), color, width)
	targeting_indicator.draw_line(Vector2(0, 0), Vector2(0, corner_len), color, width)
	# # Top-right
	targeting_indicator.draw_line(Vector2(size.x, 0), Vector2(size.x - corner_len, 0), color, width)
	targeting_indicator.draw_line(Vector2(size.x, 0), Vector2(size.x, corner_len), color, width)
	# # Bottom-left
	targeting_indicator.draw_line(Vector2(0, size.y), Vector2(corner_len, size.y), color, width)
	targeting_indicator.draw_line(Vector2(0, size.y), Vector2(0, size.y - corner_len), color, width)
	# # Bottom-right
	targeting_indicator.draw_line(
		Vector2(size.x, size.y), Vector2(size.x - corner_len, size.y), color, width
	)
	targeting_indicator.draw_line(
		Vector2(size.x, size.y), Vector2(size.x, size.y - corner_len), color, width
	)


# --- Cleanup ---
func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		if EventBus:
			if EventBus.is_connected("player_target_selected", self, "_on_Player_Target_Selected"):
				EventBus.disconnect("player_target_selected", self, "_on_Player_Target_Selected")
			if EventBus.is_connected(
				"player_target_deselected", self, "_on_Player_Target_Deselected"
			):
				EventBus.disconnect(
					"player_target_deselected", self, "_on_Player_Target_Deselected"
				)


func _on_ButtonFreeFlight_pressed():
	if EventBus:
		EventBus.emit_signal("player_free_flight_toggled")


func _on_ButtonStop_pressed():
	if EventBus:
		EventBus.emit_signal("player_stop_pressed")


func _on_ButtonOrbit_pressed():
	if EventBus:
		EventBus.emit_signal("player_orbit_pressed")


func _on_ButtonApproach_pressed():
	if EventBus:
		EventBus.emit_signal("player_approach_pressed")


func _on_ButtonFlee_pressed():
	if EventBus:
		EventBus.emit_signal("player_flee_pressed")


func _on_SliderControlLeft_value_changed(value):
	# ZOOM camera slider
	if EventBus:
		EventBus.emit_signal("player_camera_zoom_changed", value)


func _on_SliderControlRight_value_changed(value):
	# SPEED (maximum) limiter.
	# This slider is inverted (rotated by 180) for the sake of appearance.
	if EventBus:
		EventBus.emit_signal("player_ship_speed_changed", value)

--- Start of ./core/utils/editor_object.gd ---

extends MeshInstance

func _ready():
	self.hide()

--- Start of ./core/utils/pid_controller.gd ---

# File: core/utils/pid_controller.gd
# Version: 1.0
# Purpose: A reusable PID controller class.

extends Node  # Or use 'extends Reference' if node features aren't needed
class_name PIDController

# --- Gains ---
var kp: float = 1.0 setget set_kp
var ki: float = 0.0 setget set_ki
var kd: float = 0.0 setget set_kd

# --- Limits ---
var integral_limit: float = 1000.0 setget set_integral_limit
var output_limit: float = 50.0 setget set_output_limit

# --- State ---
var integral: float = 0.0
var previous_error: float = 0.0


# --- Initialization ---
func initialize(
	p_gain: float, i_gain: float, d_gain: float, i_limit: float = 1000.0, o_limit: float = 50.0
):
	kp = p_gain
	ki = i_gain
	kd = d_gain
	integral_limit = abs(i_limit)  # Ensure positive limit
	output_limit = abs(o_limit)  # Ensure positive limit
	reset()  # Start with a clean state


# --- Update ---
# Calculates the PID output based on the current error and delta time.
# Returns the clamped PID output value.
func update(error: float, delta: float) -> float:
	if delta <= 0.0001:
		# Avoid division by zero or instability with tiny delta
		return 0.0

	# --- Proportional Term ---
	var p_term = kp * error

	# --- Integral Term ---
	integral += error * delta
	# Clamp integral to prevent windup
	integral = clamp(integral, -integral_limit, integral_limit)
	var i_term = ki * integral

	# --- Derivative Term ---
	var derivative = (error - previous_error) / delta
	var d_term = kd * derivative

	# --- Update State for Next Iteration ---
	previous_error = error

	# --- Calculate & Clamp Output ---
	var output = p_term + i_term + d_term
	output = clamp(output, -output_limit, output_limit)

	return output


# --- Reset ---
# Resets the integral and previous error state.
func reset():
	integral = 0.0
	previous_error = 0.0


# --- Setters (Optional, for runtime tweaking if needed) ---
func set_kp(value: float):
	kp = value


func set_ki(value: float):
	ki = value


func set_kd(value: float):
	kd = value


func set_integral_limit(value: float):
	integral_limit = abs(value)


func set_output_limit(value: float):
	output_limit = abs(value)

--- Start of ./core/utils/rotating_object.gd ---

extends MeshInstance

export var rotation_speed = 0.01

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _physics_process(delta):
	self.rotate(Vector3(0,1,0), delta * rotation_speed)

--- Start of ./modules/piloting/scripts/player_controller_ship.gd ---

# File: modules/piloting/scripts/player_controller_ship.gd
# Version 3.8 - Speed control refactored for keyboard and slider synchronization.
extends Node

# --- References ---
var agent_script: Node = null  # Parent AgentBody (KinematicBody with agent.gd)
var agent_body: KinematicBody = null  # Same as agent_script in this context
var movement_system: Node = null  # Agent's MovementSystem component
var _main_camera: Camera = null
var _speed_slider: Slider = null

# --- Speed Control Values ---
var template_min_speed_actual: float = 0.0  # Ship's absolute minimum speed capability
var template_max_speed_actual: float = 300.0  # Ship's absolute maximum speed capability (from template)
var current_target_speed_normalized: float = 1.0  # Player's desired speed percentage (0.0 to 1.0)
const KEY_SPEED_INCREMENT_NORMALIZED: float = 0.05  # 5% change per key press

# --- State ---
var _target_under_cursor: Spatial = null
var _selected_target: Spatial = null setget _set_selected_target
var _is_free_flight_mode: bool = false
var _is_programmatically_setting_slider: bool = false

# --- Input Tracking State ---
var _lmb_pressed: bool = false
var _lmb_press_pos: Vector2 = Vector2.ZERO
var _lmb_press_time: int = 0
var _is_dragging: bool = false
var _last_tap_time: int = 0

# --- Constants ---
const DEFAULT_MOVE_TO_PROJECTION_DIST = 1e6
const DRAG_THRESHOLD_PX_SQ = 10 * 10
const DOUBLE_CLICK_TIME_MS = 400


func _ready():
	var parent = get_parent()
	if parent is KinematicBody and parent.has_method("command_stop"):
		agent_body = parent
		agent_script = parent  # agent.gd is on AgentBody

		# Attempt to get MovementSystem. Agent.gd should make this accessible.
		if agent_script.has_node("MovementSystem"):
			movement_system = agent_script.get_node("MovementSystem")

		if (
			not is_instance_valid(movement_system)
			or not movement_system.has_method("initialize_movement_params")
		):
			printerr(
				"PlayerController Error: Valid MovementSystem not found on agent: ",
				agent_script.name
			)
			set_physics_process(false)
			set_process_input(false)
			return

		print("Player Controller ready for: ", agent_script.agent_name)
		call_deferred("_deferred_ready_setup")
		Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
	else:
		printerr("Player Controller Error: Parent invalid or missing command methods!")
		set_physics_process(false)
		set_process_input(false)
		return


func _deferred_ready_setup():
	# Ensure GlobalRefs and HUD are ready
	if not is_instance_valid(GlobalRefs.main_hud):
		yield(GlobalRefs, "main_hud_ready")  # Assuming GlobalRefs could emit such a signal if needed
		if not is_instance_valid(GlobalRefs.main_hud):  # Check again
			printerr("PlayerController Error: Main HUD not available in GlobalRefs after wait.")
			return

	_speed_slider = GlobalRefs.main_hud.get_node_or_null(
		"ScreenControls/CenterRightZone/SliderControlRight"
	)
	if not is_instance_valid(_speed_slider):
		printerr("PlayerController Error: Speed slider not found in MainHUD.")
		# Potentially disable speed control features or log error further

	# Initialize speed capabilities from the agent's movement system
	# This assumes movement_system.max_move_speed holds the ship's template max speed at this point.
	template_max_speed_actual = movement_system.max_move_speed
	template_min_speed_actual = 0.0  # Or a game-defined minimum if ships don't fully stop

	current_target_speed_normalized = 1.0  # Start at 100% speed
	_update_agent_speed_cap_and_slider_visuals()

	# Connect to EventBus signals
	if EventBus:
		if not EventBus.is_connected(
			"player_free_flight_toggled", self, "_on_Player_Free_Flight_Toggled"
		):
			EventBus.connect("player_free_flight_toggled", self, "_on_Player_Free_Flight_Toggled")
		if not EventBus.is_connected("player_stop_pressed", self, "_on_Player_Stop_Pressed"):
			EventBus.connect("player_stop_pressed", self, "_on_Player_Stop_Pressed")
		if not EventBus.is_connected("player_orbit_pressed", self, "_on_Player_Orbit_Pressed"):
			EventBus.connect("player_orbit_pressed", self, "_on_Player_Orbit_Pressed")
		if not EventBus.is_connected(
			"player_approach_pressed", self, "_on_Player_Approach_Pressed"
		):
			EventBus.connect("player_approach_pressed", self, "_on_Player_Approach_Pressed")
		if not EventBus.is_connected("player_flee_pressed", self, "_on_Player_Flee_Pressed"):
			EventBus.connect("player_flee_pressed", self, "_on_Player_Flee_Pressed")
		# This connection is for when the SLIDER's value is changed by the user via main_hud.gd
		if not EventBus.is_connected(
			"player_ship_speed_changed", self, "_on_Player_Ship_Speed_Slider_Changed_By_HUD"
		):
			EventBus.connect(
				"player_ship_speed_changed", self, "_on_Player_Ship_Speed_Slider_Changed_By_HUD"
			)
	else:
		printerr("PlayerController Error: EventBus not available for signal connections.")

	call_deferred("_get_camera_reference")


func _get_camera_reference():
	yield(get_tree(), "idle_frame")  # Wait for scene tree to be fully ready
	if is_instance_valid(GlobalRefs.main_camera) and GlobalRefs.main_camera is Camera:
		_main_camera = GlobalRefs.main_camera
		print("Player Controller obtained camera reference.")
	else:
		printerr("Player Controller Error: Could not find valid Main Camera in GlobalRefs.")


func _physics_process(delta):
	if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE:
		_update_target_under_cursor()
	else:
		_target_under_cursor = null

	if _is_free_flight_mode:
		if is_instance_valid(_main_camera) and is_instance_valid(agent_script):
			var move_dir = -_main_camera.global_transform.basis.z.normalized()
			agent_script.command_move_direction(move_dir)
		elif is_instance_valid(agent_script):
			agent_script.command_stop()


func _update_target_under_cursor():
	_target_under_cursor = null
	if not is_instance_valid(agent_body):
		return
	var camera = get_viewport().get_camera()
	if not is_instance_valid(camera):
		return

	var mouse_pos = get_viewport().get_mouse_position()
	var ray_origin = camera.project_ray_origin(mouse_pos)
	var ray_normal = camera.project_ray_normal(mouse_pos)
	var ray_end = ray_origin + ray_normal * Constants.TARGETING_RAY_LENGTH

	var space_state = agent_body.get_world().direct_space_state
	var result = space_state.intersect_ray(ray_origin, ray_end, [agent_body], 1)

	if result and result.collider is Spatial:
		_target_under_cursor = result.collider


func _set_selected_target(new_target: Spatial):
	if _selected_target == new_target:
		return

	_selected_target = new_target
	if EventBus:
		if is_instance_valid(_selected_target):
			EventBus.emit_signal("player_target_selected", _selected_target)
			print("Player selected target: ", _selected_target.name)
		else:
			EventBus.emit_signal("player_target_deselected")
			print("Player de-selected target.")


func deselect_current_target():
	if is_instance_valid(_selected_target):
		self._selected_target = null


func _unhandled_input(event):
	var input_handled = false

	if Input.is_action_just_pressed("toggle_free_flight"):
		_toggle_free_flight_mode()
		input_handled = true

	if event is InputEventMouseButton and event.button_index == BUTTON_LEFT:
		if event.pressed:
			_lmb_pressed = true
			_is_dragging = false
			_lmb_press_pos = event.position
			_lmb_press_time = OS.get_ticks_msec()
		else:  # Released
			if _lmb_pressed:
				_lmb_pressed = false
				var time_now = OS.get_ticks_msec()
				if _is_dragging:
					if (
						is_instance_valid(_main_camera)
						and _main_camera.has_method("set_is_rotating")
					):
						_main_camera.set_is_rotating(false)
					input_handled = true
				else:  # Tap/Click
					if time_now - _last_tap_time <= DOUBLE_CLICK_TIME_MS:
						_handle_double_click(event.position)
						_last_tap_time = 0  # Reset double click timer
					else:
						_handle_single_click(event.position)
						_last_tap_time = time_now
					input_handled = true
				_is_dragging = false

	elif event is InputEventMouseMotion and _lmb_pressed and not _is_dragging:
		if event.position.distance_squared_to(_lmb_press_pos) > DRAG_THRESHOLD_PX_SQ:
			_is_dragging = true
			_last_tap_time = 0  # Cancel potential double click
			if not _is_free_flight_mode:
				if is_instance_valid(_main_camera) and _main_camera.has_method("set_is_rotating"):
					_main_camera.set_is_rotating(true)

	# Keyboard commands (not consumed by mouse/touch release)
	if not input_handled:
		if not _is_free_flight_mode and is_instance_valid(agent_script):
			var command_action_key = ""
			if Input.is_action_just_pressed("command_approach"):
				command_action_key = "approach"
			elif Input.is_action_just_pressed("command_orbit"):
				command_action_key = "orbit"
			elif Input.is_action_just_pressed("command_flee"):
				command_action_key = "flee"

			if command_action_key != "":
				input_handled = true
				if is_instance_valid(_selected_target):
					match command_action_key:
						"approach":
							agent_script.command_approach(_selected_target)
						"orbit":
							agent_script.command_orbit(_selected_target)
						"flee":
							agent_script.command_flee(_selected_target)
					print(
						"Command Input: ", command_action_key.to_upper(), " ", _selected_target.name
					)
				else:
					print("Command Input: ", command_action_key, " failed - no target.")
					input_handled = false  # Don't consume if command failed

		# Speed adjustment keys (work in both modes)
		if Input.is_action_pressed("command_speed_up"):  # Use is_action_pressed for holding down
			current_target_speed_normalized = clamp(
				(
					current_target_speed_normalized
					+ KEY_SPEED_INCREMENT_NORMALIZED * event.get_action_strength("command_speed_up")
				),
				0.0,
				1.0
			)
			_update_agent_speed_cap_and_slider_visuals()
			input_handled = true
		elif Input.is_action_pressed("command_speed_down"):
			current_target_speed_normalized = clamp(
				(
					current_target_speed_normalized
					- (
						KEY_SPEED_INCREMENT_NORMALIZED
						* event.get_action_strength("command_speed_down")
					)
				),
				0.0,
				1.0
			)
			_update_agent_speed_cap_and_slider_visuals()
			input_handled = true

		if Input.is_action_just_pressed("command_stop"):
			_issue_stop_command()
			input_handled = true

	if input_handled:
		get_viewport().set_input_as_handled()


func _handle_single_click(click_pos: Vector2):
	if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE:
		var target = _raycast_for_target(click_pos)
		self._selected_target = target


# --- Helper Raycast Function ---
func _raycast_for_target(screen_pos: Vector2) -> Spatial:
	if not is_instance_valid(agent_body):
		return null
	var camera = get_viewport().get_camera()
	if not is_instance_valid(camera):
		return null
	var ray_origin = camera.project_ray_origin(screen_pos)
	var ray_normal = camera.project_ray_normal(screen_pos)
	var ray_end = ray_origin + ray_normal * Constants.TARGETING_RAY_LENGTH
	var space_state = agent_body.get_world().direct_space_state
	var result = space_state.intersect_ray(ray_origin, ray_end, [agent_body], 1)
	if result and result.collider is Spatial:
		return result.collider
	else:
		return null


func _handle_double_click(click_pos: Vector2):
	if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE:
		if is_instance_valid(agent_script) and is_instance_valid(_main_camera):
			var ray_origin = _main_camera.project_ray_origin(click_pos)
			var ray_normal = _main_camera.project_ray_normal(click_pos)
			var target_point = ray_origin + ray_normal * DEFAULT_MOVE_TO_PROJECTION_DIST
			print("Input: Double-Click Move To ", target_point)
			agent_script.command_move_to(target_point)


# --- Signal Handlers for UI Button Presses via EventBus ---
func _on_Player_Free_Flight_Toggled():
	_toggle_free_flight_mode()


func _on_Player_Stop_Pressed():
	_issue_stop_command()


func _on_Player_Orbit_Pressed():
	if is_instance_valid(_selected_target) and is_instance_valid(agent_script):
		agent_script.command_orbit(_selected_target)
	else:
		print("PlayerController: Cannot Orbit - invalid target or agent.")


func _on_Player_Approach_Pressed():
	if is_instance_valid(_selected_target) and is_instance_valid(agent_script):
		agent_script.command_approach(_selected_target)
	else:
		print("PlayerController: Cannot Approach - invalid target or agent.")


func _on_Player_Flee_Pressed():
	if is_instance_valid(_selected_target) and is_instance_valid(agent_script):
		agent_script.command_flee(_selected_target)
	else:
		print("PlayerController: Cannot Flee - invalid target or agent.")


# --- Speed Control Logic ---
# Called when the MainHUD's speed slider is changed by the USER.
func _on_Player_Ship_Speed_Slider_Changed_By_HUD(slider_ui_value: float):
	if _is_programmatically_setting_slider:
		return  # Avoid loop if we set the slider from code

	# Slider value is 0-100, 0=max speed, 100=min speed (inverted UI)
	current_target_speed_normalized = (100.0 - slider_ui_value) / 100.0
	current_target_speed_normalized = clamp(current_target_speed_normalized, 0.0, 1.0)
	_update_agent_speed_cap_and_slider_visuals()  # Update agent and ensure slider reflects clamped value


# Central function to update agent's speed cap and the UI slider's visual state
func _update_agent_speed_cap_and_slider_visuals():
	if not is_instance_valid(movement_system):
		printerr("PlayerController: MovementSystem invalid, cannot update speed.")
		return

	# 1. Calculate the new actual speed cap for the movement system
	var new_actual_speed_cap = lerp(
		template_min_speed_actual, template_max_speed_actual, current_target_speed_normalized
	)
	movement_system.max_move_speed = new_actual_speed_cap
	# print("Player Speed Cap set to: ", movement_system.max_move_speed, " (Normalized: ", current_target_speed_normalized, ")")

	# 2. Update the UI Slider's visual position
	if is_instance_valid(_speed_slider):
		_is_programmatically_setting_slider = true
		var slider_display_value = current_target_speed_normalized * 100.0
		# The slider is inverted (0 means full speed, 100 means min speed)
		_speed_slider.value = 100.0 - clamp(slider_display_value, 0.0, 100.0)
		_is_programmatically_setting_slider = false
	# else:
	# print("PlayerController: Speed slider instance is not valid for UI update.")


func _issue_stop_command():
	if not is_instance_valid(agent_script):
		printerr("PlayerController Error: AgentScript invalid, cannot issue stop command.")
		return

	print("Command Input: STOP")
	agent_script.command_stop()

	if _is_free_flight_mode:
		_exit_free_flight_mode_common()  # Common exit logic


func _toggle_free_flight_mode():
	_is_free_flight_mode = not _is_free_flight_mode
	print("Toggling Free Flight Mode to: ", "ON" if _is_free_flight_mode else "OFF")

	if _is_free_flight_mode:  # Entering Free Flight
		Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)
		if is_instance_valid(_main_camera) and _main_camera.has_method("set_rotation_input_active"):
			_main_camera.set_rotation_input_active(true)
		_is_dragging = false
		if is_instance_valid(_main_camera) and _main_camera.has_method("set_is_rotating"):
			_main_camera.set_is_rotating(false)  # Ensure external drag rotation is off
	else:  # Exiting Free Flight (not via stop command, but by toggle)
		_exit_free_flight_mode_common()
		if is_instance_valid(agent_script):  # Issue stop if exiting via toggle
			agent_script.command_stop()


func _exit_free_flight_mode_common():
	_is_free_flight_mode = false  # Ensure state is OFF
	Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
	if is_instance_valid(_main_camera):
		if _main_camera.has_method("set_rotation_input_active"):
			_main_camera.set_rotation_input_active(false)
		if _main_camera.has_method("set_is_rotating"):
			_main_camera.set_is_rotating(false)
	_lmb_pressed = false
	_is_dragging = false


func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		if EventBus:
			if EventBus.is_connected(
				"player_free_flight_toggled", self, "_on_Player_Free_Flight_Toggled"
			):
				EventBus.disconnect(
					"player_free_flight_toggled", self, "_on_Player_Free_Flight_Toggled"
				)
			if EventBus.is_connected("player_stop_pressed", self, "_on_Player_Stop_Pressed"):
				EventBus.disconnect("player_stop_pressed", self, "_on_Player_Stop_Pressed")
			if EventBus.is_connected("player_orbit_pressed", self, "_on_Player_Orbit_Pressed"):
				EventBus.disconnect("player_orbit_pressed", self, "_on_Player_Orbit_Pressed")
			if EventBus.is_connected(
				"player_approach_pressed", self, "_on_Player_Approach_Pressed"
			):
				EventBus.disconnect("player_approach_pressed", self, "_on_Player_Approach_Pressed")
			if EventBus.is_connected("player_flee_pressed", self, "_on_Player_Flee_Pressed"):
				EventBus.disconnect("player_flee_pressed", self, "_on_Player_Flee_Pressed")
			if EventBus.is_connected(
				"player_ship_speed_changed", self, "_on_Player_Ship_Speed_Slider_Changed_By_HUD"
			):
				EventBus.disconnect(
					"player_ship_speed_changed", self, "_on_Player_Ship_Speed_Slider_Changed_By_HUD"
				)

--- Start of ./modules/piloting/scripts/ship_controller_ai.gd ---

# File: modules/piloting/scripts/ship_controller_ai.gd
# Attach to Node child of AgentBody in npc_agent.tscn
# Version 2.1 - Simplified for agent command execution model

extends Node

# --- References ---
# Set in _ready()
var agent_script: Node = null  # Reference to the parent agent.gd script instance


# --- Initialization ---
func _ready():
	# Get reference to parent agent script
	var parent = get_parent()
	# Check if parent is the correct type and has the command methods
	if parent is KinematicBody and parent.has_method("command_move_to"):
		agent_script = parent
		# print("AI Controller ready for: ", agent_script.agent_name) # Optional Debug
	else:
		printerr(
			"AI Controller Error: Parent node is not an Agent KinematicBody with command methods!"
		)
		# If setup fails, this controller can't function.
		# We can disable physics process (though it's empty now)
		# or even detach the script to prevent errors.
		set_physics_process(false)
		set_script(null)  # Detach script if parent is wrong


# Called by WorldManager's spawn_agent function (via initialize dictionary in agent.gd)
# The 'config' dictionary here is the 'overrides' passed to spawn_agent
func initialize(config: Dictionary):
	# Ensure agent script reference is valid before issuing command
	if not is_instance_valid(agent_script):
		printerr("AI Initialize Error: Agent script invalid. Cannot issue command.")
		return

	# Read necessary parameters from config dictionary if present
	var stopping_dist = config.get("stopping_distance", 10.0)  # May not be needed by AI now
	# TODO: Agent's MOVE_TO command should probably use its own internal stopping distance logic

	# Immediately issue the initial command based on 'initial_target' in config
	if config.has("initial_target") and config.initial_target is Vector3:
		var target_pos = config.initial_target
		print(agent_script.agent_name, " AI issuing command: MOVE_TO ", target_pos)
		# Call the command method on the agent script
		agent_script.command_move_to(target_pos)
	else:
		# If no target, the agent remains IDLE (its default state)
		if is_instance_valid(agent_script):  # Check again just in case
			print(
				"AI Controller Warning: No initial target provided for ",
				agent_script.agent_name,
				". Agent will remain idle."
			)

# --- No Physics Update Needed ---
# For this simple "go-to" AI, the agent itself executes the command issued
# during initialize. This controller doesn't need to do anything frame-by-frame.
# More complex AI would have state machines here, checking conditions and
# issuing different commands (approach, orbit, flee, etc.) as needed.
# func _physics_process(delta):
#     pass

# --- No Event Handling Needed Here ---
# The agent itself now emits "agent_reached_destination" via EventBus
# when its relevant command (MOVE_TO -> STOPPING -> IDLE) completes.
# WorldManager listens for that signal to trigger the despawn.
# func _handle_target_reached(): # Removed
# func _on_Agent_Reached_Destination(agent_body): # Removed

# --- No Public Functions Needed Here ---
# func set_target(new_target: Vector3): # Removed - command issued once at init

--- Start of ./scenes/camera/camera_particles_controller.gd ---

# File: res://scenes/camera/camera_particles_controller.gd
# Purpose: Controls the space dust (CPUParticles) effect attached to the camera,
#          adjusting emission, velocity, and emitter position based on
#          the CAMERA's movement speed. (GLES2 Compatible)
extends CPUParticles  # Use CPUParticles for GLES2

# --- Tunable Parameters ---
# Camera speed threshold below which particles stop emitting strongly
export var min_camera_speed_threshold: float = 0.5
# Camera speed at which the effect reaches maximum intensity
export var max_camera_speed_for_effect: float = 50.0
# --- NEW: How much to shift emitter opposite to velocity vector ---
export var velocity_offset_scale: float = -250.0

# --- Node References ---
var _camera: Camera = null

# --- State ---
var _previous_camera_pos: Vector3 = Vector3.ZERO
var _initialized: bool = false


func _ready():
	# Get camera reference (assuming this node is a direct child of the camera)
	_camera = get_parent() as Camera
	if not _camera:
		printerr("CameraParticlesController Error: Parent node is not a Camera!")
		set_process(false)
		return

	# Set initial state directly on the node
	self.emitting = false
	self.gravity = Vector3.ZERO
	self.transform.origin = Vector3.ZERO  # Ensure offset starts at zero

	# Defer setting previous position until the first process frame
	# to ensure the camera has its initial position set.
	call_deferred("_initialize_position")


func _initialize_position():
	if is_instance_valid(_camera):
		_previous_camera_pos = _camera.global_transform.origin
		_initialized = true
		#print("CameraParticlesController Initialized.")
	else:
		printerr("CameraParticlesController Error: Camera invalid during deferred init.")
		set_process(false)


func _process(delta: float):
	# Ensure camera is valid and initialized
	if not _initialized or not is_instance_valid(_camera):
		# Keep particles off if camera isn't ready
		if self.emitting:
			self.emitting = false
		if self.gravity != Vector3.ZERO:
			self.gravity = Vector3.ZERO
		# Reset offset if camera becomes invalid
		if self.transform.origin != Vector3.ZERO:
			self.transform.origin = Vector3.ZERO
		return

	# --- Calculate Camera Movement ---
	var current_pos: Vector3 = _camera.global_transform.origin
	# Vector representing the camera's displacement over the last frame in global space
	var position_delta_global: Vector3 = current_pos - _previous_camera_pos
	var camera_speed: float = 0.0

	if delta > 0.0001:  # Avoid division by zero or large spikes on first frame/lag
		camera_speed = position_delta_global.length() / delta

	# Store current position for the next frame's calculation
	_previous_camera_pos = current_pos

	# --- Apply Velocity Offset ---
	# Calculate the desired offset in the opposite direction of the global movement.
	# Since this script/node is a child of the camera, we need to transform the global
	# offset direction into the camera's local space before applying it.
	var global_offset_vector = -position_delta_global * velocity_offset_scale
	# Transform the global offset vector into the camera's local coordinate system
	var local_offset_vector = _camera.global_transform.basis.xform_inv(global_offset_vector)

	# Set the local position offset of this CPUParticles node
	self.transform.origin = local_offset_vector

	# --- Control Emission (based on speed) ---
	if camera_speed > min_camera_speed_threshold:
		if not self.emitting:
			self.emitting = true
	else:
		if self.emitting:
			self.emitting = false

--- Start of ./scenes/camera/orbit_camera.gd ---

# File: scenes/camera/orbit_camera.gd
# Version 1.31 - camera zoom UI slider connected

extends Camera

# --- Configuration ---
var distance: float = 55.0
var min_distance_multiplier: float = 3.0
var max_distance_multiplier: float = 30.0
var preferred_distance_multiplier: float = min_distance_multiplier
const MIN_ABSOLUTE_DISTANCE = 1.0
const MAX_ABSOLUTE_DISTANCE = 500.0
var zoom_speed: float = 0.5

# var rotation_speed: float = 0.004 # REMOVED - Replaced by PID logic
var pitch_min: float = -1.45
var pitch_max: float = 1.45
var position_smoothing_speed: float = 18.0
var rotation_smoothing_speed: float = 18.0  # Now affects how fast camera *looks at* target
var bob_frequency: float = 0.1
var bob_amplitude: float = 0.2

# --- FoV Configuration ---
var _min_fov_deg: float = 70.0
var _max_fov_deg: float = 90.0

# --- Rotation PID Config --- (Tunable - Initial guesses)
# Higher Kp = Faster reaction to input changes
# Higher Ki = Reduces steady-state error (but can cause overshoot/oscillation)
# Higher Kd = Dampens overshoot/oscillation
# --- TUNABLE PARAMETERS START ---
var pid_yaw_kp: float = 10  # Was _rotation_acceleration
var pid_yaw_ki: float = 0.01
var pid_yaw_kd: float = 0.1  # Related to old _rotation_damping conceptually
var pid_pitch_kp: float = 10  # Was _rotation_acceleration
var pid_pitch_ki: float = 0.01
var pid_pitch_kd: float = 0.1  # Related to old _rotation_damping conceptually
var pid_integral_limit: float = 10.0  # Limit integral windup
var pid_output_limit_multiplier: float = 100  # Allow PID to demand slightly > max speed temporarily
# --- TUNABLE PARAMETERS END ---

# --- Rotation Base Config --- (Set via initialize or defaults)
var _rotation_max_speed: float = 15  # Max angular speed (radians/frame? check usage) -> Should be radians/sec
var _rotation_input_curve: float = 1.1  # Power curve for mouse input

# --- Internal State ---
var _target: Spatial = null
var _target_radius: float = 15.0
var _yaw: float = PI
var _pitch: float = 0.25
var _current_distance: float = 55.0
var _rotation_input_active: bool = false  # Free flight flag
var _is_externally_rotating: bool = false  # LMB/Touch drag flag
var _bob_timer: float = 0.0
var _is_programmatically_setting_slider: bool = false  # Flag to prevent signal loops

# --- Rotation PID State ---
var _target_yaw_speed: float = 0.0
var _target_pitch_speed: float = 0.0
var _current_yaw_speed: float = 0.0
var _current_pitch_speed: float = 0.0

# --- PID Controller Instances ---
var _yaw_pid: PIDController = null
var _pitch_pid: PIDController = null
const PIDControllerScript = preload("res://core/utils/pid_controller.gd")


# --- Initialization ---
func _ready():
	_current_distance = distance
	_yaw = PI
	_pitch = 0.25
	set_as_toplevel(true)
	GlobalRefs.main_camera = self

	# --- Connect signals ---
	# Connect to EventBus signals
	if EventBus:
		if not EventBus.is_connected(
			"player_camera_zoom_changed", self, "_on_Player_Camera_Zoom_Changed"
		):
			var err = EventBus.connect(
				"player_camera_zoom_changed", self, "_on_Player_Camera_Zoom_Changed"
			)
			if err != OK:
				printerr(
					"OrbitCamera Error: Failed connect player_camera_zoom_changed signal! Code: ",
					err
				)

	else:
		printerr("OrbitCamera Error: EventBus not available!")

	# --- Instantiate and Initialize PID Controllers ---
	if PIDControllerScript:
		_yaw_pid = PIDControllerScript.new()
		_pitch_pid = PIDControllerScript.new()

		# Calculate output limit based on max speed
		# PID output represents acceleration, limit it reasonably
		var output_limit = _rotation_max_speed * pid_output_limit_multiplier  # Allow some overshoot potential if needed

		if is_instance_valid(_yaw_pid):
			_yaw_pid.initialize(
				pid_yaw_kp, pid_yaw_ki, pid_yaw_kd, pid_integral_limit, output_limit
			)
			print(
				(
					"Camera Yaw PID Initialized (Kp=%.2f, Ki=%.2f, Kd=%.2f, OLimit=%.2f)"
					% [pid_yaw_kp, pid_yaw_ki, pid_yaw_kd, output_limit]
				)
			)
		else:
			printerr("Camera Error: Failed to instance Yaw PIDController.")

		if is_instance_valid(_pitch_pid):
			_pitch_pid.initialize(
				pid_pitch_kp, pid_pitch_ki, pid_pitch_kd, pid_integral_limit, output_limit
			)
			print(
				(
					"Camera Pitch PID Initialized (Kp=%.2f, Ki=%.2f, Kd=%.2f, OLimit=%.2f)"
					% [pid_pitch_kp, pid_pitch_ki, pid_pitch_kd, output_limit]
				)
			)
		else:
			printerr("Camera Error: Failed to instance Pitch PIDController.")
	else:
		printerr(
			"Camera Error: Failed to preload PIDController script! Rotation smoothing disabled."
		)
		set_physics_process(false)  # Disable if PIDs can't be created

	# Connect signals... (same as before)
	if EventBus:
		if not EventBus.is_connected(
			"camera_set_target_requested", self, "_on_Camera_Set_Target_Requested"
		):
			var err = EventBus.connect(
				"camera_set_target_requested", self, "_on_Camera_Set_Target_Requested"
			)
			if err != OK:
				printerr("Camera Error: Failed connect signal! Code: ", err)
	else:
		printerr("Camera Error: EventBus not available!")

	# Proactive player check... (same as before)
	if not is_instance_valid(_target):
		if is_instance_valid(GlobalRefs.player_agent_body):
			set_target_node(GlobalRefs.player_agent_body)
	_update_fov()


func initialize(config: Dictionary):
	# Initialize standard config... (same as before)
	if config.has("distance"):
		self.distance = config.distance
	if config.has("min_distance_multiplier"):
		self.min_distance_multiplier = config.min_distance_multiplier
	if config.has("max_distance_multiplier"):
		self.max_distance_multiplier = config.max_distance_multiplier
	if config.has("preferred_distance_multiplier"):
		self.preferred_distance_multiplier = config.preferred_distance_multiplier
	if config.has("zoom_speed"):
		self.zoom_speed = config.zoom_speed
	if config.has("pitch_min"):
		self.pitch_min = config.pitch_min
	if config.has("pitch_max"):
		self.pitch_max = config.pitch_max
	if config.has("position_smoothing_speed"):
		self.position_smoothing_speed = config.position_smoothing_speed
	if config.has("rotation_smoothing_speed"):
		self.rotation_smoothing_speed = config.rotation_smoothing_speed
	if config.has("bob_frequency"):
		self.bob_frequency = config.bob_frequency
	if config.has("bob_amplitude"):
		self.bob_amplitude = config.bob_amplitude

	# Initialize FoV limits... (same as before)
	if config.has("min_fov_deg"):
		self._min_fov_deg = config.min_fov_deg
	if config.has("max_fov_deg"):
		self._max_fov_deg = config.max_fov_deg

	# --- Initialize Rotation Base Config from config ---
	if config.has("rotation_max_speed"):
		self._rotation_max_speed = config.rotation_max_speed
	if config.has("rotation_input_curve"):
		self._rotation_input_curve = config.rotation_input_curve

	# --- Initialize PID Tunables from config ---
	if config.has("pid_yaw_kp"):
		self.pid_yaw_kp = config.pid_yaw_kp
	if config.has("pid_yaw_ki"):
		self.pid_yaw_ki = config.pid_yaw_ki
	if config.has("pid_yaw_kd"):
		self.pid_yaw_kd = config.pid_yaw_kd
	if config.has("pid_pitch_kp"):
		self.pid_pitch_kp = config.pid_pitch_kp
	if config.has("pid_pitch_ki"):
		self.pid_pitch_ki = config.pid_pitch_ki
	if config.has("pid_pitch_kd"):
		self.pid_pitch_kd = config.pid_pitch_kd
	if config.has("pid_integral_limit"):
		self.pid_integral_limit = config.pid_integral_limit
	if config.has("pid_output_limit_multiplier"):
		self.pid_output_limit_multiplier = config.pid_output_limit_multiplier

	# --- Re-Initialize PIDs if they exist and params changed ---
	if is_instance_valid(_yaw_pid) and is_instance_valid(_pitch_pid):
		var output_limit = _rotation_max_speed * pid_output_limit_multiplier
		_yaw_pid.initialize(pid_yaw_kp, pid_yaw_ki, pid_yaw_kd, pid_integral_limit, output_limit)
		_pitch_pid.initialize(
			pid_pitch_kp, pid_pitch_ki, pid_pitch_kd, pid_integral_limit, output_limit
		)
		print("Camera PIDs Re-initialized from config.")

	self._yaw = deg2rad(config.get("initial_yaw_deg", 180.0))
	self._pitch = clamp(deg2rad(config.get("initial_pitch_deg", 15.0)), pitch_min, pitch_max)
	_current_distance = self.distance

	print("OrbitCamera initialized via config.")


# --- Input Handling ---
func _unhandled_input(event):
	# Rotation Input (Mouse Motion) - Sets TARGET speed
	if event is InputEventMouseMotion:
		if _rotation_input_active or _is_externally_rotating:
			# Calculate input strength (normalize relative motion magnitude if needed)
			# Using event.relative directly, scaled by max_speed later.
			var input_x = event.relative.x
			var input_y = event.relative.y

			# Apply power curve for non-linear response
			# Sign must be preserved
			var strength_x = pow(abs(input_x), _rotation_input_curve) * sign(input_x)
			var strength_y = pow(abs(input_y), _rotation_input_curve) * sign(input_y)

			# Set target speed based on direction and scaled strength
			# Normalize/Scale the input strength. How much mouse movement corresponds to max speed?
			# Let's assume a certain pixel movement (e.g., 50px?) corresponds to reaching max speed.
			var input_scale_factor = 0.01  # TUNABLE: Adjust this based on feel. Lower = more sensitive.
			_target_yaw_speed = -strength_x * input_scale_factor * _rotation_max_speed
			_target_pitch_speed = -strength_y * input_scale_factor * _rotation_max_speed

			# Clamp target speed to max speed (important!)
			_target_yaw_speed = clamp(_target_yaw_speed, -_rotation_max_speed, _rotation_max_speed)
			_target_pitch_speed = clamp(
				_target_pitch_speed, -_rotation_max_speed, _rotation_max_speed
			)

			# Consume the event
			get_viewport().set_input_as_handled()
		#else: # Reset target speed if mouse moves but rotation is not active? Or let physics handle damping?
		#	_target_yaw_speed = 0.0
		#	_target_pitch_speed = 0.0
		# Let physics handle damping back to 0 if input stops or mode changes.

	elif event is InputEventMouseButton and is_instance_valid(_target):
		# var dyn_min_dist = _get_dynamic_min_distance() # Already calculated in _set_and_update_zoom_distance
		# var dyn_max_dist = _get_dynamic_max_distance() # Already calculated in _set_and_update_zoom_distance
		var zoom_factor = 1.0 + (zoom_speed * 0.1)  # zoom_speed should be a class variable
		var input_handled = false
		var new_distance_candidate = _current_distance

		if event.button_index == BUTTON_WHEEL_UP and event.pressed:
			new_distance_candidate = _current_distance / zoom_factor
			input_handled = true
		elif event.button_index == BUTTON_WHEEL_DOWN and event.pressed:
			new_distance_candidate = _current_distance * zoom_factor
			input_handled = true

		if input_handled:
			_set_and_update_zoom_distance(new_distance_candidate, false)
			get_viewport().set_input_as_handled()


# --- Signal handling ---
# From UI slider
func _on_Player_Camera_Zoom_Changed(value):
	if _is_programmatically_setting_slider:  # If we set the slider from code, don't react to its signal
		return

	var dyn_min_dist = _get_dynamic_min_distance()
	var dyn_max_dist = _get_dynamic_max_distance()
	var target_distance = lerp(dyn_min_dist, dyn_max_dist, value / 100)

	_set_and_update_zoom_distance(target_distance, true)


# --- Physics Update ---
func _physics_process(delta):
	_bob_timer += delta

	# --- Update FoV --- (Unchanged)
	if is_instance_valid(_target):
		_update_fov()

	# --- PID Rotation Update ---
	# Check if PIDs are valid
	if not is_instance_valid(_yaw_pid) or not is_instance_valid(_pitch_pid):
		# Fallback or error state if PIDs failed
		if delta > 0:
			printerr("Camera physics update skipped: PIDs invalid.")
		# Could implement simple non-PID rotation here as fallback if desired
	else:
		var rot_active = _rotation_input_active or _is_externally_rotating

		# If rotation isn't active, force target speed to 0
		if not rot_active:
			_target_yaw_speed = 0.0
			_target_pitch_speed = 0.0

		# Calculate Error (Setpoint - Process Variable)
		var error_yaw = _target_yaw_speed - _current_yaw_speed
		var error_pitch = _target_pitch_speed - _current_pitch_speed

		# Update PIDs to get acceleration adjustment
		var yaw_accel = _yaw_pid.update(error_yaw, delta)
		var pitch_accel = _pitch_pid.update(error_pitch, delta)

		# Apply acceleration to current speed
		_current_yaw_speed += yaw_accel * delta
		_current_pitch_speed += pitch_accel * delta

		# --- Sanity check/clamp speed if PID overshoots significantly (optional) ---
		# _current_yaw_speed = clamp(_current_yaw_speed, -_rotation_max_speed * 1.1, _rotation_max_speed * 1.1)
		# _current_pitch_speed = clamp(_current_pitch_speed, -_rotation_max_speed * 1.1, _rotation_max_speed * 1.1)

		# Apply calculated rotation speeds to angles
		_yaw += _current_yaw_speed * delta
		_pitch -= _current_pitch_speed * delta  # MAINTAIN SIGN CONVENTION
		_pitch = clamp(_pitch, pitch_min, pitch_max)  # Keep pitch within limits

		# Reset target speed derived from momentary input for next frame
		# PID system naturally damps if input stops setting a target speed.
		_target_yaw_speed = 0.0
		_target_pitch_speed = 0.0
	# --- End PID Rotation Update ---

	# --- Update Position and LookAt --- (Unchanged from previous logic)
	if not is_instance_valid(_target):
		# Detached Mode (Apply only orientation calculated above)
		# Ensure _yaw and _pitch updates are still applied
		var new_basis = Basis().rotated(Vector3.UP, _yaw).rotated(
			Basis().rotated(Vector3.UP, _yaw).x, _pitch
		)
		# We don't slerp the basis anymore, we directly set it based on PID-controlled angles
		global_transform.basis = new_basis.orthonormalized()
		return

	# --- Attached Mode --- (Position + LookAt)
	var target_pos = _target.global_transform.origin
	var bob_offset = (
		global_transform.basis.y
		* sin(_bob_timer * bob_frequency * TAU)
		* bob_amplitude
	)

	# Calculate desired orientation first based on yaw/pitch
	var desired_basis = Basis().rotated(Vector3.UP, _yaw).rotated(
		Basis().rotated(Vector3.UP, _yaw).x, _pitch
	)

	# Calculate desired position based on orientation and distance
	var position_offset = -desired_basis.z * _current_distance
	var desired_position = target_pos + position_offset + bob_offset

	# Interpolate Position
	global_transform.origin = global_transform.origin.linear_interpolate(
		desired_position, position_smoothing_speed * delta
	)

	# Interpolate Look At (still smoothly look *at* the target even while manually rotating orientation)
	var target_look_transform = global_transform.looking_at(target_pos, Vector3.UP)
	global_transform.basis = global_transform.basis.slerp(
		target_look_transform.basis.orthonormalized(), rotation_smoothing_speed * delta
	)


# --- Dynamic FoV Update Logic --- (Unchanged)
func _update_fov():
	var dyn_min_dist = _get_dynamic_min_distance()
	var dyn_max_dist = _get_dynamic_max_distance()
	if is_equal_approx(dyn_max_dist, dyn_min_dist):
		self.fov = _max_fov_deg
		return
	var t = clamp((_current_distance - dyn_min_dist) / (dyn_max_dist - dyn_min_dist), 0.0, 1.0)
	self.fov = lerp(_min_fov_deg, _max_fov_deg, t)


# --- Helper functions for dynamic distances ---
func _set_and_update_zoom_distance(new_distance: float, from_slider_event: bool = false):
	#print(from_slider_event, " ", new_distance)
	var dyn_min_dist = _get_dynamic_min_distance()
	var dyn_max_dist = _get_dynamic_max_distance()
	var _zoom_slider = GlobalRefs.main_hud.get_node(
		"ScreenControls/CenterLeftZone/SliderControlLeft"
	)

	# 1. Clamp and set the internal _current_distance
	_current_distance = clamp(new_distance, dyn_min_dist, dyn_max_dist)

	# 2. If the change didn't come from the slider itself, update the slider's visual position
	if not from_slider_event and is_instance_valid(_zoom_slider):
		if abs(dyn_max_dist - dyn_min_dist) > 0.001:  # Avoid division by zero if range is tiny
			var normalized_value = (
				100
				* (_current_distance - dyn_min_dist)
				/ (dyn_max_dist - dyn_min_dist)
			)

			_is_programmatically_setting_slider = true  # Set flag before changing slider value
			_zoom_slider.value = clamp(normalized_value, 0.0, 100.0)  # Ensure slider value is 0-100
			_is_programmatically_setting_slider = false  # Reset flag
		elif _current_distance <= dyn_min_dist:  # Handle edge case where range is effectively zero
			_is_programmatically_setting_slider = true
			_zoom_slider.value = 0.0
			_is_programmatically_setting_slider = false
		else:  # _current_distance >= dyn_max_dist
			_is_programmatically_setting_slider = true
			_zoom_slider.value = 100.0
			_is_programmatically_setting_slider = false


func _get_dynamic_min_distance() -> float:
	if not is_instance_valid(_target):
		return MIN_ABSOLUTE_DISTANCE
	_target_radius = _get_target_effective_radius(_target)
	return max(MIN_ABSOLUTE_DISTANCE, _target_radius * min_distance_multiplier)


func _get_dynamic_max_distance() -> float:
	if not is_instance_valid(_target):
		return MAX_ABSOLUTE_DISTANCE
	var dyn_min_dist = _get_dynamic_min_distance()
	var dyn_max_calc = max(dyn_min_dist + 1.0, _target_radius * max_distance_multiplier)
	return min(MAX_ABSOLUTE_DISTANCE, dyn_max_calc)


# --- Signal Handler & Public Functions --- (External control functions unchanged)
func _on_Camera_Set_Target_Requested(target_node):
	set_target_node(target_node)


func set_rotation_input_active(is_active: bool):
	_rotation_input_active = is_active
	if is_active:
		_is_externally_rotating = false
	# Reset PID controllers when state changes? Optional, depends on desired feel.
	# if is_instance_valid(_yaw_pid): _yaw_pid.reset()
	# if is_instance_valid(_pitch_pid): _pitch_pid.reset()


func set_is_rotating(rotating: bool):
	# Only allow external rotation if free flight rotation is not active
	if not _rotation_input_active:
		_is_externally_rotating = rotating
	# Reset PIDs when starting/stopping drag?
	# if is_instance_valid(_yaw_pid): _yaw_pid.reset()
	# if is_instance_valid(_pitch_pid): _pitch_pid.reset()


# --- set_target_node, _get_target_effective_radius, get_current_target, _notification ---
# (Unchanged from v1.26/previous version)
func set_target_node(new_target: Spatial):
	var target_changed = false
	if is_instance_valid(new_target):
		if _target != new_target:
			_target = new_target
			_target_radius = _get_target_effective_radius(_target)
			print("OrbitCamera target set to: ", new_target.name, " | Eff Radius: ", _target_radius)
			var dyn_min_dist = _get_dynamic_min_distance()
			var dyn_max_dist = _get_dynamic_max_distance()
			var preferred_dist = max(dyn_min_dist, _target_radius * preferred_distance_multiplier)
			_current_distance = clamp(preferred_dist, dyn_min_dist, dyn_max_dist)
			print("  Reset distance to: ", _current_distance)
			target_changed = true
			# Reset PIDs on target change for stability
			if is_instance_valid(_yaw_pid):
				_yaw_pid.reset()
			if is_instance_valid(_pitch_pid):
				_pitch_pid.reset()
			_current_yaw_speed = 0.0
			_current_pitch_speed = 0.0
	else:
		if _target != null:
			print("OrbitCamera target cleared.")
			target_changed = true
		_target = null
		_target_radius = 10.0
		# Optionally reset PIDs when target is cleared too
		# if is_instance_valid(_yaw_pid): _yaw_pid.reset()
		# if is_instance_valid(_pitch_pid): _pitch_pid.reset()
		# _current_yaw_speed = 0.0
		# _current_pitch_speed = 0.0
	if target_changed:
		_update_fov()


func _get_target_effective_radius(target_node: Spatial) -> float:
	var default_radius = 10.0
	if not is_instance_valid(target_node):
		return default_radius
	# Use the agent's method if available (consistent with NavigationSystem)
	if target_node.has_method("get_interaction_radius"):
		var radius = target_node.get_interaction_radius()
		if (radius is float or radius is int) and radius > 0.0:
			return max(float(radius), 1.0)  # Ensure float and minimum size
	# Fallback (keep simple for camera, agent has more complex logic)
	var node_scale = target_node.global_transform.basis.get_scale()
	var max_scale = max(node_scale.x, max(node_scale.y, node_scale.z))
	return max(max_scale / 2.0, default_radius)  # Rough radius from scale, or default


func get_current_target() -> Spatial:
	if is_instance_valid(_target):
		return _target
	else:
		return null


func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		if (
			EventBus
			and EventBus.is_connected(
				"camera_set_target_requested", self, "_on_Camera_Set_Target_Requested"
			)
		):
			EventBus.disconnect(
				"camera_set_target_requested", self, "_on_Camera_Set_Target_Requested"
			)
		if GlobalRefs and GlobalRefs.main_camera == self:
			GlobalRefs.main_camera = null

--- Start of ./scenes/game_world/world_manager.gd ---

# File: scenes/game_world/world_manager.gd
# Version 2.3 - Code style cleanup (Tabs, Line Length, If/Else)

extends Node

# --- NodePaths ---
const ACTIVE_MODULE_CONTAINER_PATH = "../" + Constants.CURRENT_ZONE_CONTAINER_NAME

# --- State ---
var current_zone_instance: Node = null
var _spawned_agent_bodies = []
var _player_agent_body: KinematicBody = null


# --- Initialization ---
func _ready():
	GlobalRefs.world_manager = self
	if EventBus:
		var err1 = EventBus.connect(
			"agent_reached_destination", self, "_on_Agent_Reached_Destination"
		)
		var err2 = EventBus.connect("agent_despawning", self, "_on_Agent_Despawning")
		var err3 = EventBus.connect("zone_loaded", self, "_on_Zone_Loaded_WorldManager")
		if err1 != OK or err2 != OK or err3 != OK:
			printerr("WM _ready Error: Failed connect EventBus signals!")
	else:
		printerr("WM _ready Error: EventBus not available!")

	randomize()
	print("WM: 1/13 - _ready started.")
	print("WM _ready Debug: Checking Constant value...")
	print("- Constants.INITIAL_ZONE_SCENE_PATH = '", Constants.INITIAL_ZONE_SCENE_PATH, "'")
	print("- Type = ", typeof(Constants.INITIAL_ZONE_SCENE_PATH))

	print("WM: 2/13 - Attempting load_zone...")
	load_zone(Constants.INITIAL_ZONE_SCENE_PATH)
	print("WM: 9/13 - Returned from initial load_zone call.")
	print("WM: 10/13 - _ready finished (Player spawn handled by signal).")


# --- Zone Management ---
func load_zone(zone_scene_path: String):
	print("WM: 3/13 - load_zone starting for path: ", zone_scene_path)

	if not zone_scene_path or zone_scene_path.empty():
		printerr("WM Error: Invalid zone path provided.")
		return

	# 1. Cleanup Previous Zone
	if is_instance_valid(current_zone_instance):
		EventBus.emit_signal("zone_unloading", current_zone_instance)
		_spawned_agent_bodies.clear()
		_player_agent_body = null
		GlobalRefs.player_agent_body = null
		GlobalRefs.current_zone = null
		GlobalRefs.agent_container = null
		current_zone_instance.queue_free()
		current_zone_instance = null

	# 2. Find Parent Container Node
	var parent_node = get_parent()
	if not is_instance_valid(parent_node):
		printerr("WM Error: Could not get valid parent node!")
		return
	var zone_holder = parent_node.get_node_or_null(Constants.CURRENT_ZONE_CONTAINER_NAME)

	if not zone_holder:
		printerr(
			"WM Error: Node '",
			Constants.CURRENT_ZONE_CONTAINER_NAME,
			"' missing as child of parent '",
			parent_node.name,
			"'"
		)
		return
	print("WM: 4/13 - Found zone holder: ", zone_holder.name)

	# 3. Load and Instance the Zone Scene
	var zone_scene = load(zone_scene_path)
	if not zone_scene:
		printerr("WM Error: Failed load Zone Scene Resource: ", zone_scene_path)
		return

	current_zone_instance = zone_scene.instance()
	if not current_zone_instance:
		printerr("WM Error: Failed instance Zone Scene: ", zone_scene_path)
		return

	print("WM: 5/13 - Instanced Zone Scene: ", current_zone_instance.name)

	# 4. Add Zone to Tree & Update GlobalRefs for Zone
	zone_holder.add_child(current_zone_instance)
	GlobalRefs.current_zone = current_zone_instance

	# 5. Find Agent Container *within* the Zone & Update GlobalRef
	if not is_instance_valid(current_zone_instance):
		printerr("WM Error: current_zone_instance invalid after add_child?")
		return

	var agent_cont_ref = current_zone_instance.find_node(
		Constants.AGENT_CONTAINER_NAME, true, false
	)
	GlobalRefs.agent_container = agent_cont_ref
	print("WM: 6/13 - Found Agent Container: ", agent_cont_ref)
	if not agent_cont_ref:
		printerr(
			"WM Warning: Agent container '", Constants.AGENT_CONTAINER_NAME, "' not found in zone."
		)

	# 6. Emit Loaded Signal
	print("WM: 7/13 - Emitting zone_loaded signal.")
	EventBus.emit_signal(
		"zone_loaded", current_zone_instance, zone_scene_path, GlobalRefs.agent_container
	)
	print("WM: 8/13 - load_zone finished.")


# --- Agent Spawning & Management ---
# Called by handler for zone_loaded signal
func spawn_player():
	print("WM: 12/13 - spawn_player called.")
	var container = GlobalRefs.agent_container
	if not is_instance_valid(container):
		printerr("WM spawn_player Error: GlobalRefs.agent_container invalid.")
		return

	var player_template = load(Constants.PLAYER_DEFAULT_TEMPLATE_PATH)
	if not player_template is AgentTemplate:
		printerr("WM Error: Failed load Player AgentTemplate")
		return

	var player_spawn_pos = Vector3.ZERO
	var env_instance = GlobalRefs.current_zone
	if is_instance_valid(env_instance):
		var entry_node = null
		if Constants.ENTRY_POINT_NAMES.size() > 0:
			entry_node = env_instance.find_node(Constants.ENTRY_POINT_NAMES[0], true, false)
		if entry_node is Spatial:
			player_spawn_pos = entry_node.global_transform.origin + Vector3(0, 5, 15)

	var player_overrides = {"name": "PlayerShip", "faction": "Player"}
	_player_agent_body = spawn_agent(
		Constants.PLAYER_AGENT_SCENE_PATH, player_spawn_pos, player_template, player_overrides
	)

	if is_instance_valid(_player_agent_body):
		GlobalRefs.player_agent_body = _player_agent_body
		EventBus.emit_signal("camera_set_target_requested", _player_agent_body)
		EventBus.emit_signal("player_spawned", _player_agent_body)
	else:
		printerr("WorldManager Error: Failed to spawn player agent body!")
	print("WM: 13/13 - spawn_player finished.")


# Generic function CALLED BY EXTERNAL systems
func spawn_agent(
	agent_scene_path: String,
	position: Vector3,
	agent_template: Resource,
	overrides: Dictionary = {}
) -> KinematicBody:
	var container = GlobalRefs.agent_container
	if not is_instance_valid(container):
		printerr("WM Spawn Error: Invalid GlobalRefs.agent_container.")
		return null
	if not agent_template is AgentTemplate:
		printerr("WM Spawn Error: Invalid AgentTemplate Resource.")
		return null
	if not agent_scene_path or agent_scene_path.empty():
		printerr("WM Spawn Error: Invalid scene path.")
		return null

	var agent_scene = load(agent_scene_path)
	if not agent_scene:
		printerr("WM Spawn Error: Failed load agent scene: ", agent_scene_path)
		return null
	var agent_root_instance = agent_scene.instance()
	if not agent_root_instance:
		printerr("WM Spawn Error: Failed instance agent scene!")
		return null

	var agent_node = agent_root_instance.get_node_or_null(Constants.AGENT_BODY_NODE_NAME)
	if not agent_node or not agent_node is KinematicBody:
		var error_msg = str(
			"WM Spawn Error: Invalid node '",
			Constants.AGENT_BODY_NODE_NAME,
			"' in scene: ",
			agent_scene_path
		)
		printerr(error_msg)
		agent_root_instance.queue_free()
		return null

	var instance_name = overrides.get(
		"name", agent_template.default_agent_name + "_" + str(agent_root_instance.get_instance_id())
	)
	agent_root_instance.name = instance_name

	container.add_child(agent_root_instance)
	agent_node.global_transform.origin = position

	if agent_node.has_method("initialize"):
		agent_node.initialize(agent_template, overrides)

	_spawned_agent_bodies.append(agent_node)
	var name_to_print = instance_name
	# Expanded check using 'in' for property existence
	if "agent_name" in agent_node:
		name_to_print = agent_node.agent_name
	print("Spawned agent '", name_to_print, "' core node.")

	EventBus.emit_signal(
		"agent_spawned", agent_node, {"template": agent_template, "overrides": overrides}
	)

	var controller = agent_node.get_node_or_null(Constants.AI_CONTROLLER_NODE_NAME)
	if controller and controller.has_method("initialize"):
		controller.initialize(overrides)
	elif controller and controller.has_method("set_target") and ("initial_target" in overrides):
		controller.set_target(overrides.initial_target)

	return agent_node


# --- Signal Handlers ---
func _on_Agent_Reached_Destination(agent_body):
	if is_instance_valid(agent_body) and agent_body != _player_agent_body:
		if agent_body.has_method("despawn"):
			agent_body.despawn()
		else:
			agent_body.queue_free()  # Fallback
	elif is_instance_valid(agent_body) and agent_body == _player_agent_body:
		pass  # Player reached destination, do nothing here


func _on_Agent_Despawning(agent_body):
	call_deferred("_cleanup_despawned_agent_from_list", agent_body)


func _cleanup_despawned_agent_from_list(agent_instance):
	if _spawned_agent_bodies.has(agent_instance):
		_spawned_agent_bodies.erase(agent_instance)
	# Expanded check
	if _player_agent_body == agent_instance:
		print("Player agent reference cleared during cleanup.")
		_player_agent_body = null
		GlobalRefs.player_agent_body = null


func _on_Zone_Loaded_WorldManager(_zone_instance, _zone_path, agent_container_node):
	print("WM: 11/13 - Reacting to zone_loaded signal.")
	if is_instance_valid(agent_container_node):
		if not is_instance_valid(_player_agent_body):
			# Try direct call again now that other issues might be fixed
			spawn_player()
	else:
		printerr("WM _on_Zone_Loaded Error: Agent container invalid. Cannot spawn player.")


# --- Cleanup ---
func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		print("!!! WM: RECEIVED NOTIFICATION_PREDELETE !!!")
		if EventBus:
			# Expanded disconnect checks
			if EventBus.is_connected(
				"agent_reached_destination", self, "_on_Agent_Reached_Destination"
			):
				EventBus.disconnect(
					"agent_reached_destination", self, "_on_Agent_Reached_Destination"
				)
			if EventBus.is_connected("agent_despawning", self, "_on_Agent_Despawning"):
				EventBus.disconnect("agent_despawning", self, "_on_Agent_Despawning")
			if EventBus.is_connected("zone_loaded", self, "_on_Zone_Loaded_WorldManager"):
				EventBus.disconnect("zone_loaded", self, "_on_Zone_Loaded_WorldManager")
		# Expanded GlobalRefs check
		if GlobalRefs and GlobalRefs.world_manager == self:
			GlobalRefs.world_manager = null
		# Expanded instance check
		if is_instance_valid(current_zone_instance):
			current_zone_instance.queue_free()

--- Start of ./scenes/main_menu/SettingsRendering.gd ---

extends Control

var _viewport_size = Vector2(1920, 1080)

# Called when the node enters the scene tree for the first time.
func _ready():
	_viewport_size = get_viewport().size


# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

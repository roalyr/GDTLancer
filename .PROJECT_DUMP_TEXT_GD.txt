--- Start of ./autoload/Constants.gd ---

# File: autoload/Constants.gd
# Autoload Singleton: Constants
# Version: 1.3 - Reverted paths/names for Complete Zone Scene architecture

extends Node

# --- Scene Paths ---
const PLAYER_AGENT_SCENE_PATH = "res://core/agents/player_agent.tscn"
const NPC_AGENT_SCENE_PATH = "res://core/agents/npc_agent.tscn"

# Complete Zone Scene Paths (Self-contained environments with AgentContainer etc.)
const INITIAL_ZONE_SCENE_PATH = "res://scenes/zones/basic_flight_zone.tscn"
# Example future zones:
# const ZONE_ASTEROID_BELT_BETA_PATH = "res://scenes/zones/asteroid_belt_beta.tscn"
# const ZONE_SCRAPYARD_STATION_PATH = "res://scenes/zones/scrapyard_station.tscn"

# Agent Template Resource Paths
const PLAYER_DEFAULT_TEMPLATE_PATH = "res://assets/data/templates/agents/player_default.tres"
const NPC_TRAFFIC_TEMPLATE_PATH = "res://assets/data/templates/agents/npc_traffic.tres"

# Base UI Scenes
const MAIN_HUD_SCENE_PATH = "res://core/ui/main_hud.tscn"
const MAIN_MENU_SCENE_PATH = "res://scenes/main_menu/main_menu.tscn"

# --- Common Node Names ---
# Inside main_game_scene.tscn
const CURRENT_ZONE_CONTAINER_NAME = "CurrentZoneContainer"  # Node holding the loaded zone instance

# Inside Zone Scenes (e.g., basic_flight_zone.tscn)
const AGENT_CONTAINER_NAME = "AgentContainer"  # Child node for housing agents
const AGENT_MODEL_CONTAINER_NAME = "Model"
const ENTRY_POINT_NAMES = ["EntryPointA", "EntryPointB", "EntryPointC"]  # Expected Position3D/Spatial nodes

# Inside Agent Scenes (e.g., agent.tscn, npc_agent.tscn)
const AGENT_BODY_NODE_NAME = "AgentBody"  # The KinematicBody root in agent scenes
# MOVEMENT_COMPONENT_NAME removed as component was merged
const AI_CONTROLLER_NODE_NAME = "AIController"
const PLAYER_INPUT_HANDLER_NAME = "PlayerInputHandler"

# --- Core Mechanics Thresholds ---
const ACTION_CHECK_FAIL_THRESHOLD = 10
const ACTION_CHECK_SWC_THRESHOLD = 10
const ACTION_CHECK_CRIT_THRESHOLD = 14

# --- Core Mechanics Parameters ---
const FOCUS_MAX_DEFAULT = 3
const FOCUS_BOOST_PER_POINT = 1

# --- Default Simulation Values ---
const DEFAULT_MAX_MOVE_SPEED = 300.0  # m/s
const DEFAULT_ACCELERATION = 0.5  # NOT m/s^2
const DEFAULT_DECELERATION = 0.5  # NOT m/s^2
const DEFAULT_MAX_TURN_SPEED = 0.75

# --- Gameplay / Physics Approximations ---
const ORBIT_FULL_SPEED_RADIUS = 2000.0

# --- System Defaults (Examples - Used by placeholder systems) ---
const MAX_NPCS_DEFAULT = 10
const SPAWN_INTERVAL_DEFAULT = 2.0
const TRAFFIC_SPEED_MULT_DEFAULT = 0.2
const TARGETING_RAY_LENGTH = 1e7

--- Start of ./autoload/CoreMechanicsAPI.gd ---

# File: autoload/CoreMechanicsAPI.gd
# Autoload Singleton: CoreMechanicsAPI
# Purpose: Provides globally accessible functions for core mechanic resolutions,
#          ensuring consistency across the game.
# Version: 1.0

extends Node

# Random Number Generator for dice rolls
var _rng = RandomNumberGenerator.new()


func _ready():
	# Seed the random number generator once when the game starts
	_rng.randomize()
	print("CoreMechanicsAPI Ready.")


# --- Core Action Resolution ---


# Performs the standard 3d6+Mod Action Check based on passed parameters.
# Returns a Dictionary containing the detailed results of the check.
# - module_modifier: The calculated modifier for the current action context (Skill + Asset Diff).
# - focus_points_spent: How many FP the player chose to spend (0-3) *before* the roll.
# Return Dictionary keys:
#   "roll_total": int (Final result after mods/FP)
#   "dice_sum": int (Result of 3d6 only)
#   "modifier": int (Module modifier passed in)
#   "focus_spent": int (FP spent)
#   "focus_bonus": int (Bonus gained from FP)
#   "result_tier": String ("CritSuccess", "SwC", "Failure")
#   "focus_gain": int (FP gained from this result, usually 1 on Crit)
#   "focus_loss_reset": bool (True if FP should be reset to 0 due to Failure)
func perform_action_check(module_modifier: int, focus_points_spent: int) -> Dictionary:
	# Ensure focus spent is within valid range (0 to Max FP defined in Constants)
	focus_points_spent = clamp(focus_points_spent, 0, Constants.FOCUS_MAX_DEFAULT)

	# --- Roll Dice ---
	var d1 = _rng.randi_range(1, 6)
	var d2 = _rng.randi_range(1, 6)
	var d3 = _rng.randi_range(1, 6)
	var dice_sum = d1 + d2 + d3

	# --- Calculate Bonuses ---
	var focus_bonus = focus_points_spent * Constants.FOCUS_BOOST_PER_POINT

	# --- Calculate Final Roll ---
	var total_roll = dice_sum + module_modifier + focus_bonus

	# --- Determine Outcome Tier & Focus Effects ---
	var result_tier = ""
	var focus_gain = 0
	var focus_loss_reset = false

	if total_roll >= Constants.ACTION_CHECK_CRIT_THRESHOLD:
		result_tier = "CritSuccess"
		focus_gain = 1  # Standard gain on Crit
		focus_loss_reset = false
	elif total_roll >= Constants.ACTION_CHECK_SWC_THRESHOLD:  # e.g., 10-13
		result_tier = "SwC"  # Success with Complication
		focus_gain = 0
		focus_loss_reset = false
	else:  # e.g., < 10
		result_tier = "Failure"
		focus_gain = 0
		focus_loss_reset = true  # Standard reset on Failure

	# --- Assemble Results Dictionary ---
	var results = {
		"roll_total": total_roll,
		"dice_sum": dice_sum,
		"modifier": module_modifier,
		"focus_spent": focus_points_spent,
		"focus_bonus": focus_bonus,
		"result_tier": result_tier,
		"focus_gain": focus_gain,
		"focus_loss_reset": focus_loss_reset
	}

	# --- Optional: Emit Global Signal ---
	# If many systems need to react directly to *every* check result,
	# emitting a signal here could be useful later. Requires passing agent + approach.
	# EventBus.emit_signal("action_check_resolved", agent_ref, results, approach_ref)
	# For now, let the calling script handle reactions and FP updates.

	# print("Action Check: %d (3d6=%d, Mod=%d, FP=%d(+%d)) -> %s" % [total_roll, dice_sum, module_modifier, focus_points_spent, focus_bonus, result_tier]) # Debug

	return results

# --- Potential Future Core Mechanic Functions ---

# func update_focus_state(agent_stats_ref, focus_change: int):
#     # Central logic for applying focus gain/loss, respecting cap
#     pass

# func calculate_upkeep_cost(agent_assets_ref):
#     # Central logic for determining periodic WP upkeep cost
#     return 0 # Placeholder WP cost

# func advance_time_clock(agent_stats_ref_or_global, tu_amount: int):
#     # Central logic for adding TU and checking for World Event Tick trigger
#     pass

--- Start of ./autoload/EventBus.gd ---

# File: autoload/EventBus.gd
# Version: 1.1 Added target picking.

extends Node

# --- Game State Signals ---
signal game_loaded(save_data)
# signal game_saving(slot_id)
# signal save_complete(slot_id, success)

# --- Agent Lifecycle Signals ---
# Emitted by WorldManager after agent initialized and added to tree
# init_data parameter is now Dictionary {"template": Res, "overrides": Dict}
signal agent_spawned(agent_body, init_data)
# Emitted by Agent's despawn() method via EventBus BEFORE queue_free
signal agent_despawning(agent_body)
# Emitted by AI Controller via EventBus when destination reached
signal agent_reached_destination(agent_body)
# Emitted by WorldManager after player specifically spawned
signal player_spawned(player_agent_body)

# --- Camera Control Signals ---
# Emitted by systems requesting camera target change
signal camera_set_target_requested(target_node)
# Emitted by input handlers requesting target cycle (KEEPING for potential future use)
signal camera_cycle_target_requested

# --- Player Interaction Signals --- ADDED SECTION
signal player_target_selected(target_node)
signal player_target_deselected
signal player_free_flight_toggled
signal player_stop_pressed
signal player_orbit_pressed
signal player_approach_pressed
signal player_flee_pressed
signal player_camera_zoom_changed(value)
signal player_ship_speed_changed(value)

# --- Zone Loading Signals ---
# Emitted by WorldManager before unloading current zone instance
signal zone_unloading(zone_node)  # zone_node is the root of the scene being unloaded
# Emitted by WorldManager when starting to load a new zone path
signal zone_loading(zone_path)  # zone_path is path to the complete zone scene
# Emitted by WorldManager after new zone is instanced, added, container found
# zone_node is root of the new zone instance, agent_container_node is ref inside it
signal zone_loaded(zone_node, zone_path, agent_container_node)

# --- Core Mechanics / Gameplay Events (Placeholders) ---
# signal action_check_resolved(agent_body, result_dictionary, action_approach)
# signal focus_changed(agent_body, new_focus_value)
# signal wealth_changed(agent_body, new_wealth_value)
# signal world_event_tick_triggered()

# --- Goal System Events (Placeholders) ---
# signal goal_progress_updated(agent_body, goal_id, new_progress)
# signal goal_completed(agent_body, goal_id, success_level)

# --- Module Specific Signals (Placeholders - Use sparingly) ---
# signal major_discovery_made(discovery_data)


func _ready():
	print("EventBus Ready.")

--- Start of ./autoload/GameStateManager.gd ---

# File: autoload/GameStateManager.gd
# Autoload Singleton: GameStateManager
# Purpose: Handles saving and loading game state.
# Version: 1.1 - Corrected ProjectSettings.get_setting for Godot 3

extends Node

const SAVE_DIR = "user://savegames/"
const SAVE_FILE_PREFIX = "save_"
const SAVE_FILE_EXT = ".sav"  # Godot's variant storage format


func _ready():
	print("GameStateManager Ready.")
	# Ensure save directory exists on startup
	var dir = Directory.new()
	if not dir.dir_exists(SAVE_DIR):
		var err = dir.make_dir_recursive(SAVE_DIR)
		if err != OK:
			printerr(
				"GameStateManager Error: Could not create save directory: ",
				SAVE_DIR,
				" Error: ",
				err
			)


# --- Save Game ---
# Returns true on success, false on failure
func save_game(slot_id: int) -> bool:
	print("Attempting to save game to slot ", slot_id)
	var save_data = {}  # Dictionary to hold all save data

	# --- (Gathering Data) ---
	# 1. Player Data
	if is_instance_valid(GlobalRefs.player_agent_body):
		var player_data = {}
		player_data["scene_path"] = Constants.PLAYER_AGENT_SCENE_PATH
		player_data["position_x"] = GlobalRefs.player_agent_body.global_transform.origin.x
		player_data["position_y"] = GlobalRefs.player_agent_body.global_transform.origin.y
		player_data["position_z"] = GlobalRefs.player_agent_body.global_transform.origin.z
		player_data["rotation_basis_cols"] = [
			GlobalRefs.player_agent_body.global_transform.basis.x,
			GlobalRefs.player_agent_body.global_transform.basis.y,
			GlobalRefs.player_agent_body.global_transform.basis.z
		]
		player_data["position_z"] = GlobalRefs.player_agent_body.global_transform.origin.z
		save_data["player_state"] = player_data
	else:
		printerr("Save Error: Player agent body not valid!")
		return false

	# 2. Character System Data (FP, WP, Skills, etc.) - Assumed Placeholder
	if (
		is_instance_valid(GlobalRefs.character_system)
		and GlobalRefs.character_system.has_method("get_player_save_data")
	):
		save_data["character_state"] = GlobalRefs.character_system.get_player_save_data()
	else:
		print("Save Warning: CharacterSystem missing or no save method. FP/WP/Skills NOT saved.")

	# 3. World State
	var world_data = {}
	if is_instance_valid(GlobalRefs.current_zone):
		world_data["current_zone_path"] = GlobalRefs.current_zone.filename
	else:
		printerr("Save Error: Current zone reference invalid!")
		return false
	# TODO: Add Time Clock Value - Requires Time System/Manager reference
	# world_data["time_clock_tu"] = GlobalRefs.time_manager.get_current_tu()
	save_data["world_state"] = world_data

	# 4. Goal System State - Assumed Placeholder
	# if is_instance_valid(GlobalRefs.goal_system) and GlobalRefs.goal_system.has_method("get_save_data"):
	#     save_data["goal_system_state"] = GlobalRefs.goal_system.get_save_data()

	# 5. Add Metadata
	# *** CORRECTED for Godot 3 ***
	var game_version_setting = ProjectSettings.get_setting("application/config/version")
	var game_version = "0.0.1"  # Default version
	if game_version_setting != null:
		game_version = str(game_version_setting)  # Ensure it's a string if found
	# *** END CORRECTION ***

	save_data["metadata"] = {"save_time": OS.get_unix_time(), "game_version": game_version}

	# --- Writing File ---
	var file = File.new()
	var path = SAVE_DIR + SAVE_FILE_PREFIX + str(slot_id) + SAVE_FILE_EXT
	var err = file.open(path, File.WRITE)

	if err == OK:
		# Use true for share/compression - valid in Godot 3
		file.store_var(save_data, true)
		file.close()
		print("Game saved successfully to: ", path)
		return true
	else:
		printerr("Error saving game to path: ", path, " Error code: ", err)
		file.close()  # Ensure file is closed even on error
		return false


# --- Load Game ---
# Returns true on success, false on failure
func load_game(slot_id: int) -> bool:
	print("Load attempt for slot ", slot_id)
	var path = get_save_slot_path(slot_id)
	print("Load path: ", path)

	var file = File.new()
	if not file.file_exists(path):
		printerr("Load Error: Save file not found at path!")
		return false

	print("Load Debug: File exists. Attempting to open...")
	var err = file.open(path, File.READ)
	if err != OK:
		printerr("Load Error: Failed to open file for reading! Error code: ", err)
		return false

	print("Load Debug: File opened. Attempting to get var...")
	# Use true if store_var used true
	var save_data = file.get_var(true)
	var file_err = file.get_error()  # Check error *after* operation
	file.close()  # Close file immediately

	if file_err != OK:
		printerr("Load Error: Error reading var from file! File Error code: ", file_err)
		return false

	print("Load Debug: Got var. Checking type...")
	if not save_data is Dictionary:
		printerr("Load Error: Save file data is not a Dictionary! Type is: ", typeof(save_data))
		return false

	print("Save file loaded successfully. Applying state...")
	# ... (Placeholder apply logic) ...
	EventBus.emit_signal("game_loaded", save_data)
	return true

	# --- Apply Loaded State ---
	# This section requires careful coordination with scene loading and initialization.
	# It might need to emit signals or use call_deferred extensively.
	# Placeholder logic - assumes this is called from a state where loading is safe (e.g., main menu)

	# 1. Request Zone Load (WorldManager listens for this?) - NEEDS A ROBUST WORKFLOW
	if save_data.has("world_state") and save_data.world_state.has("current_zone_path"):
		var zone_path = save_data.world_state.current_zone_path
		if (
			is_instance_valid(GlobalRefs.world_manager)
			and GlobalRefs.world_manager.has_method("load_zone")
		):
			# Ideally, loading should happen via scene transition, not direct call here.
			# For now, just logging. Actual loading needs proper handling.
			print("Load Request: Need to load zone: ", zone_path)
			# GlobalRefs.world_manager.load_zone(zone_path) # Direct call here is usually problematic
			# Need a system to handle scene transition THEN player spawn/restore
			# Emit signal instead? EventBus.emit_signal("load_zone_requested", zone_path, save_data)
		else:
			printerr("Load Error: Cannot request zone load, WorldManager invalid/missing method.")
			return false
	else:
		printerr("Load Error: Save data missing world state or zone path.")
		return false

	# 2. Restore Player State (Should happen AFTER zone is loaded)
	# This logic needs to be triggered *after* the scene transition and player spawn.
	# Placeholder - This should be handled by CharacterSystem reacting to load event or player spawn
	if save_data.has("player_state"):
		var p_state = save_data.player_state
		var p_pos = Vector3(
			p_state.get("position_x", 0), p_state.get("position_y", 0), p_state.get("position_z", 0)
		)
		var p_basis_cols = p_state.get(
			"rotation_basis_cols", [Vector3.RIGHT, Vector3.UP, Vector3.BACK]
		)
		var p_basis = Basis(p_basis_cols[0], p_basis_cols[1], p_basis_cols[2])
		# Need to apply pos/rot AFTER player is spawned in the new zone.
		print("Load Request: Player should spawn at ", p_pos, " with rotation")

	if save_data.has("character_state"):
		# CharacterSystem should listen for game_loaded or player_spawned signal
		# and apply this data to the player agent
		print("Load Request: Character state needs restore: ", save_data.character_state)
		# GlobalRefs.character_system.load_save_data(save_data.character_state)

	# 3. Restore Time Clock
	# print("Load Request: Time clock needs restore")
	# GlobalRefs.time_manager.load_save_data(...)

	# 4. Restore Goal System State
	# print("Load Request: Goals need restore")
	# GlobalRefs.goal_system.load_save_data(...)

	# 5. Restore Persistent NPCs (Later Phase)

	# 6. Emit signal that load data is ready (systems should listen and apply)
	print("Load Process: Emitting game_loaded signal...")
	EventBus.emit_signal("game_loaded", save_data)  # Pass full data

	# IMPORTANT: Returning true here only means the file was read.
	# Actual game state restoration is asynchronous and depends on listeners.
	return true


# --- Helper Functions ---
func get_save_slot_path(slot_id: int) -> String:
	return SAVE_DIR + SAVE_FILE_PREFIX + str(slot_id) + SAVE_FILE_EXT


func save_exists(slot_id: int) -> bool:
	var file = File.new()
	return file.file_exists(get_save_slot_path(slot_id))


# Gets only the metadata part of a save file, if possible
func get_save_metadata(slot_id: int) -> Dictionary:
	var path = get_save_slot_path(slot_id)
	var file = File.new()
	if not file.file_exists(path):
		return {}
	var err = file.open(path, File.READ)
	if err != OK:
		return {}
	# Use false here if we ONLY want the top-level dict, not full object parsing
	# Depends if metadata is stored simply at top level
	var data = file.get_var(true)
	file.close()
	if data is Dictionary and data.has("metadata"):
		return data.metadata
	# Try parsing non-shared if metadata is simple? Might fail on complex saves.
	# var file2 = File.new(); file2.open(path, File.READ); var data2 = file2.get_var(false); file2.close()
	# if data2 is Dictionary and data2.has("metadata"): return data2.metadata
	print("Warning: Could not read metadata from save slot ", slot_id)
	return {}

--- Start of ./autoload/GlobalRefs.gd ---

# File: autoload/GlobalRefs.gd
# Autoload Singleton: GlobalRefs
# Purpose: Holds easily accessible references to unique global nodes/managers.
# Nodes register themselves here via setter functions during their _ready() phase.
# Version: 1.0

extends Node

# --- Key Node References ---
# Other scripts access these directly (e.g., GlobalRefs.player_agent_body)
# but should ALWAYS check if is_instance_valid() first!

var player_agent_body = null setget set_player_agent_body  #KinematicBody, spawned by WM
var main_camera = null setget set_main_camera
var world_manager = null setget set_world_manager
var event_system = null setget set_event_system  # If EventSystem is a Node, not Autoload
var goal_system = null setget set_goal_system  # If GoalSystem is a Node
var character_system = null setget set_character_system  # If CharacterSystem is a Node
var asset_system = null setget set_asset_system  # If AssetSystem is a Node

# Add other core system node references as needed...
var current_zone = null setget set_current_zone  # Reference to the root node of the loaded zone scene
var agent_container = null setget set_agent_container  # Reference to the node *within* the zone where agents are parented
var main_hud = null setget set_main_hud


func _ready():
	print("GlobalRefs Ready.")
	# This script typically doesn't do much itself, it just holds references set by others.


# --- Setters (Provide controlled way to update references & add validation) ---
# Using setget ensures these are called automatically on assignment.


func set_player_agent_body(new_ref):
	if new_ref == player_agent_body:
		return  # No change
	if new_ref == null or is_instance_valid(new_ref):
		player_agent_body = new_ref
		print("GlobalRefs: Player Agent reference ", "set to ", new_ref.name if new_ref else "null")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Player Agent reference: ", new_ref)


func set_main_camera(new_ref):
	if new_ref == main_camera:
		return
	if new_ref == null or is_instance_valid(new_ref):
		main_camera = new_ref
		print("GlobalRefs: Main Camera reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Main Camera reference: ", new_ref)


func set_world_manager(new_ref):
	if new_ref == world_manager:
		return
	if new_ref == null or is_instance_valid(new_ref):
		world_manager = new_ref
		print("GlobalRefs: World Manager reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid World Manager reference: ", new_ref)


func set_event_system(new_ref):
	if new_ref == event_system:
		return
	if new_ref == null or is_instance_valid(new_ref):
		event_system = new_ref
		print("GlobalRefs: Event System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Event System reference: ", new_ref)


func set_goal_system(new_ref):
	if new_ref == goal_system:
		return
	if new_ref == null or is_instance_valid(new_ref):
		goal_system = new_ref
		print("GlobalRefs: Goal System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Goal System reference: ", new_ref)


func set_character_system(new_ref):
	if new_ref == character_system:
		return
	if new_ref == null or is_instance_valid(new_ref):
		character_system = new_ref
		print("GlobalRefs: Character System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Character System reference: ", new_ref)


func set_asset_system(new_ref):
	if new_ref == asset_system:
		return
	if new_ref == null or is_instance_valid(new_ref):
		asset_system = new_ref
		print("GlobalRefs: Asset System reference ", "set." if new_ref else "cleared.")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Asset System reference: ", new_ref)


func set_current_zone(new_ref):
	if new_ref == current_zone:
		return
	if new_ref == null or is_instance_valid(new_ref):
		current_zone = new_ref
		print("GlobalRefs: Current Zone reference ", "set to ", new_ref.name if new_ref else "null")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Current Zone reference: ", new_ref)


func set_agent_container(new_ref):
	if new_ref == agent_container:
		return
	if new_ref == null or is_instance_valid(new_ref):
		agent_container = new_ref
		print(
			"GlobalRefs: Agent Container reference ", "set to ", new_ref.name if new_ref else "null"
		)
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Agent Container reference: ", new_ref)


func set_main_hud(new_ref):
	if new_ref == main_hud:
		return
	if new_ref == null or is_instance_valid(new_ref):
		main_hud = new_ref
		print("GlobalRefs: Main HUD reference ", "set to ", new_ref.name if new_ref else "null")
	else:
		printerr("GlobalRefs Error: Attempted to set invalid Main HUD reference: ", new_ref)

# --- Optional: Add simple getter functions if needed ---
# func get_player() -> KinematicBody:
#     return player_agent_body if is_instance_valid(player_agent_body) else null

--- Start of ./core/agents/agent.gd ---

# File: res://core/agents/agent.gd (Attached to AgentBody KinematicBody)
# Version: 3.35 - Modified command_orbit to capture current distance.
extends KinematicBody

# --- Core State & Identity ---
var agent_name: String = "Default Agent"
var faction_id: String = "Neutral"
var template_id: String = "default"
var interaction_radius: float = 15.0

# --- Physics State ---
var current_velocity: Vector3 = Vector3.ZERO

# --- Component References ---
var movement_system: Node = null
var navigation_system: Node = null


# --- Initialization ---
# Called externally (e.g., by WorldManager) after instancing and adding to tree
func initialize(template: AgentTemplate, overrides: Dictionary = {}):
	if not template is AgentTemplate:
		printerr("AgentBody Initialize Error: Invalid template for ", self.name)
		return

	self.template_id = template.template_id
	var default_name = template.default_agent_name + "_" + str(get_instance_id())
	self.agent_name = overrides.get("name", default_name)
	self.faction_id = overrides.get("faction", template.default_faction_id)
	self.name = self.agent_name
	self.interaction_radius = overrides.get("interaction_radius", template.interaction_radius)

	movement_system = get_node_or_null("MovementSystem")
	navigation_system = get_node_or_null("NavigationSystem")

	if not is_instance_valid(movement_system) or not is_instance_valid(navigation_system):
		printerr(
			"AgentBody Initialize Error: Failed to get required component nodes for '",
			self.name,
			"'."
		)
		set_physics_process(false)
		return

	var move_params = {
		"max_move_speed": overrides.get("max_move_speed", template.max_move_speed),
		"acceleration": overrides.get("acceleration", template.acceleration),
		"deceleration": overrides.get("deceleration", template.deceleration),
		"max_turn_speed": overrides.get("max_turn_speed", template.max_turn_speed),
		"brake_strength": overrides.get("brake_strength", template.deceleration * 1.5),
		"alignment_threshold_angle_deg":
		overrides.get("alignment_threshold_angle_deg", template.alignment_threshold_angle_deg)
	}
	var nav_params = {
		"orbit_kp": overrides.get("orbit_kp", 3.0),
		"orbit_ki": overrides.get("orbit_ki", 0.1),
		"orbit_kd": overrides.get("orbit_kd", 0.5)
	}

	movement_system.initialize_movement_params(move_params)
	navigation_system.initialize_navigation(nav_params, movement_system)

	print(
		"AgentBody '",
		self.name,
		"' initialized WITH COMPONENTS successfully using template '",
		self.template_id,
		"'."
	)


# --- Godot Lifecycle ---
func _ready():
	add_to_group("Agents")
	set_physics_process(true)


func _physics_process(delta: float):
	if not is_instance_valid(navigation_system) or not is_instance_valid(movement_system):
		if delta > 0:
			printerr("AgentBody _physics_process Error: Components invalid for '", self.name, "'!")
		set_physics_process(false)
		return

	if delta <= 0.0001:
		return

	# 1. Update Navigation & Movement Logic
	navigation_system.update_navigation(delta)

	# 2. Smoothly enforce the current speed limit before moving.
	movement_system.enforce_speed_limit(delta)

	# 3. Apply Physics Engine Movement
	current_velocity = move_and_slide(current_velocity, Vector3.UP)

	# 4. Apply Post-Movement Corrections (e.g., PID for orbit)
	navigation_system.apply_orbit_pid_correction(delta)


# --- Public Command API (Delegates to NavigationSystem) ---
func command_stop():
	if is_instance_valid(navigation_system):
		navigation_system.set_command_stopping()
	else:
		printerr("AgentBody: Cannot command_stop - NavigationSystem invalid.")


func command_move_to(position: Vector3):
	if is_instance_valid(navigation_system):
		navigation_system.set_command_move_to(position)
	else:
		printerr("AgentBody: Cannot command_move_to - NavigationSystem invalid.")


func command_move_direction(direction: Vector3):
	if is_instance_valid(navigation_system):
		navigation_system.set_command_move_direction(direction)
	else:
		printerr("AgentBody: Cannot command_move_direction - NavigationSystem invalid.")


func command_approach(target: Spatial):
	if is_instance_valid(navigation_system):
		navigation_system.set_command_approach(target)
	else:
		printerr("AgentBody: Cannot command_approach - NavigationSystem invalid.")


# MODIFIED: This function now captures the ship's current distance to the target
# as the desired orbit distance, preventing the navigation system from
# immediately trying to correct to a different, pre-calculated minimum.
func command_orbit(target: Spatial):
	if not is_instance_valid(target):
		printerr("AgentBody: command_orbit - Invalid target node provided.")
		if is_instance_valid(navigation_system):
			navigation_system.set_command_stopping()
		return

	if is_instance_valid(navigation_system):
		var vec_to_target_local = to_local(target.global_transform.origin)
		var orbit_clockwise = vec_to_target_local.x > 0.01
		
		# Always capture the current distance. The NavigationSystem will handle
		# gently pushing the agent out if this distance is too close.
		var captured_orbit_dist = global_transform.origin.distance_to(target.global_transform.origin)
		
		navigation_system.set_command_orbit(target, captured_orbit_dist, orbit_clockwise)
	else:
		printerr("AgentBody: Cannot command_orbit - NavigationSystem invalid.")


func command_flee(target: Spatial):
	if is_instance_valid(navigation_system):
		navigation_system.set_command_flee(target)
	else:
		printerr("AgentBody: Cannot command_flee - NavigationSystem invalid.")


func command_align_to(direction: Vector3):
	if is_instance_valid(navigation_system):
		navigation_system.set_command_align_to(direction)
	else:
		printerr("AgentBody: Cannot command_align_to - NavigationSystem invalid.")


# --- Public Getters ---
func get_interaction_radius() -> float:
	return interaction_radius


# --- Despawn ---
func despawn():
	print("AgentBody '", self.name, "' despawning...")
	EventBus.emit_signal("agent_despawning", self)
	set_physics_process(false)
	call_deferred("queue_free")

--- Start of ./core/agents/agent_template.gd ---

# File: core/agents/agent_template.gd
# Resource Definition for Agent Stats/Config
# Version: 1.1 - Added alignment threshold export

extends Resource
class_name AgentTemplate  # Allows type hinting and creating this resource type in editor

# --- Identification ---
export var template_id: String = "default_template"  # Unique ID for this template type
export var default_agent_name: String = "Agent"  # Base name for agents using this
export var default_faction_id: String = "Neutral"  # Default faction

# --- Base Movement Capabilities (Reads defaults from Constants) ---
export var max_move_speed: float = Constants.DEFAULT_MAX_MOVE_SPEED
export var acceleration: float = Constants.DEFAULT_ACCELERATION
export var deceleration: float = Constants.DEFAULT_DECELERATION
export var max_turn_speed: float = Constants.DEFAULT_MAX_TURN_SPEED

# --- Interaction Size ---
# Used by camera targeting, docking, etc. Represents effective size.
export var interaction_radius: float = 15.0  # Default reasonable size

# --- NEW: Alignment Threshold ---
# Agent will only accelerate forward if facing within this angle (degrees) of the target direction.
# Relevant for MOVE_TO, MOVE_DIRECTION, APPROACH, FLEE commands.
export var alignment_threshold_angle_deg: float = 45.0

# --- Base Combat Stats (Placeholders - Link to Combat Module/Character System later) ---
# export var base_hull : int = 100
# export var base_shields : int = 0

# --- Base Skills (Placeholders - Link to Character System later) ---
# These represent the inherent skill level associated with this *type* of agent
# export var base_piloting_skill : int = 0
# export var base_tech_skill : int = 0
# export var base_social_skill : int = 0

# --- AI Behavior Hint (Optional) ---
# export var default_ai_behavior : String = "idle" # Hint for AI controller selection/init

# --- Visuals / Asset Links (Placeholders) ---
# Optional: Could link to default ship model path, visual effects, etc.
# export (String, FILE, "*.tscn,*.glb,*.gltf") var default_model_path = ""

--- Start of ./core/agents/components/movement_system.gd ---

# File: res://core/agents/components/movement_system.gd
# Version: 1.4 - Added smooth deceleration when max_move_speed is lowered.
# Purpose: Handles the low-level execution of agent movement and rotation physics.
# Called by NavigationSystem.

extends Node

# --- Movement Capabilities (Set by AgentBody during initialize) ---
var max_move_speed: float = Constants.DEFAULT_MAX_MOVE_SPEED
var acceleration: float = Constants.DEFAULT_ACCELERATION
var deceleration: float = Constants.DEFAULT_DECELERATION
var brake_strength: float = Constants.DEFAULT_DECELERATION * 1.5
var max_turn_speed: float = Constants.DEFAULT_MAX_TURN_SPEED
var alignment_threshold_angle_deg: float = 45.0
var _alignment_threshold_rad: float = deg2rad(alignment_threshold_angle_deg)

# --- Angular Velocity & Damping ---
var angular_velocity := Vector3.ZERO
var turn_damping := 5.0

# Reference to the parent AgentBody KinematicBody
var agent_body: KinematicBody = null


func _ready():
	agent_body = get_parent()
	if not agent_body is KinematicBody:
		printerr("MovementSystem Error: Parent is not a KinematicBody!")
		agent_body = null
		set_process(false)


func initialize_movement_params(params: Dictionary):
	max_move_speed = params.get("max_move_speed", max_move_speed)
	acceleration = params.get("acceleration", acceleration)
	deceleration = params.get("deceleration", deceleration)
	brake_strength = params.get("brake_strength", deceleration * 1.5)
	max_turn_speed = params.get("max_turn_speed", max_turn_speed)
	alignment_threshold_angle_deg = params.get(
		"alignment_threshold_angle_deg", alignment_threshold_angle_deg
	)
	_alignment_threshold_rad = deg2rad(alignment_threshold_angle_deg)
	print(
		(
			"MovementSystem Initialized: Speed=%.1f, Accel=%.1f, Decel=%.1f, Turn=%.1f, Align=%.1f"
			% [
				max_move_speed,
				acceleration,
				deceleration,
				max_turn_speed,
				alignment_threshold_angle_deg
			]
		)
	)


# --- Public Methods Called by NavigationSystem & AgentBody ---

# Applies acceleration towards max_move_speed ONLY if aligned within threshold.
func apply_acceleration(target_direction: Vector3, delta: float):
	if not is_instance_valid(agent_body):
		return

	if target_direction.length_squared() < 0.001:
		apply_deceleration(delta)
		return

	var target_dir_norm = target_direction.normalized()
	var current_forward = -agent_body.global_transform.basis.z.normalized()
	var angle = current_forward.angle_to(target_dir_norm)

	if angle <= _alignment_threshold_rad:
		var target_velocity = target_dir_norm * max_move_speed
		agent_body.current_velocity = agent_body.current_velocity.linear_interpolate(
			target_velocity, acceleration * delta
		)
	else:
		# If not aligned, we just decelerate naturally instead of accelerating.
		apply_deceleration(delta)


# Applies natural deceleration (drag).
func apply_deceleration(delta: float):
	if not is_instance_valid(agent_body):
		return
	# We only apply natural deceleration if we are NOT over the speed limit.
	# If we are over, enforce_speed_limit() will handle the deceleration.
	if agent_body.current_velocity.length_squared() <= max_move_speed * max_move_speed:
		agent_body.current_velocity = agent_body.current_velocity.linear_interpolate(
			Vector3.ZERO, deceleration * delta
		)


# Applies active braking force.
func apply_braking(delta: float) -> bool:
	if not is_instance_valid(agent_body):
		return true
	agent_body.current_velocity = agent_body.current_velocity.linear_interpolate(
		Vector3.ZERO, brake_strength * delta
	)
	return agent_body.current_velocity.length_squared() < 0.5


# Handles rotation and calculates resulting angular velocity.
func apply_rotation(target_look_dir: Vector3, delta: float):
	if not is_instance_valid(agent_body):
		return

	var basis_before_rotation = agent_body.global_transform.basis

	if target_look_dir.length_squared() < 0.001:
		angular_velocity = Vector3.ZERO
		return

	var target_dir = target_look_dir.normalized()
	var current_basis = basis_before_rotation.orthonormalized()

	var up_vector = Vector3.UP
	if abs(target_dir.dot(Vector3.UP)) > 0.999:
		up_vector = Vector3.FORWARD

	var target_basis = Transform(Basis(), Vector3.ZERO).looking_at(target_dir, up_vector).basis.orthonormalized()

	if current_basis.is_equal_approx(target_basis):
		angular_velocity = Vector3.ZERO
		return

	var new_basis: Basis
	if max_turn_speed > 0.001:
		var turn_step = max_turn_speed * delta
		new_basis = current_basis.slerp(target_basis, turn_step)
	else:
		new_basis = target_basis

	agent_body.global_transform.basis = new_basis

	var rotation_diff_basis = new_basis * basis_before_rotation.inverse()
	var rotation_diff_quat = Quat(rotation_diff_basis)

	var angle = 2 * acos(rotation_diff_quat.w)
	var axis: Vector3
	var sin_half_angle = sin(angle / 2)
	
	if sin_half_angle > 0.0001:
		axis = Vector3(rotation_diff_quat.x, rotation_diff_quat.y, rotation_diff_quat.z) / sin_half_angle
	else:
		axis = Vector3.UP

	if delta > 0.0001:
		angular_velocity = axis * (angle / delta)
	else:
		angular_velocity = Vector3.ZERO


# Smoothly dampens rotation to a stop.
func damp_rotation(delta: float):
	if not is_instance_valid(agent_body):
		return

	if angular_velocity.length_squared() > 0.0001:
		var rotation_axis = angular_velocity.normalized()
		var rotation_angle = angular_velocity.length() * delta
		agent_body.rotate(rotation_axis, rotation_angle)

		angular_velocity = angular_velocity.linear_interpolate(Vector3.ZERO, turn_damping * delta)


# NEW: Smoothly reduces speed if current velocity is over the max_move_speed limit.
func enforce_speed_limit(delta: float):
	if not is_instance_valid(agent_body):
		return

	var current_speed_sq = agent_body.current_velocity.length_squared()
	var max_speed_sq = max_move_speed * max_move_speed

	if current_speed_sq > max_speed_sq:
		# We are over the speed limit. Smoothly decelerate to the new cap.
		var direction = agent_body.current_velocity.normalized()
		var target_velocity = direction * max_move_speed
		
		# Use the existing deceleration property for a consistent feel.
		agent_body.current_velocity = agent_body.current_velocity.linear_interpolate(
			target_velocity, deceleration * delta
		)

--- Start of ./core/agents/components/navigation_system/command_align_to.gd ---

# File: core/agents/components/navigation_system/command_align_to.gd
extends Node

var _nav_sys: Node
var _agent_body: KinematicBody
var _movement_system: Node


func initialize(nav_system):
	_nav_sys = nav_system
	_agent_body = nav_system.agent_body
	_movement_system = nav_system.movement_system


func execute(delta: float):
	if is_instance_valid(_movement_system) and is_instance_valid(_agent_body):
		var target_dir = _nav_sys._current_command.target_dir
		_movement_system.apply_rotation(target_dir, delta)
		_movement_system.apply_deceleration(delta)
		var current_fwd = -_agent_body.global_transform.basis.z
		if current_fwd.dot(target_dir) > 0.999:
			_nav_sys.set_command_idle()

--- Start of ./core/agents/components/navigation_system/command_approach.gd ---

# File: core/agents/components/navigation_system/command_approach.gd
extends Node

var _nav_sys: Node
var _agent_body: KinematicBody
var _movement_system: Node
var _pid: PIDController


func initialize(nav_system):
	_nav_sys = nav_system
	_agent_body = nav_system.agent_body
	_movement_system = nav_system.movement_system
	_pid = nav_system._pid_approach


func execute(delta: float):
	if not is_instance_valid(_pid):
		return

	var cmd = _nav_sys._current_command
	var target_node = cmd.target_node
	var target_pos = target_node.global_transform.origin
	var target_size = _nav_sys._get_target_effective_size(target_node)
	var desired_stop_dist = max(
		_nav_sys.APPROACH_MIN_DISTANCE, target_size * _nav_sys.APPROACH_DISTANCE_MULTIPLIER
	)

	var vector_to_target = target_pos - _agent_body.global_transform.origin
	var distance = vector_to_target.length()

	if distance < (desired_stop_dist + _nav_sys.ARRIVAL_DISTANCE_THRESHOLD):
		if not cmd.get("signaled_stop", false):
			EventBus.emit_signal("agent_reached_destination", _agent_body)
			cmd["signaled_stop"] = true
		_nav_sys.set_command_idle()
		_movement_system.apply_braking(delta)
		return

	var direction = vector_to_target.normalized() if distance > 0.01 else Vector3.ZERO
	_movement_system.apply_rotation(direction, delta)

	var deceleration_start_dist = (
		desired_stop_dist
		* _nav_sys.APPROACH_DECELERATION_START_DISTANCE_FACTOR
	)
	var target_velocity: Vector3

	if distance > deceleration_start_dist:
		target_velocity = direction * _movement_system.max_move_speed
		_pid.reset()
		cmd["signaled_stop"] = false
	else:
		var distance_error = distance - desired_stop_dist
		var pid_target_speed = _pid.update(distance_error, delta)
		pid_target_speed = clamp(
			pid_target_speed,
			-_movement_system.max_move_speed * 0.1,
			_movement_system.max_move_speed
		)
		target_velocity = direction * pid_target_speed

		if (
			abs(distance_error) < _nav_sys.ARRIVAL_DISTANCE_THRESHOLD
			and _agent_body.current_velocity.length_squared() < _nav_sys.ARRIVAL_SPEED_THRESHOLD_SQ
		):
			if not cmd.get("signaled_stop", false):
				EventBus.emit_signal("agent_reached_destination", _agent_body)
				cmd["signaled_stop"] = true
			_movement_system.apply_braking(delta)
			return
		else:
			cmd["signaled_stop"] = false

	_agent_body.current_velocity = _agent_body.current_velocity.linear_interpolate(
		target_velocity, _movement_system.acceleration * delta
	)

--- Start of ./core/agents/components/navigation_system/command_flee.gd ---

# File: core/agents/components/navigation_system/command_flee.gd
extends Node

var _nav_sys: Node
var _agent_body: KinematicBody
var _movement_system: Node


func initialize(nav_system):
	_nav_sys = nav_system
	_agent_body = nav_system.agent_body
	_movement_system = nav_system.movement_system


func execute(delta: float):
	if is_instance_valid(_movement_system) and is_instance_valid(_agent_body):
		var target_pos = _nav_sys._current_command.target_node.global_transform.origin
		var vector_away = _agent_body.global_transform.origin - target_pos
		var direction_away = (
			vector_away.normalized()
			if vector_away.length_squared() > 0.01
			else -_agent_body.global_transform.basis.z
		)
		_movement_system.apply_rotation(direction_away, delta)
		_movement_system.apply_acceleration(direction_away, delta)

--- Start of ./core/agents/components/navigation_system/command_idle.gd ---

# File: core/agents/components/navigation_system/command_idle.gd
extends Node

var _movement_system: Node


func initialize(nav_system):
	_movement_system = nav_system.movement_system


func execute(delta: float):
	if is_instance_valid(_movement_system):
		_movement_system.apply_deceleration(delta)

--- Start of ./core/agents/components/navigation_system/command_move_direction.gd ---

# File: core/agents/components/navigation_system/command_move_direction.gd
extends Node

var _nav_sys: Node
var _movement_system: Node


func initialize(nav_system):
	_nav_sys = nav_system
	_movement_system = nav_system.movement_system


func execute(delta: float):
	if is_instance_valid(_movement_system):
		var move_dir = _nav_sys._current_command.get("target_dir", Vector3.ZERO)
		if move_dir.length_squared() > 0.001:
			_movement_system.apply_rotation(move_dir, delta)
			_movement_system.apply_acceleration(move_dir, delta)
		else:
			_movement_system.apply_deceleration(delta)

--- Start of ./core/agents/components/navigation_system/command_move_to.gd ---

# File: core/agents/components/navigation_system/command_move_to.gd
extends Node

var _nav_sys: Node
var _agent_body: KinematicBody
var _movement_system: Node
var _pid: PIDController


func initialize(nav_system):
	_nav_sys = nav_system
	_agent_body = nav_system.agent_body
	_movement_system = nav_system.movement_system
	_pid = nav_system._pid_move_to


func execute(delta: float):
	if not is_instance_valid(_pid):
		return

	var cmd = _nav_sys._current_command
	var target_pos = cmd.target_pos
	var vector_to_target = target_pos - _agent_body.global_transform.origin
	var distance = vector_to_target.length()

	var pid_target_speed = _pid.update(distance, delta)
	pid_target_speed = clamp(pid_target_speed, 0, _movement_system.max_move_speed)

	var direction = vector_to_target.normalized() if distance > 0.01 else Vector3.ZERO
	_movement_system.apply_rotation(direction, delta)

	var target_velocity = direction * pid_target_speed
	_agent_body.current_velocity = _agent_body.current_velocity.linear_interpolate(
		target_velocity, _movement_system.acceleration * delta
	)

	if (
		distance < _nav_sys.ARRIVAL_DISTANCE_THRESHOLD
		and _agent_body.current_velocity.length_squared() < _nav_sys.ARRIVAL_SPEED_THRESHOLD_SQ
	):
		if not cmd.get("signaled_stop", false):
			EventBus.emit_signal("agent_reached_destination", _agent_body)
			cmd["signaled_stop"] = true
		_movement_system.apply_braking(delta)
	else:
		cmd["signaled_stop"] = false

--- Start of ./core/agents/components/navigation_system/command_orbit.gd ---

# File: core/agents/components/navigation_system/command_orbit.gd
# Version: 1.4 - Added dynamic speed calculation for the spiral-out phase.
extends Node

var _nav_sys: Node
var _agent_body: KinematicBody
var _movement_system: Node

const SPIRAL_OUTWARD_FACTOR = 0.3
const ORBITAL_VELOCITY_LERP_WEIGHT = 2.5

var _current_orbital_velocity: Vector3 = Vector3.ZERO


func initialize(nav_system):
	_nav_sys = nav_system
	_agent_body = nav_system.agent_body
	_movement_system = nav_system.movement_system


func execute(delta: float):
	if not is_instance_valid(_movement_system) or not is_instance_valid(_agent_body):
		return

	var cmd = _nav_sys._current_command
	var target_node = cmd.target_node
	var target_pos = target_node.global_transform.origin
	var clockwise = cmd.get("clockwise", false)

	if cmd.get("is_new", false):
		_current_orbital_velocity = _agent_body.current_velocity
		cmd["is_new"] = false

	# --- Vector Calculations ---
	var vector_to_target = target_pos - _agent_body.global_transform.origin
	var distance = vector_to_target.length()
	if distance < 0.01: distance = 0.01
	var direction_to_target = vector_to_target / distance
	var tangent_dir = (direction_to_target.cross(Vector3.UP) if not clockwise else Vector3.UP.cross(direction_to_target)).normalized()

	# --- Determine Movement Direction & Ideal Speed ---
	var safe_dist = _nav_sys._get_target_effective_size(target_node) * _nav_sys.CLOSE_ORBIT_DISTANCE_THRESHOLD_FACTOR
	var ideal_move_dir: Vector3
	var speed_calc_dist: float # The distance to use for speed calculation

	if distance < safe_dist:
		# TOO CLOSE: Spiral out and use CURRENT distance for speed calculation.
		var radial_dir_outward = -direction_to_target
		ideal_move_dir = (tangent_dir + radial_dir_outward * SPIRAL_OUTWARD_FACTOR).normalized()
		speed_calc_dist = distance # Use current, closer distance for a slower speed.
	else:
		# SAFE DISTANCE: Normal orbit and use DESIRED distance for speed calculation.
		ideal_move_dir = tangent_dir
		speed_calc_dist = cmd.get("distance", 100.0) # Use final, desired distance.

	# Calculate the ideal speed based on the appropriate distance (current or desired).
	var full_speed_radius = max(1.0, Constants.ORBIT_FULL_SPEED_RADIUS)
	var ideal_speed = _movement_system.max_move_speed
	if speed_calc_dist > 0 and speed_calc_dist < full_speed_radius:
		ideal_speed *= (speed_calc_dist / full_speed_radius)
	ideal_speed = clamp(ideal_speed, 0.0, _movement_system.max_move_speed)

	var ideal_orbital_velocity = ideal_move_dir * ideal_speed

	# --- Smoothly Transition & Apply ---
	_current_orbital_velocity = _current_orbital_velocity.linear_interpolate(
		ideal_orbital_velocity, ORBITAL_VELOCITY_LERP_WEIGHT * delta
	)

	_movement_system.apply_rotation(tangent_dir, delta)
	_agent_body.current_velocity = _current_orbital_velocity

--- Start of ./core/agents/components/navigation_system/command_stop.gd ---

# File: core/agents/components/navigation_system/command_stop.gd
# Version: 1.1 - Added call to damp_rotation for smooth rotational stops.
extends Node

var _nav_sys: Node
var _agent_body: KinematicBody
var _movement_system: Node


func initialize(nav_system):
	_nav_sys = nav_system
	_agent_body = nav_system.agent_body
	_movement_system = nav_system.movement_system


func execute(delta: float):
	if is_instance_valid(_movement_system) and is_instance_valid(_agent_body):
		# --- Dampen linear motion ---
		var stopped_moving = _movement_system.apply_braking(delta)
		
		# --- NEW: Dampen angular motion ---
		_movement_system.damp_rotation(delta)
		
		# Check if linear motion has stopped before signaling completion
		if stopped_moving and not _nav_sys._current_command.get("signaled_stop", false):
			EventBus.emit_signal("agent_reached_destination", _agent_body)
			_nav_sys._current_command["signaled_stop"] = true

--- Start of ./core/agents/components/navigation_system.gd ---

# File: res://core/agents/components/navigation_system.gd
# Version: 2.1 - Added 'is_new' flag to orbit command for stateful initialization.

extends Node

# --- Enums and Constants ---
enum CommandType { IDLE, STOPPING, MOVE_TO, MOVE_DIRECTION, APPROACH, ORBIT, FLEE, ALIGN_TO }
const APPROACH_DISTANCE_MULTIPLIER = 1.3
const APPROACH_MIN_DISTANCE = 50.0
const APPROACH_DECELERATION_START_DISTANCE_FACTOR = 50.0
const ARRIVAL_DISTANCE_THRESHOLD = 5.0
const ARRIVAL_SPEED_THRESHOLD_SQ = 1.0
const CLOSE_ORBIT_DISTANCE_THRESHOLD_FACTOR = 1.5

# --- References ---
var agent_body: KinematicBody = null
var movement_system: Node = null

# --- State ---
var _current_command = {}

# --- Child Components ---
var _pid_orbit: PIDController = null
var _pid_approach: PIDController = null
var _pid_move_to: PIDController = null
var _command_handlers = {}
const PIDControllerScript = preload("res://core/utils/pid_controller.gd")


# --- Initialization ---
func _ready():
	if not _current_command:
		set_command_idle()


func initialize_navigation(nav_params: Dictionary, move_sys_ref: Node):
	movement_system = move_sys_ref
	agent_body = get_parent()

	if not is_instance_valid(agent_body) or not is_instance_valid(movement_system):
		printerr("NavigationSystem Error: Invalid parent or movement system reference!")
		set_process(false)
		return

	_initialize_pids(nav_params)
	_initialize_command_handlers()

	print("NavigationSystem Initialized.")
	set_command_idle()


func _initialize_pids(nav_params: Dictionary):
	if not PIDControllerScript:
		printerr("NavigationSystem Error: Failed to load PIDController script!")
		return

	_pid_orbit = PIDControllerScript.new()
	_pid_approach = PIDControllerScript.new()
	_pid_move_to = PIDControllerScript.new()

	add_child(_pid_orbit)
	add_child(_pid_approach)
	add_child(_pid_move_to)

	var o_limit = movement_system.max_move_speed
	_pid_orbit.initialize(
		nav_params.get("orbit_kp", 0.5),
		nav_params.get("orbit_ki", 0.001),
		nav_params.get("orbit_kd", 1.0),
		1000.0,
		75.0
	)
	_pid_approach.initialize(
		nav_params.get("approach_kp", 0.5),
		nav_params.get("approach_ki", 0.001),
		nav_params.get("approach_kd", 1.0),
		1000.0,
		o_limit
	)
	_pid_move_to.initialize(
		nav_params.get("move_to_kp", 0.5),
		nav_params.get("move_to_ki", 0.001),
		nav_params.get("move_to_kd", 1.0),
		1000.0,
		o_limit
	)


func _initialize_command_handlers():
	var command_path = "res://core/agents/components/navigation_system/"
	_command_handlers = {
		CommandType.IDLE: load(command_path + "command_idle.gd").new(),
		CommandType.STOPPING: load(command_path + "command_stop.gd").new(),
		CommandType.MOVE_TO: load(command_path + "command_move_to.gd").new(),
		CommandType.MOVE_DIRECTION: load(command_path + "command_move_direction.gd").new(),
		CommandType.APPROACH: load(command_path + "command_approach.gd").new(),
		CommandType.ORBIT: load(command_path + "command_orbit.gd").new(),
		CommandType.FLEE: load(command_path + "command_flee.gd").new(),
		CommandType.ALIGN_TO: load(command_path + "command_align_to.gd").new(),
	}

	for handler_script in _command_handlers.values():
		add_child(handler_script)
		if handler_script.has_method("initialize"):
			handler_script.initialize(self)


# --- Public Command Setting Methods ---
func set_command_idle():
	_current_command = {"type": CommandType.IDLE}


func set_command_stopping():
	_current_command = {"type": CommandType.STOPPING}
	if is_instance_valid(_pid_orbit):
		_pid_orbit.reset()
	if is_instance_valid(_pid_approach):
		_pid_approach.reset()
	if is_instance_valid(_pid_move_to):
		_pid_move_to.reset()


func set_command_move_to(position: Vector3):
	_current_command = {"type": CommandType.MOVE_TO, "target_pos": position}
	if is_instance_valid(_pid_orbit):
		_pid_orbit.reset()
	if is_instance_valid(_pid_approach):
		_pid_approach.reset()
	if is_instance_valid(_pid_move_to):
		_pid_move_to.reset()


func set_command_move_direction(direction: Vector3):
	if direction.length_squared() < 0.001:
		set_command_stopping()
		return
	_current_command = {"type": CommandType.MOVE_DIRECTION, "target_dir": direction.normalized()}


func set_command_approach(target: Spatial):
	if not is_instance_valid(target):
		set_command_stopping()
		return
	_current_command = {"type": CommandType.APPROACH, "target_node": target}
	if is_instance_valid(_pid_orbit):
		_pid_orbit.reset()
	if is_instance_valid(_pid_approach):
		_pid_approach.reset()
	if is_instance_valid(_pid_move_to):
		_pid_move_to.reset()


# MODIFIED: Added "is_new" flag to signal the command handler to initialize its state.
func set_command_orbit(target: Spatial, distance: float, clockwise: bool):
	if not is_instance_valid(target):
		set_command_stopping()
		return
	_current_command = {
		"type": CommandType.ORBIT,
		"target_node": target,
		"distance": distance,
		"clockwise": clockwise,
		"is_new": true # Flag for one-time setup in the command handler
	}
	if is_instance_valid(_pid_orbit):
		_pid_orbit.reset()
	if is_instance_valid(_pid_approach):
		_pid_approach.reset()
	if is_instance_valid(_pid_move_to):
		_pid_move_to.reset()


func set_command_flee(target: Spatial):
	if not is_instance_valid(target):
		set_command_stopping()
		return
	_current_command = {"type": CommandType.FLEE, "target_node": target}


func set_command_align_to(direction: Vector3):
	if direction.length_squared() < 0.001:
		set_command_idle()
		return
	_current_command = {"type": CommandType.ALIGN_TO, "target_dir": direction.normalized()}


# --- Main Update Logic ---
func update_navigation(delta: float):
	if not is_instance_valid(agent_body) or not is_instance_valid(movement_system):
		return

	var cmd_type = _current_command.get("type", CommandType.IDLE)
	var target_node = _current_command.get("target_node", null)

	var is_target_cmd = cmd_type in [CommandType.APPROACH, CommandType.ORBIT, CommandType.FLEE]
	if is_target_cmd and not is_instance_valid(target_node):
		set_command_stopping()
		cmd_type = CommandType.STOPPING

	if _command_handlers.has(cmd_type):
		var handler = _command_handlers[cmd_type]
		if handler.has_method("execute"):
			handler.execute(delta)
	else:
		_command_handlers[CommandType.IDLE].execute(delta)


# --- PID Correction & Helper Functions ---
func apply_orbit_pid_correction(delta: float):
	if _current_command.get("type") != CommandType.ORBIT:
		return
	if (
		not is_instance_valid(agent_body)
		or not is_instance_valid(movement_system)
		or not is_instance_valid(_pid_orbit)
	):
		return

	var target_node = _current_command.get("target_node", null)
	if is_instance_valid(target_node):
		var desired_orbit_dist = _current_command.get("distance", 100.0)
		var vector_to_target = (
			target_node.global_transform.origin
			- agent_body.global_transform.origin
		)
		var current_distance = vector_to_target.length()
		if current_distance < 0.01:
			return

		var distance_error = current_distance - desired_orbit_dist
		var pid_output = _pid_orbit.update(distance_error, delta)

		var close_orbit_threshold = APPROACH_MIN_DISTANCE * CLOSE_ORBIT_DISTANCE_THRESHOLD_FACTOR
		if distance_error < 0 and desired_orbit_dist < close_orbit_threshold:
			var max_outward_push_speed = movement_system.max_move_speed * 0.05
			pid_output = max(pid_output, -max_outward_push_speed)

		var radial_direction = vector_to_target.normalized()
		var velocity_correction = radial_direction * pid_output
		agent_body.current_velocity += velocity_correction


func _get_target_effective_size(target_node: Spatial) -> float:
	var calculated_size = 1.0
	var default_radius = 10.0

	if not is_instance_valid(target_node):
		return default_radius

	if target_node.has_method("get_interaction_radius"):
		var explicit_radius = target_node.get_interaction_radius()
		if (explicit_radius is float or explicit_radius is int) and explicit_radius > 0:
			return max(float(explicit_radius), 1.0)

	var model_node = target_node.get_node_or_null("Model")
	if is_instance_valid(model_node) and model_node is Spatial:
		var combined_aabb: AABB = AABB()
		var first_visual_found = false
		for child in model_node.get_children():
			if child is VisualInstance:
				var child_global_aabb = child.get_transformed_aabb()
				if not first_visual_found:
					combined_aabb = child_global_aabb
					first_visual_found = true
				else:
					combined_aabb = combined_aabb.merge(child_global_aabb)

		if first_visual_found:
			var longest_axis_size = combined_aabb.get_longest_axis_size()
			calculated_size = longest_axis_size / 2.0
			if calculated_size > 0.01:
				return max(calculated_size, 1.0)

	var node_scale = target_node.global_transform.basis.get_scale()
	calculated_size = max(node_scale.x, max(node_scale.y, node_scale.z)) / 2.0
	if calculated_size <= 0.01:
		return default_radius

	return max(calculated_size, 1.0)

--- Start of ./core/systems/agent_spawner.gd ---

# File: core/systems/agent_spawner.gd
# New script dedicated to agent spawning logic.

extends Node

var _player_agent_body: KinematicBody = null


func _ready():
	# Listen for the zone_loaded signal to know when it's safe to spawn.
	EventBus.connect("zone_loaded", self, "_on_Zone_Loaded")


func _on_Zone_Loaded(_zone_instance, _zone_path, agent_container_node):
	if is_instance_valid(agent_container_node):
		if not is_instance_valid(_player_agent_body):
			spawn_player()
	else:
		printerr("AgentSpawner Error: Agent container invalid. Cannot spawn player.")


func spawn_player():
	var container = GlobalRefs.agent_container
	if not is_instance_valid(container):
		printerr("AgentSpawner Error: GlobalRefs.agent_container invalid.")
		return

	var player_template = load(Constants.PLAYER_DEFAULT_TEMPLATE_PATH)
	if not player_template is AgentTemplate:
		printerr("AgentSpawner Error: Failed to load Player AgentTemplate.")
		return

	var player_spawn_pos = Vector3.ZERO
	if is_instance_valid(GlobalRefs.current_zone):
		var entry_node = null
		if Constants.ENTRY_POINT_NAMES.size() > 0:
			entry_node = GlobalRefs.current_zone.find_node(
				Constants.ENTRY_POINT_NAMES[0], true, false
			)
		if entry_node is Spatial:
			player_spawn_pos = entry_node.global_transform.origin + Vector3(0, 5, 15)

	var player_overrides = {"name": "PlayerShip", "faction": "Player"}
	_player_agent_body = spawn_agent(
		Constants.PLAYER_AGENT_SCENE_PATH, player_spawn_pos, player_template, player_overrides
	)

	if is_instance_valid(_player_agent_body):
		GlobalRefs.player_agent_body = _player_agent_body
		EventBus.emit_signal("camera_set_target_requested", _player_agent_body)
		EventBus.emit_signal("player_spawned", _player_agent_body)
	else:
		printerr("AgentSpawner Error: Failed to spawn player agent body!")


func spawn_agent(
	agent_scene_path: String,
	position: Vector3,
	agent_template: Resource,
	overrides: Dictionary = {}
) -> KinematicBody:
	var container = GlobalRefs.agent_container
	if not is_instance_valid(container):
		printerr("AgentSpawner Spawn Error: Invalid GlobalRefs.agent_container.")
		return null
	if not agent_template is AgentTemplate:
		printerr("AgentSpawner Spawn Error: Invalid AgentTemplate Resource.")
		return null

	var agent_scene = load(agent_scene_path)
	if not agent_scene:
		printerr("AgentSpawner Spawn Error: Failed to load agent scene: ", agent_scene_path)
		return null

	var agent_root_instance = agent_scene.instance()
	# agent_node is the "AgentBody" KinematicBody within the scene instance
	var agent_node = agent_root_instance.get_node_or_null(Constants.AGENT_BODY_NODE_NAME)
	
	if not (agent_node and agent_node is KinematicBody):
		printerr("AgentSpawner Spawn Error: Invalid agent body node in scene: ", agent_scene_path)
		agent_root_instance.queue_free()
		return null

	var instance_name = overrides.get(
		"name", agent_template.default_agent_name + "_" + str(agent_root_instance.get_instance_id())
	)
	agent_root_instance.name = instance_name

	container.add_child(agent_root_instance)
	agent_node.global_transform.origin = position

	if agent_node.has_method("initialize"):
		agent_node.initialize(agent_template, overrides)

	EventBus.emit_signal(
		"agent_spawned", agent_node, {"template": agent_template, "overrides": overrides}
	)

	# --- CORRECTED CONTROLLER LOGIC ---
	# The controller is a child of the AgentBody (agent_node), not the scene root.
	# We also need to check for both AI and Player controllers.
	var ai_controller = agent_node.get_node_or_null(Constants.AI_CONTROLLER_NODE_NAME)
	var player_controller = agent_node.get_node_or_null(Constants.PLAYER_INPUT_HANDLER_NAME)
	
	if ai_controller and ai_controller.has_method("initialize"):
		ai_controller.initialize(overrides)
	# The PlayerInputHandler does not have an initialize method, so we don't need to call it,
	# but by getting a reference to it, we ensure the test framework is aware of it.
	
	return agent_node

--- Start of ./core/systems/asset_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/character_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/chronicle_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/event_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/goal_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/progression_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/traffic_system_placeholder.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/systems/world_map_system.gd ---

extends Node

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
	pass  # Replace with function body.

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

--- Start of ./core/ui/CenteredGrowingLabel.gd ---

# File: res://ui_elements/CenteredGrowingLabel.gd (or your preferred path)

# class_name ClassName, path/to/icon.svg
class_name CenteredGrowingLabel, "res://assets/art/ui/class_labels/class_centered_growing_label.svg"
extends Label

# --- Static Group Name ---
const AUTO_GROUP_NAME = "centered_growing_labels"

# --- Internal ---
var _is_ready_for_recenter = false


func _enter_tree():
	if not is_in_group(AUTO_GROUP_NAME):
		add_to_group(AUTO_GROUP_NAME)
	if not is_connected("resized", self, "_on_self_resized"):
		connect("resized", self, "_on_self_resized")
	call_deferred("_initial_setup_and_recenter")


func _initial_setup_and_recenter():
	_is_ready_for_recenter = true
	_recenter_in_parent()
	self.focus_mode = Control.FOCUS_NONE


func _exit_tree():
	if is_in_group(AUTO_GROUP_NAME):
		remove_from_group(AUTO_GROUP_NAME)
	if is_connected("resized", self, "_on_self_resized"):
		disconnect("resized", self, "_on_self_resized")


func _on_self_resized():
	_recenter_in_parent()


func _recenter_in_parent():
	if not _is_ready_for_recenter:
		return
	var parent_control = get_parent_control()
	if parent_control:
		var current_label_size = self.rect_size
		var parent_size = parent_control.rect_size
		var new_pos_x = (parent_size.x - current_label_size.x) / 2.0
		var new_pos_y = (parent_size.y - current_label_size.y) / 2.0
		if (
			not is_equal_approx(rect_position.x, new_pos_x)
			or not is_equal_approx(rect_position.y, new_pos_y)
		):
			self.rect_position = Vector2(new_pos_x, new_pos_y)


func get_parent_control() -> Control:
	var p = get_parent()
	if p is Control:
		return p
	return null

--- Start of ./core/ui/main_hud.gd ---

# File: res://core/ui/main_hud.gd
# Script for the main HUD container. Handles displaying targeting info, etc.
# Version: 1.1 - Fixed targeting indicator visibility restoration

extends Control

# --- Nodes ---
onready var targeting_indicator: Control = $TargetingIndicator

# --- State ---
var _current_target: Spatial = null
var _main_camera: Camera = null


# --- Initialization ---
func _ready():
	GlobalRefs.set_main_hud(self)

	# Ensure indicator starts hidden
	targeting_indicator.visible = false

	# Get camera reference once
	_main_camera = get_viewport().get_camera()  # Initial attempt
	if not is_instance_valid(_main_camera) and is_instance_valid(GlobalRefs.main_camera):
		_main_camera = GlobalRefs.main_camera  # Fallback via GlobalRefs

	if not is_instance_valid(_main_camera):
		printerr("MainHUD Error: Could not get a valid camera reference!")
		set_process(false)  # Disable processing if no camera

	# Connect to EventBus signals
	if EventBus:
		if not EventBus.is_connected("player_target_selected", self, "_on_Player_Target_Selected"):
			EventBus.connect("player_target_selected", self, "_on_Player_Target_Selected")
		if not EventBus.is_connected(
			"player_target_deselected", self, "_on_Player_Target_Deselected"
		):
			EventBus.connect("player_target_deselected", self, "_on_Player_Target_Deselected")
	else:
		printerr("MainHUD Error: EventBus not available!")

	# Connect draw signal for custom drawing (optional, but good for style)
	targeting_indicator.connect("draw", self, "_draw_targeting_indicator")


# --- Process Update ---
func _process(delta):
	# Only update position if a target is selected and valid
	if is_instance_valid(_current_target) and is_instance_valid(_main_camera):
		# Project the target's 3D origin position to 2D screen coordinates
		var screen_pos: Vector2 = _main_camera.unproject_position(
			_current_target.global_transform.origin
		)

		# Check if the target is behind the camera
		var target_dir = (_current_target.global_transform.origin - _main_camera.global_transform.origin).normalized()
		var camera_fwd = -_main_camera.global_transform.basis.z.normalized()
		var is_in_front = target_dir.dot(camera_fwd) >= 0  # Use >= 0 to include exactly perpendicular

		# --- MODIFIED Visibility Logic ---
		# Set visibility based on whether the target is in front
		targeting_indicator.visible = is_in_front

		# Only update position and redraw if it's actually visible
		if targeting_indicator.visible:
			# Update the indicator's position
			targeting_indicator.rect_position = screen_pos - (targeting_indicator.rect_size / 2.0)
			targeting_indicator.update()  # Trigger redraw if using _draw
	else:
		# Ensure indicator is hidden if target becomes invalid or camera is invalid
		if targeting_indicator.visible:
			targeting_indicator.visible = false


# --- Signal Handlers ---
func _on_Player_Target_Selected(target_node: Spatial):
	print(target_node)
	if is_instance_valid(target_node):
		_current_target = target_node
		# Visibility is now primarily handled in _process,
		# but we still need to ensure _process runs.
		# targeting_indicator.visible = true # This line can be removed or kept, _process will override
		set_process(true)  # Ensure _process runs
	else:
		_on_Player_Target_Deselected()


func _on_Player_Target_Deselected():
	_current_target = null
	targeting_indicator.visible = false
	set_process(false)  # Can disable processing if target is deselected


# --- Custom Drawing (Optional but Recommended) ---
func _draw_targeting_indicator():
	# Example: Draw a simple white rectangle outline
	var rect = Rect2(Vector2.ZERO, targeting_indicator.rect_size)
	var line_color = Color.white
	var line_width = 1.0  # Adjust thickness as needed
	#targeting_indicator.draw_rect(rect, line_color, false, line_width)

	# Example: Draw simple corner brackets
	var size = targeting_indicator.rect_size
	var corner_len = size.x * 0.25  # Length of corner lines
	var color = Color.cyan
	var width = 2.0
	# # Top-left
	targeting_indicator.draw_line(Vector2(0, 0), Vector2(corner_len, 0), color, width)
	targeting_indicator.draw_line(Vector2(0, 0), Vector2(0, corner_len), color, width)
	# # Top-right
	targeting_indicator.draw_line(Vector2(size.x, 0), Vector2(size.x - corner_len, 0), color, width)
	targeting_indicator.draw_line(Vector2(size.x, 0), Vector2(size.x, corner_len), color, width)
	# # Bottom-left
	targeting_indicator.draw_line(Vector2(0, size.y), Vector2(corner_len, size.y), color, width)
	targeting_indicator.draw_line(Vector2(0, size.y), Vector2(0, size.y - corner_len), color, width)
	# # Bottom-right
	targeting_indicator.draw_line(
		Vector2(size.x, size.y), Vector2(size.x - corner_len, size.y), color, width
	)
	targeting_indicator.draw_line(
		Vector2(size.x, size.y), Vector2(size.x, size.y - corner_len), color, width
	)


# --- Cleanup ---
func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		if EventBus:
			if EventBus.is_connected("player_target_selected", self, "_on_Player_Target_Selected"):
				EventBus.disconnect("player_target_selected", self, "_on_Player_Target_Selected")
			if EventBus.is_connected(
				"player_target_deselected", self, "_on_Player_Target_Deselected"
			):
				EventBus.disconnect(
					"player_target_deselected", self, "_on_Player_Target_Deselected"
				)


func _on_ButtonFreeFlight_pressed():
	if EventBus:
		EventBus.emit_signal("player_free_flight_toggled")


func _on_ButtonStop_pressed():
	if EventBus:
		EventBus.emit_signal("player_stop_pressed")


func _on_ButtonOrbit_pressed():
	if EventBus:
		EventBus.emit_signal("player_orbit_pressed")


func _on_ButtonApproach_pressed():
	if EventBus:
		EventBus.emit_signal("player_approach_pressed")


func _on_ButtonFlee_pressed():
	if EventBus:
		EventBus.emit_signal("player_flee_pressed")


func _on_SliderControlLeft_value_changed(value):
	# ZOOM camera slider
	if EventBus:
		EventBus.emit_signal("player_camera_zoom_changed", value)


func _on_SliderControlRight_value_changed(value):
	# SPEED (maximum) limiter.
	# This slider is inverted (rotated by 180) for the sake of appearance.
	if EventBus:
		EventBus.emit_signal("player_ship_speed_changed", value)

--- Start of ./core/utils/editor_object.gd ---

extends MeshInstance


func _ready():
	self.hide()

--- Start of ./core/utils/pid_controller.gd ---

# File: core/utils/pid_controller.gd
# Version: 1.0
# Purpose: A reusable PID controller class.

extends Node  # Or use 'extends Reference' if node features aren't needed
class_name PIDController

# --- Gains ---
var kp: float = 1.0 setget set_kp
var ki: float = 0.0 setget set_ki
var kd: float = 0.0 setget set_kd

# --- Limits ---
var integral_limit: float = 1000.0 setget set_integral_limit
var output_limit: float = 50.0 setget set_output_limit

# --- State ---
var integral: float = 0.0
var previous_error: float = 0.0


# --- Initialization ---
func initialize(
	p_gain: float, i_gain: float, d_gain: float, i_limit: float = 1000.0, o_limit: float = 50.0
):
	kp = p_gain
	ki = i_gain
	kd = d_gain
	integral_limit = abs(i_limit)  # Ensure positive limit
	output_limit = abs(o_limit)  # Ensure positive limit
	reset()  # Start with a clean state


# --- Update ---
# Calculates the PID output based on the current error and delta time.
# Returns the clamped PID output value.
func update(error: float, delta: float) -> float:
	if delta <= 0.0001:
		# Avoid division by zero or instability with tiny delta
		return 0.0

	# --- Proportional Term ---
	var p_term = kp * error

	# --- Integral Term ---
	integral += error * delta
	# Clamp integral to prevent windup
	integral = clamp(integral, -integral_limit, integral_limit)
	var i_term = ki * integral

	# --- Derivative Term ---
	var derivative = (error - previous_error) / delta
	var d_term = kd * derivative

	# --- Update State for Next Iteration ---
	previous_error = error

	# --- Calculate & Clamp Output ---
	var output = p_term + i_term + d_term
	output = clamp(output, -output_limit, output_limit)

	return output


# --- Reset ---
# Resets the integral and previous error state.
func reset():
	integral = 0.0
	previous_error = 0.0


# --- Setters (Optional, for runtime tweaking if needed) ---
func set_kp(value: float):
	kp = value


func set_ki(value: float):
	ki = value


func set_kd(value: float):
	kd = value


func set_integral_limit(value: float):
	integral_limit = abs(value)


func set_output_limit(value: float):
	output_limit = abs(value)

--- Start of ./core/utils/rotating_object.gd ---

extends MeshInstance

export var rotation_speed = 0.01


# Called every frame. 'delta' is the elapsed time since the previous frame.
func _physics_process(delta):
	self.rotate(Vector3(0, 1, 0), delta * rotation_speed)

--- Start of ./modules/piloting/scripts/player_controller_ship.gd ---

# File: modules/piloting/scripts/player_controller_ship.gd
# Version: 4.1 - Corrected get_world() call for Godot 3 syntax.

extends Node

# --- References ---
var agent_script: Node = null
var agent_body: KinematicBody = null
var movement_system: Node = null
var _main_camera: Camera = null
var _speed_slider: Slider = null

# --- Speed Control ---
var template_max_speed_actual: float = 300.0
var current_target_speed_normalized: float = 1.0
const KEY_SPEED_INCREMENT_NORMALIZED: float = 0.05

# --- State ---
var _current_input_state: InputState = null
var _states = {}
var _target_under_cursor: Spatial = null
var _selected_target: Spatial = null setget _set_selected_target

# --- Preload States ---
const StateBase = preload("res://modules/piloting/scripts/player_input_states/state_base.gd")
const StateDefault = preload("res://modules/piloting/scripts/player_input_states/state_default.gd")
const StateFreeFlight = preload(
	"res://modules/piloting/scripts/player_input_states/state_free_flight.gd"
)


func _ready():
	agent_body = get_parent()
	if not (agent_body is KinematicBody and agent_body.has_method("command_stop")):
		printerr("PlayerController Error: Parent is not a valid agent.")
		set_process(false)
		return

	agent_script = agent_body
	movement_system = agent_body.get_node_or_null("MovementSystem")
	if not is_instance_valid(movement_system):
		printerr("PlayerController Error: MovementSystem not found on agent.")
		set_process(false)
		return

	_states = {"default": StateDefault.new(), "free_flight": StateFreeFlight.new()}

	call_deferred("_deferred_ready_setup")
	_change_state("default")


func _deferred_ready_setup():
	if not is_instance_valid(GlobalRefs.main_hud):
		yield(get_tree().create_timer(0.1), "timeout")
	_speed_slider = GlobalRefs.main_hud.get_node_or_null(
		"ScreenControls/CenterRightZone/SliderControlRight"
	)

	template_max_speed_actual = movement_system.max_move_speed
	current_target_speed_normalized = 1.0
	_update_agent_speed_cap_and_slider_visuals()

	_connect_eventbus_signals()
	call_deferred("_get_camera_reference")


func _get_camera_reference():
	yield(get_tree(), "idle_frame")
	_main_camera = GlobalRefs.main_camera if is_instance_valid(GlobalRefs.main_camera) else null
	if not is_instance_valid(_main_camera):
		printerr("PlayerController Error: Could not find valid Main Camera.")


func _change_state(new_state_name: String):
	if _current_input_state and _current_input_state.has_method("exit"):
		_current_input_state.exit()

	if _states.has(new_state_name):
		_current_input_state = _states[new_state_name]
		if _current_input_state.has_method("enter"):
			_current_input_state.enter(self)
	else:
		printerr("PlayerController Error: Attempted to change to unknown state: ", new_state_name)


func _physics_process(delta: float):
	if _current_input_state and _current_input_state.has_method("physics_update"):
		_current_input_state.physics_update(delta)


func _unhandled_input(event: InputEvent):
	# Global inputs that work in any state
	if Input.is_action_just_pressed("toggle_free_flight"):
		var new_state = "default" if _current_input_state is StateFreeFlight else "free_flight"
		_change_state(new_state)
		get_viewport().set_input_as_handled()
		return

	if Input.is_action_pressed("command_speed_up"):
		var change = KEY_SPEED_INCREMENT_NORMALIZED * event.get_action_strength("command_speed_up")
		current_target_speed_normalized = clamp(current_target_speed_normalized + change, 0.0, 1.0)
		_update_agent_speed_cap_and_slider_visuals()
		get_viewport().set_input_as_handled()
		return

	if Input.is_action_pressed("command_speed_down"):
		var change = (
			KEY_SPEED_INCREMENT_NORMALIZED
			* event.get_action_strength("command_speed_down")
		)
		current_target_speed_normalized = clamp(current_target_speed_normalized - change, 0.0, 1.0)
		_update_agent_speed_cap_and_slider_visuals()
		get_viewport().set_input_as_handled()
		return

	if Input.is_action_just_pressed("command_stop"):
		_issue_stop_command()
		get_viewport().set_input_as_handled()
		return

	if Input.is_action_just_pressed("command_approach"):
		_issue_approach_command()
		get_viewport().set_input_as_handled()
		return
		
	if Input.is_action_just_pressed("command_flee"):
		_issue_flee_command()
		get_viewport().set_input_as_handled()
		return
		
	if Input.is_action_just_pressed("command_orbit"):
		_issue_orbit_command()
		get_viewport().set_input_as_handled()
		return


	# Delegate other inputs to the current state
	if _current_input_state and _current_input_state.has_method("handle_input"):
		_current_input_state.handle_input(event)


# --- Helper & Command Functions (Publicly callable by states) ---
func _update_target_under_cursor():
	_target_under_cursor = _raycast_for_target(get_viewport().get_mouse_position())


func _set_selected_target(new_target: Spatial):
	if _selected_target == new_target:
		return
	_selected_target = new_target
	if is_instance_valid(_selected_target):
		EventBus.emit_signal("player_target_selected", _selected_target)
	else:
		EventBus.emit_signal("player_target_deselected")


func _handle_single_click(_click_pos: Vector2):
	self._selected_target = _target_under_cursor


func _handle_double_click(click_pos: Vector2):
	if is_instance_valid(agent_script) and is_instance_valid(_main_camera):
		var ray_origin = _main_camera.project_ray_origin(click_pos)
		var ray_normal = _main_camera.project_ray_normal(click_pos)
		var target_point = ray_origin + ray_normal * Constants.TARGETING_RAY_LENGTH
		agent_script.command_move_to(target_point)


func _issue_stop_command():
	if not is_instance_valid(agent_script):
		return
	agent_script.command_stop()
	if _current_input_state is StateFreeFlight:
		_change_state("default")
		
func _issue_approach_command():
	if not is_instance_valid(agent_script):
		return
	if EventBus:
		EventBus.emit_signal("player_approach_pressed")
	if _current_input_state is StateFreeFlight:
		_change_state("default")
		
func _issue_flee_command():
	if not is_instance_valid(agent_script):
		return
	if EventBus:
		EventBus.emit_signal("player_flee_pressed")
	if _current_input_state is StateFreeFlight:
		_change_state("default")


func _issue_orbit_command():
	if not is_instance_valid(agent_script):
		return
	if EventBus:
		EventBus.emit_signal("player_orbit_pressed")
	if _current_input_state is StateFreeFlight:
		_change_state("default")

func _update_agent_speed_cap_and_slider_visuals():
	if not is_instance_valid(movement_system):
		return
	var new_cap = lerp(0.0, template_max_speed_actual, current_target_speed_normalized)
	movement_system.max_move_speed = new_cap

	if is_instance_valid(_speed_slider):
		var slider_val = 100.0 - (current_target_speed_normalized * 100.0)
		if not is_equal_approx(_speed_slider.value, slider_val):
			_speed_slider.value = slider_val


func _raycast_for_target(screen_pos: Vector2) -> Spatial:
	if not is_instance_valid(agent_body) or not is_instance_valid(_main_camera):
		return null
	var ray_origin = _main_camera.project_ray_origin(screen_pos)
	var ray_normal = _main_camera.project_ray_normal(screen_pos)
	var ray_end = ray_origin + ray_normal * Constants.TARGETING_RAY_LENGTH
	# --- FIX: Call get_world() from the agent_body node ---
	var space_state = agent_body.get_world().direct_space_state
	var result = space_state.intersect_ray(ray_origin, ray_end, [agent_body], 1)
	return result.collider if result else null


# --- Signal Handlers ---
func _on_Player_Free_Flight_Toggled():
	var new_state = "default" if _current_input_state is StateFreeFlight else "free_flight"
	_change_state(new_state)


func _on_Player_Stop_Pressed():
	_issue_stop_command()


func _on_Player_Orbit_Pressed():
	if is_instance_valid(_selected_target):
		agent_script.command_orbit(_selected_target)


func _on_Player_Approach_Pressed():
	if is_instance_valid(_selected_target):
		agent_script.command_approach(_selected_target)


func _on_Player_Flee_Pressed():
	if is_instance_valid(_selected_target):
		agent_script.command_flee(_selected_target)


func _on_Player_Ship_Speed_Slider_Changed_By_HUD(slider_ui_value: float):
	current_target_speed_normalized = (100.0 - slider_ui_value) / 100.0
	_update_agent_speed_cap_and_slider_visuals()


# --- Connections & Cleanup ---
func _connect_eventbus_signals():
	EventBus.connect("player_free_flight_toggled", self, "_on_Player_Free_Flight_Toggled")
	EventBus.connect("player_stop_pressed", self, "_on_Player_Stop_Pressed")
	EventBus.connect("player_orbit_pressed", self, "_on_Player_Orbit_Pressed")
	EventBus.connect("player_approach_pressed", self, "_on_Player_Approach_Pressed")
	EventBus.connect("player_flee_pressed", self, "_on_Player_Flee_Pressed")
	EventBus.connect(
		"player_ship_speed_changed", self, "_on_Player_Ship_Speed_Slider_Changed_By_HUD"
	)


func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		if EventBus.is_connected(
			"player_free_flight_toggled", self, "_on_Player_Free_Flight_Toggled"
		):
			EventBus.disconnect(
				"player_free_flight_toggled", self, "_on_Player_Free_Flight_Toggled"
			)
		if EventBus.is_connected("player_stop_pressed", self, "_on_Player_Stop_Pressed"):
			EventBus.disconnect("player_stop_pressed", self, "_on_Player_Stop_Pressed")
		if EventBus.is_connected("player_orbit_pressed", self, "_on_Player_Orbit_Pressed"):
			EventBus.disconnect("player_orbit_pressed", self, "_on_Player_Orbit_Pressed")
		if EventBus.is_connected("player_approach_pressed", self, "_on_Player_Approach_Pressed"):
			EventBus.disconnect("player_approach_pressed", self, "_on_Player_Approach_Pressed")
		if EventBus.is_connected("player_flee_pressed", self, "_on_Player_Flee_Pressed"):
			EventBus.disconnect("player_flee_pressed", self, "_on_Player_Flee_Pressed")
		if EventBus.is_connected(
			"player_ship_speed_changed", self, "_on_Player_Ship_Speed_Slider_Changed_By_HUD"
		):
			EventBus.disconnect(
				"player_ship_speed_changed", self, "_on_Player_Ship_Speed_Slider_Changed_By_HUD"
			)

--- Start of ./modules/piloting/scripts/player_input_states/state_base.gd ---

# File: modules/piloting/scripts/player_input_states/state_base.gd
# Base class for all player input states.

class_name InputState
extends Node

var _controller: Node  # Reference to the main player_controller_ship.gd


func enter(controller: Node):
	"""Called when entering this state."""
	_controller = controller


func exit():
	"""Called when exiting this state."""
	pass


func handle_input(_event: InputEvent):
	"""Handles unhandled input events."""
	pass


func physics_update(_delta: float):
	"""Handles physics process logic for this state."""
	pass

--- Start of ./modules/piloting/scripts/player_input_states/state_default.gd ---

# File: modules/piloting/scripts/player_input_states/state_default.gd
# Handles standard flight, targeting, and camera drag input.

extends "res://modules/piloting/scripts/player_input_states/state_base.gd"

# --- Input Tracking State for this mode ---
var _lmb_pressed: bool = false
var _lmb_press_pos: Vector2 = Vector2.ZERO
var _last_tap_time: int = 0
var _is_dragging: bool = false

const DRAG_THRESHOLD_PX_SQ = 10 * 10
const DOUBLE_CLICK_TIME_MS = 400


func enter(controller: Node):
	.enter(controller)
	Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
	if (
		is_instance_valid(_controller._main_camera)
		and _controller._main_camera.has_method("set_is_rotating")
	):
		_controller._main_camera.set_is_rotating(false)
	_lmb_pressed = false
	_is_dragging = false


func physics_update(_delta: float):
	_controller._update_target_under_cursor()


func handle_input(event: InputEvent):
	if event is InputEventMouseButton and event.button_index == BUTTON_LEFT:
		if event.pressed:
			_lmb_pressed = true
			_is_dragging = false
			_lmb_press_pos = event.position
		else:  # Released
			if _lmb_pressed:
				if _is_dragging:
					# Stop camera rotation when drag is released
					if (
						is_instance_valid(_controller._main_camera)
						and _controller._main_camera.has_method("set_is_rotating")
					):
						_controller._main_camera.set_is_rotating(false)
				else:  # Tap/Click
					var time_now = OS.get_ticks_msec()
					if time_now - _last_tap_time <= DOUBLE_CLICK_TIME_MS:
						_controller._handle_double_click(event.position)
						_last_tap_time = 0
					else:
						_controller._handle_single_click(event.position)
						_last_tap_time = time_now
				_lmb_pressed = false
				_is_dragging = false
				_controller.get_viewport().set_input_as_handled()

	elif event is InputEventMouseMotion and _lmb_pressed and not _is_dragging:
		if event.position.distance_squared_to(_lmb_press_pos) > DRAG_THRESHOLD_PX_SQ:
			_is_dragging = true
			if (
				is_instance_valid(_controller._main_camera)
				and _controller._main_camera.has_method("set_is_rotating")
			):
				_controller._main_camera.set_is_rotating(true)
			_controller.get_viewport().set_input_as_handled()

--- Start of ./modules/piloting/scripts/player_input_states/state_free_flight.gd ---

# File: modules/piloting/scripts/player_input_states/state_free_flight.gd
# Handles direct ship orientation and movement input.

extends "res://modules/piloting/scripts/player_input_states/state_base.gd"


func enter(controller: Node):
	.enter(controller)
	Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)
	if (
		is_instance_valid(_controller._main_camera)
		and _controller._main_camera.has_method("set_rotation_input_active")
	):
		_controller._main_camera.set_rotation_input_active(true)


func exit():
	Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
	if (
		is_instance_valid(_controller._main_camera)
		and _controller._main_camera.has_method("set_rotation_input_active")
	):
		_controller._main_camera.set_rotation_input_active(false)


func physics_update(_delta: float):
	if is_instance_valid(_controller._main_camera) and is_instance_valid(_controller.agent_script):
		var move_dir = -_controller._main_camera.global_transform.basis.z.normalized()
		_controller.agent_script.command_move_direction(move_dir)
	elif is_instance_valid(_controller.agent_script):
		_controller.agent_script.command_stop()

--- Start of ./modules/piloting/scripts/ship_controller_ai.gd ---

# File: modules/piloting/scripts/ship_controller_ai.gd
# Attach to Node child of AgentBody in npc_agent.tscn
# Version 2.1 - Simplified for agent command execution model

extends Node

# --- References ---
# Set in _ready()
var agent_script: Node = null  # Reference to the parent agent.gd script instance


# --- Initialization ---
func _ready():
	# Get reference to parent agent script
	var parent = get_parent()
	# Check if parent is the correct type and has the command methods
	if parent is KinematicBody and parent.has_method("command_move_to"):
		agent_script = parent
		# print("AI Controller ready for: ", agent_script.agent_name) # Optional Debug
	else:
		printerr(
			"AI Controller Error: Parent node is not an Agent KinematicBody with command methods!"
		)
		# If setup fails, this controller can't function.
		# We can disable physics process (though it's empty now)
		# or even detach the script to prevent errors.
		set_physics_process(false)
		set_script(null)  # Detach script if parent is wrong


# Called by WorldManager's spawn_agent function (via initialize dictionary in agent.gd)
# The 'config' dictionary here is the 'overrides' passed to spawn_agent
func initialize(config: Dictionary):
	# Ensure agent script reference is valid before issuing command
	if not is_instance_valid(agent_script):
		printerr("AI Initialize Error: Agent script invalid. Cannot issue command.")
		return

	# Read necessary parameters from config dictionary if present
	var stopping_dist = config.get("stopping_distance", 10.0)  # May not be needed by AI now
	# TODO: Agent's MOVE_TO command should probably use its own internal stopping distance logic

	# Immediately issue the initial command based on 'initial_target' in config
	if config.has("initial_target") and config.initial_target is Vector3:
		var target_pos = config.initial_target
		print(agent_script.agent_name, " AI issuing command: MOVE_TO ", target_pos)
		# Call the command method on the agent script
		agent_script.command_move_to(target_pos)
	else:
		# If no target, the agent remains IDLE (its default state)
		if is_instance_valid(agent_script):  # Check again just in case
			print(
				"AI Controller Warning: No initial target provided for ",
				agent_script.agent_name,
				". Agent will remain idle."
			)

# --- No Physics Update Needed ---
# For this simple "go-to" AI, the agent itself executes the command issued
# during initialize. This controller doesn't need to do anything frame-by-frame.
# More complex AI would have state machines here, checking conditions and
# issuing different commands (approach, orbit, flee, etc.) as needed.
# func _physics_process(delta):
#     pass

# --- No Event Handling Needed Here ---
# The agent itself now emits "agent_reached_destination" via EventBus
# when its relevant command (MOVE_TO -> STOPPING -> IDLE) completes.
# WorldManager listens for that signal to trigger the despawn.
# func _handle_target_reached(): # Removed
# func _on_Agent_Reached_Destination(agent_body): # Removed

# --- No Public Functions Needed Here ---
# func set_target(new_target: Vector3): # Removed - command issued once at init

--- Start of ./scenes/camera/camera_particles_controller.gd ---

# File: res://scenes/camera/camera_particles_controller.gd
# Purpose: Controls the space dust (CPUParticles) effect attached to the camera,
#          adjusting emission, velocity, and emitter position based on
#          the CAMERA's movement speed. (GLES2 Compatible)
extends CPUParticles  # Use CPUParticles for GLES2

# --- Tunable Parameters ---
# Camera speed threshold below which particles stop emitting strongly
export var min_camera_speed_threshold: float = 0.5
# Camera speed at which the effect reaches maximum intensity
export var max_camera_speed_for_effect: float = 50.0
# --- NEW: How much to shift emitter opposite to velocity vector ---
export var velocity_offset_scale: float = -250.0

# --- Node References ---
var _camera: Camera = null

# --- State ---
var _previous_camera_pos: Vector3 = Vector3.ZERO
var _initialized: bool = false


func _ready():
	# Get camera reference (assuming this node is a direct child of the camera)
	_camera = get_parent() as Camera
	if not _camera:
		printerr("CameraParticlesController Error: Parent node is not a Camera!")
		set_process(false)
		return

	# Set initial state directly on the node
	self.emitting = false
	self.gravity = Vector3.ZERO
	self.transform.origin = Vector3.ZERO  # Ensure offset starts at zero

	# Defer setting previous position until the first process frame
	# to ensure the camera has its initial position set.
	call_deferred("_initialize_position")


func _initialize_position():
	if is_instance_valid(_camera):
		_previous_camera_pos = _camera.global_transform.origin
		_initialized = true
		#print("CameraParticlesController Initialized.")
	else:
		printerr("CameraParticlesController Error: Camera invalid during deferred init.")
		set_process(false)


func _process(delta: float):
	# Ensure camera is valid and initialized
	if not _initialized or not is_instance_valid(_camera):
		# Keep particles off if camera isn't ready
		if self.emitting:
			self.emitting = false
		if self.gravity != Vector3.ZERO:
			self.gravity = Vector3.ZERO
		# Reset offset if camera becomes invalid
		if self.transform.origin != Vector3.ZERO:
			self.transform.origin = Vector3.ZERO
		return

	# --- Calculate Camera Movement ---
	var current_pos: Vector3 = _camera.global_transform.origin
	# Vector representing the camera's displacement over the last frame in global space
	var position_delta_global: Vector3 = current_pos - _previous_camera_pos
	var camera_speed: float = 0.0

	if delta > 0.0001:  # Avoid division by zero or large spikes on first frame/lag
		camera_speed = position_delta_global.length() / delta

	# Store current position for the next frame's calculation
	_previous_camera_pos = current_pos

	# --- Apply Velocity Offset ---
	# Calculate the desired offset in the opposite direction of the global movement.
	# Since this script/node is a child of the camera, we need to transform the global
	# offset direction into the camera's local space before applying it.
	var global_offset_vector = -position_delta_global * velocity_offset_scale
	# Transform the global offset vector into the camera's local coordinate system
	var local_offset_vector = _camera.global_transform.basis.xform_inv(global_offset_vector)

	# Set the local position offset of this CPUParticles node
	self.transform.origin = local_offset_vector

	# --- Control Emission (based on speed) ---
	if camera_speed > min_camera_speed_threshold:
		if not self.emitting:
			self.emitting = true
	else:
		if self.emitting:
			self.emitting = false

--- Start of ./scenes/camera/components/camera_position_controller.gd ---

# File: scenes/camera/components/camera_position_controller.gd
# Version: 1.1 - Added a smoothed target position to reduce jerk on rapid velocity changes.
# Purpose: Manages camera positioning, smoothing, and bobbing effect.

extends Node
class_name CameraPositionController

# --- References ---
var _camera: Camera = null
var _target: Spatial = null
var _rotation_controller: CameraRotationController = null
var _zoom_controller: CameraZoomController = null

# --- Configuration ---
var position_smoothing_speed: float = 18.0
var rotation_smoothing_speed: float = 18.0
var bob_frequency: float = 0.1
var bob_amplitude: float = 0.2
# NEW: How quickly the camera's anchor point follows the ship. Lower values are smoother.
var target_smoothing_speed: float = 15.0 

# --- State ---
var _bob_timer: float = 0.0
# NEW: This will be the point the camera actually tries to follow.
var _smoothed_target_pos: Vector3 = Vector3.ZERO


# --- Initialization ---
func initialize(camera_node: Camera, rot_ctrl: Node, zoom_ctrl: Node, config: Dictionary):
	_camera = camera_node
	_rotation_controller = rot_ctrl
	_zoom_controller = zoom_ctrl
	
	# Set configuration from the main camera script
	position_smoothing_speed = config.get("position_smoothing_speed", position_smoothing_speed)
	rotation_smoothing_speed = config.get("rotation_smoothing_speed", rotation_smoothing_speed)
	bob_frequency = config.get("bob_frequency", bob_frequency)
	bob_amplitude = config.get("bob_amplitude", bob_amplitude)
	target_smoothing_speed = config.get("target_smoothing_speed", target_smoothing_speed)


# --- Public Methods ---
func set_target(new_target: Spatial):
	_target = new_target
	# When the target changes, immediately snap the smoothed position to it.
	if is_instance_valid(_target):
		_smoothed_target_pos = _target.global_transform.origin

func physics_update(delta: float):
	_bob_timer += delta
	
	if not is_instance_valid(_target):
		# Detached Mode
		var new_basis = Basis().rotated(Vector3.UP, _rotation_controller.yaw).rotated(
			Basis().rotated(Vector3.UP, _rotation_controller.yaw).x, _rotation_controller.pitch
		)
		_camera.global_transform.basis = new_basis.orthonormalized()
		return

	# --- Attached Mode ---
	var actual_target_pos = _target.global_transform.origin
	
	# --- SMOOTHING LOGIC ---
	# Instead of using the actual target position directly, we lerp our
	# internal "smoothed" position towards it. This dampens any sudden jumps.
	_smoothed_target_pos = _smoothed_target_pos.linear_interpolate(
		actual_target_pos, target_smoothing_speed * delta
	)
	# --- END SMOOTHING LOGIC ---

	var bob_offset = (
		_camera.global_transform.basis.y
		* sin(_bob_timer * bob_frequency * TAU)
		* bob_amplitude
	)

	var desired_basis = Basis().rotated(Vector3.UP, _rotation_controller.yaw).rotated(
		Basis().rotated(Vector3.UP, _rotation_controller.yaw).x, _rotation_controller.pitch
	)

	# Calculate desired position relative to the SMOOTHED target position
	var position_offset = -desired_basis.z * _zoom_controller.current_distance
	var desired_position = _smoothed_target_pos + position_offset + bob_offset

	# Interpolate Camera's actual position
	_camera.global_transform.origin = _camera.global_transform.origin.linear_interpolate(
		desired_position, position_smoothing_speed * delta
	)

	# Interpolate Look At to point towards the SMOOTHED target position
	var target_look_transform = _camera.global_transform.looking_at(_smoothed_target_pos, Vector3.UP)
	_camera.global_transform.basis = _camera.global_transform.basis.slerp(
		target_look_transform.basis.orthonormalized(), rotation_smoothing_speed * delta
	)

--- Start of ./scenes/camera/components/camera_rotation_controller.gd ---

# File: scenes/camera/components/camera_rotation_controller.gd
# Purpose: Manages camera rotation, including PID-based smoothing and mouse input.
# This is a component of the main OrbitCamera.

extends Node
class_name CameraRotationController

# --- References ---
var _camera: Camera = null
var _yaw_pid: PIDController = null
var _pitch_pid: PIDController = null
const PIDControllerScript = preload("res://core/utils/pid_controller.gd")

# --- Configuration (Copied from OrbitCamera) ---
var pitch_min: float = -1.45
var pitch_max: float = 1.45
var pid_yaw_kp: float = 10.0
var pid_yaw_ki: float = 0.01
var pid_yaw_kd: float = 0.1
var pid_pitch_kp: float = 10.0
var pid_pitch_ki: float = 0.01
var pid_pitch_kd: float = 0.1
var pid_integral_limit: float = 10.0
var pid_output_limit_multiplier: float = 100.0
var _rotation_max_speed: float = 15.0
var _rotation_input_curve: float = 1.1

# --- State ---
var yaw: float = PI
var pitch: float = 0.25
var _rotation_input_active: bool = false
var _is_externally_rotating: bool = false
var _target_yaw_speed: float = 0.0
var _target_pitch_speed: float = 0.0
var _current_yaw_speed: float = 0.0
var _current_pitch_speed: float = 0.0


# --- Initialization ---
func initialize(camera_node: Camera, config: Dictionary):
	_camera = camera_node
	
	# Set configuration from the main camera script
	pitch_min = config.get("pitch_min", pitch_min)
	pitch_max = config.get("pitch_max", pitch_max)
	pid_yaw_kp = config.get("pid_yaw_kp", pid_yaw_kp)
	pid_yaw_ki = config.get("pid_yaw_ki", pid_yaw_ki)
	pid_yaw_kd = config.get("pid_yaw_kd", pid_yaw_kd)
	pid_pitch_kp = config.get("pid_pitch_kp", pid_pitch_kp)
	pid_pitch_ki = config.get("pid_pitch_ki", pid_pitch_ki)
	pid_pitch_kd = config.get("pid_pitch_kd", pid_pitch_kd)
	pid_integral_limit = config.get("pid_integral_limit", pid_integral_limit)
	pid_output_limit_multiplier = config.get("pid_output_limit_multiplier", pid_output_limit_multiplier)
	_rotation_max_speed = config.get("_rotation_max_speed", _rotation_max_speed)
	_rotation_input_curve = config.get("_rotation_input_curve", _rotation_input_curve)
	
	yaw = config.get("initial_yaw", PI)
	pitch = config.get("initial_pitch", 0.25)

	# Instantiate and Initialize PID Controllers
	if PIDControllerScript:
		_yaw_pid = PIDControllerScript.new()
		_pitch_pid = PIDControllerScript.new()
		add_child(_yaw_pid) # Ensure it's freed with the node
		add_child(_pitch_pid)

		var output_limit = _rotation_max_speed * pid_output_limit_multiplier
		_yaw_pid.initialize(pid_yaw_kp, pid_yaw_ki, pid_yaw_kd, pid_integral_limit, output_limit)
		_pitch_pid.initialize(pid_pitch_kp, pid_pitch_ki, pid_pitch_kd, pid_integral_limit, output_limit)
	else:
		printerr("CameraRotationController Error: Failed to preload PIDController script!")


# --- Public Methods ---
func handle_input(event: InputEvent):
	if event is InputEventMouseMotion:
		if _rotation_input_active or _is_externally_rotating:
			var input_x = event.relative.x
			var input_y = event.relative.y

			var strength_x = pow(abs(input_x), _rotation_input_curve) * sign(input_x)
			var strength_y = pow(abs(input_y), _rotation_input_curve) * sign(input_y)

			var input_scale_factor = 0.01
			_target_yaw_speed = -strength_x * input_scale_factor * _rotation_max_speed
			_target_pitch_speed = -strength_y * input_scale_factor * _rotation_max_speed

			_target_yaw_speed = clamp(_target_yaw_speed, -_rotation_max_speed, _rotation_max_speed)
			_target_pitch_speed = clamp(_target_pitch_speed, -_rotation_max_speed, _rotation_max_speed)

			get_viewport().set_input_as_handled()

func physics_update(delta: float):
	if not is_instance_valid(_yaw_pid) or not is_instance_valid(_pitch_pid):
		return

	var rot_active = _rotation_input_active or _is_externally_rotating
	if not rot_active:
		_target_yaw_speed = 0.0
		_target_pitch_speed = 0.0

	var error_yaw = _target_yaw_speed - _current_yaw_speed
	var error_pitch = _target_pitch_speed - _current_pitch_speed

	var yaw_accel = _yaw_pid.update(error_yaw, delta)
	var pitch_accel = _pitch_pid.update(error_pitch, delta)

	_current_yaw_speed += yaw_accel * delta
	_current_pitch_speed += pitch_accel * delta

	yaw += _current_yaw_speed * delta
	pitch -= _current_pitch_speed * delta
	pitch = clamp(pitch, pitch_min, pitch_max)

	_target_yaw_speed = 0.0
	_target_pitch_speed = 0.0

func set_rotation_input_active(is_active: bool):
	_rotation_input_active = is_active
	if is_active:
		_is_externally_rotating = false
	reset_pids()

func set_is_rotating(rotating: bool):
	if not _rotation_input_active:
		_is_externally_rotating = rotating
	reset_pids()

func reset_pids():
	if is_instance_valid(_yaw_pid): _yaw_pid.reset()
	if is_instance_valid(_pitch_pid): _pitch_pid.reset()
	_current_yaw_speed = 0.0
	_current_pitch_speed = 0.0

--- Start of ./scenes/camera/components/camera_zoom_controller.gd ---

# File: scenes/camera/components/camera_zoom_controller.gd
# Purpose: Manages camera zoom, distance from target, and FoV calculations.
# This is a component of the main OrbitCamera.

extends Node
class_name CameraZoomController

# --- References ---
var _camera: Camera = null
var _target: Spatial = null

# --- Configuration ---
var distance: float = 55.0
var min_distance_multiplier: float = 3.0
var max_distance_multiplier: float = 30.0
var preferred_distance_multiplier: float = 3.0
const MIN_ABSOLUTE_DISTANCE = 1.0
const MAX_ABSOLUTE_DISTANCE = 500.0
var zoom_speed: float = 0.5
var _min_fov_deg: float = 70.0
var _max_fov_deg: float = 80.0

# --- State ---
var current_distance: float = 55.0
var _target_radius: float = 15.0
var _is_programmatically_setting_slider: bool = false


# --- Initialization ---
func initialize(camera_node: Camera, config: Dictionary):
	_camera = camera_node
	
	# Set configuration from the main camera script
	distance = config.get("distance", distance)
	min_distance_multiplier = config.get("min_distance_multiplier", min_distance_multiplier)
	max_distance_multiplier = config.get("max_distance_multiplier", max_distance_multiplier)
	preferred_distance_multiplier = config.get("preferred_distance_multiplier", preferred_distance_multiplier)
	zoom_speed = config.get("zoom_speed", zoom_speed)
	_min_fov_deg = config.get("_min_fov_deg", _min_fov_deg)
	_max_fov_deg = config.get("_max_fov_deg", _max_fov_deg)
	
	current_distance = distance
	
	# Connect to EventBus signals
	if EventBus and not EventBus.is_connected("player_camera_zoom_changed", self, "_on_player_camera_zoom_changed"):
		EventBus.connect("player_camera_zoom_changed", self, "_on_player_camera_zoom_changed")


# --- Public Methods ---
func handle_input(event: InputEvent):
	if event is InputEventMouseButton and is_instance_valid(_target):
		var zoom_factor = 1.0 + (zoom_speed * 0.1)
		var input_handled = false
		var new_distance_candidate = current_distance

		if event.button_index == BUTTON_WHEEL_UP and event.pressed:
			new_distance_candidate = current_distance / zoom_factor
			input_handled = true
		elif event.button_index == BUTTON_WHEEL_DOWN and event.pressed:
			new_distance_candidate = current_distance * zoom_factor
			input_handled = true

		if input_handled:
			_set_and_update_zoom_distance(new_distance_candidate, false)
			get_viewport().set_input_as_handled()

func physics_update():
	# Update FoV based on current distance
	if is_instance_valid(_target):
		_update_fov()

func set_target(new_target: Spatial):
	_target = new_target
	if is_instance_valid(_target):
		_target_radius = _get_target_effective_radius(_target)
		# Reset distance to preferred when target changes
		var dyn_min_dist = _get_dynamic_min_distance()
		var dyn_max_dist = _get_dynamic_max_distance()
		var preferred_dist = max(dyn_min_dist, _target_radius * preferred_distance_multiplier)
		_set_and_update_zoom_distance(clamp(preferred_dist, dyn_min_dist, dyn_max_dist), false)
	else:
		_target_radius = 10.0
	
	_update_fov()


# --- Signal Handlers ---
func _on_player_camera_zoom_changed(value):
	if _is_programmatically_setting_slider:
		return

	var dyn_min_dist = _get_dynamic_min_distance()
	var dyn_max_dist = _get_dynamic_max_distance()
	var target_distance = lerp(dyn_min_dist, dyn_max_dist, value / 100.0)

	_set_and_update_zoom_distance(target_distance, true)


# --- Private Helper Methods ---
func _set_and_update_zoom_distance(new_distance: float, from_slider_event: bool = false):
	var dyn_min_dist = _get_dynamic_min_distance()
	var dyn_max_dist = _get_dynamic_max_distance()
	
	current_distance = clamp(new_distance, dyn_min_dist, dyn_max_dist)

	if not from_slider_event and is_instance_valid(GlobalRefs.main_hud):
		var zoom_slider = GlobalRefs.main_hud.get_node("ScreenControls/CenterLeftZone/SliderControlLeft")
		if is_instance_valid(zoom_slider):
			var zoom_range = dyn_max_dist - dyn_min_dist
			var normalized_value = 0.0
			if zoom_range > 0.001:
				normalized_value = 100.0 * (current_distance - dyn_min_dist) / zoom_range
			
			_is_programmatically_setting_slider = true
			zoom_slider.value = clamp(normalized_value, 0.0, 100.0)
			_is_programmatically_setting_slider = false

func _update_fov():
	var dyn_min_dist = _get_dynamic_min_distance()
	var dyn_max_dist = _get_dynamic_max_distance()
	if is_equal_approx(dyn_max_dist, dyn_min_dist):
		_camera.fov = _max_fov_deg
		return
	var t = clamp((current_distance - dyn_min_dist) / (dyn_max_dist - dyn_min_dist), 0.0, 1.0)
	_camera.fov = lerp(_min_fov_deg, _max_fov_deg, t)

func _get_dynamic_min_distance() -> float:
	if not is_instance_valid(_target):
		return MIN_ABSOLUTE_DISTANCE
	return max(MIN_ABSOLUTE_DISTANCE, _target_radius * min_distance_multiplier)

func _get_dynamic_max_distance() -> float:
	if not is_instance_valid(_target):
		return MAX_ABSOLUTE_DISTANCE
	var dyn_min_dist = _get_dynamic_min_distance()
	var dyn_max_calc = max(dyn_min_dist + 1.0, _target_radius * max_distance_multiplier)
	return min(MAX_ABSOLUTE_DISTANCE, dyn_max_calc)

func _get_target_effective_radius(target_node: Spatial) -> float:
	var default_radius = 10.0
	if not is_instance_valid(target_node):
		return default_radius
	if target_node.has_method("get_interaction_radius"):
		var radius = target_node.get_interaction_radius()
		if (radius is float or radius is int) and radius > 0.0:
			return max(float(radius), 1.0)
	var node_scale = target_node.global_transform.basis.get_scale()
	var max_scale = max(node_scale.x, max(node_scale.y, node_scale.z))
	return max(max_scale / 2.0, default_radius)

func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		if EventBus and EventBus.is_connected("player_camera_zoom_changed", self, "_on_player_camera_zoom_changed"):
			EventBus.disconnect("player_camera_zoom_changed", self, "_on_player_camera_zoom_changed")

--- Start of ./scenes/camera/orbit_camera.gd ---

# File: scenes/camera/orbit_camera.gd
# Version: 2.2 - Removed all export variables to internalize configuration.

extends Camera

# --- INTERNAL CONFIGURATION ---
# All tuning is now done directly in this script.

# --- General ---
var distance: float = 55.0
var position_smoothing_speed: float = 18.0
var rotation_smoothing_speed: float = 18.0
var target_smoothing_speed: float = 20.0
var bob_frequency: float = 0.1
var bob_amplitude: float = 0.2

# --- Zoom & FoV ---
var zoom_speed: float = 0.5
var min_distance_multiplier: float = 3.0
var max_distance_multiplier: float = 30.0
var preferred_distance_multiplier: float = 3.0
var min_fov_deg: float = 70.0
var max_fov_deg: float = 80.0

# --- Rotation & PID ---
var pitch_min_deg: float = -83.0
var pitch_max_deg: float = 83.0
var rotation_max_speed: float = 15.0
var rotation_input_curve: float = 1.1
var pid_yaw_kp: float = 10.0
var pid_yaw_ki: float = 0.01
var pid_yaw_kd: float = 0.1
var pid_pitch_kp: float = 10.0
var pid_pitch_ki: float = 0.01
var pid_pitch_kd: float = 0.1
var pid_integral_limit: float = 10.0
var pid_output_limit_multiplier: float = 100.0

# --- Component Script Paths ---
const RotationControllerScript = preload("res://scenes/camera/components/camera_rotation_controller.gd")
const ZoomControllerScript = preload("res://scenes/camera/components/camera_zoom_controller.gd")
const PositionControllerScript = preload("res://scenes/camera/components/camera_position_controller.gd")

# --- Component Instances ---
var _rotation_controller: Node = null
var _zoom_controller: Node = null
var _position_controller: Node = null


# --- Initialization ---
func _ready():
	set_as_toplevel(true)
	GlobalRefs.main_camera = self
	
	# --- Instantiate and Initialize Components ---
	_rotation_controller = RotationControllerScript.new()
	_zoom_controller = ZoomControllerScript.new()
	_position_controller = PositionControllerScript.new()
	
	_rotation_controller.name = "RotationController"
	_zoom_controller.name = "ZoomController"
	_position_controller.name = "PositionController"
	
	add_child(_rotation_controller)
	add_child(_zoom_controller)
	add_child(_position_controller)

	# Package all internal vars into a config dictionary to pass to components
	var config = {
		"distance": distance,
		"position_smoothing_speed": position_smoothing_speed,
		"rotation_smoothing_speed": rotation_smoothing_speed,
		"target_smoothing_speed": target_smoothing_speed,
		"bob_frequency": bob_frequency,
		"bob_amplitude": bob_amplitude,
		"zoom_speed": zoom_speed,
		"min_distance_multiplier": min_distance_multiplier,
		"max_distance_multiplier": max_distance_multiplier,
		"preferred_distance_multiplier": preferred_distance_multiplier,
		"min_fov_deg": min_fov_deg,
		"max_fov_deg": max_fov_deg,
		"pitch_min": deg2rad(pitch_min_deg),
		"pitch_max": deg2rad(pitch_max_deg),
		"_rotation_max_speed": rotation_max_speed,
		"_rotation_input_curve": rotation_input_curve,
		"pid_yaw_kp": pid_yaw_kp,
		"pid_yaw_ki": pid_yaw_ki,
		"pid_yaw_kd": pid_yaw_kd,
		"pid_pitch_kp": pid_pitch_kp,
		"pid_pitch_ki": pid_pitch_ki,
		"pid_pitch_kd": pid_pitch_kd,
		"pid_integral_limit": pid_integral_limit,
		"pid_output_limit_multiplier": pid_output_limit_multiplier,
		"initial_yaw": PI,
		"initial_pitch": 0.25
	}
	
	_rotation_controller.initialize(self, config)
	_zoom_controller.initialize(self, config)
	_position_controller.initialize(self, _rotation_controller, _zoom_controller, config)
	
	# --- Connect Signals ---
	if EventBus and not EventBus.is_connected("camera_set_target_requested", self, "_on_camera_set_target_requested"):
		EventBus.connect("camera_set_target_requested", self, "_on_camera_set_target_requested")
	
	# Proactive player check
	if is_instance_valid(GlobalRefs.player_agent_body):
		set_target_node(GlobalRefs.player_agent_body)


# --- Delegate Godot Functions to Components ---
func _unhandled_input(event):
	_rotation_controller.handle_input(event)
	_zoom_controller.handle_input(event)

func _physics_process(delta):
	_rotation_controller.physics_update(delta)
	_zoom_controller.physics_update()
	_position_controller.physics_update(delta)


# --- Public Methods (Delegating to Components) ---
func set_target_node(new_target: Spatial):
	if not is_instance_valid(_zoom_controller) or not is_instance_valid(_position_controller):
		return
	# When the target changes, inform the relevant components.
	_zoom_controller.set_target(new_target)
	_position_controller.set_target(new_target)
	print("OrbitCamera target set to: ", new_target.name if new_target else "null")


func set_rotation_input_active(is_active: bool):
	if is_instance_valid(_rotation_controller):
		_rotation_controller.set_rotation_input_active(is_active)

func set_is_rotating(rotating: bool):
	if is_instance_valid(_rotation_controller):
		_rotation_controller.set_is_rotating(rotating)


# --- Signal Handlers ---
func _on_camera_set_target_requested(target_node):
	set_target_node(target_node)


# --- Cleanup ---
func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		if EventBus and EventBus.is_connected("camera_set_target_requested", self, "_on_camera_set_target_requested"):
			EventBus.disconnect("camera_set_target_requested", self, "_on_camera_set_target_requested")
		if GlobalRefs and GlobalRefs.main_camera == self:
			GlobalRefs.main_camera = null

--- Start of ./scenes/game_world/world_manager.gd ---

# File: scenes/game_world/world_manager.gd
# Version: 3.0 (Refactored) - Handles zone management only. Agent spawning is delegated.

extends Node

# --- State ---
var current_zone_instance: Node = null
var _spawned_agent_bodies = []  # This list can now be managed by a future system if needed.


# --- Initialization ---
func _ready():
	GlobalRefs.world_manager = self
	# Connect to agent signals to keep the local list clean.
	EventBus.connect("agent_spawned", self, "_on_Agent_Spawned")
	EventBus.connect("agent_despawning", self, "_on_Agent_Despawning")

	randomize()
	load_zone(Constants.INITIAL_ZONE_SCENE_PATH)


# --- Zone Management ---
func load_zone(zone_scene_path: String):
	if not zone_scene_path or zone_scene_path.empty():
		printerr("WM Error: Invalid zone path provided.")
		return

	# 1. Cleanup Previous Zone
	if is_instance_valid(current_zone_instance):
		EventBus.emit_signal("zone_unloading", current_zone_instance)
		# Clear references that will be repopulated on new zone load
		_spawned_agent_bodies.clear()
		GlobalRefs.player_agent_body = null
		GlobalRefs.current_zone = null
		GlobalRefs.agent_container = null
		current_zone_instance.queue_free()
		current_zone_instance = null

	# 2. Find Parent Container Node
	var zone_holder = get_parent().get_node_or_null(Constants.CURRENT_ZONE_CONTAINER_NAME)
	if not is_instance_valid(zone_holder):
		printerr("WM Error: Could not find valid zone holder node!")
		return

	# 3. Load and Instance the Zone Scene
	var zone_scene = load(zone_scene_path)
	if not zone_scene:
		printerr("WM Error: Failed to load Zone Scene Resource: ", zone_scene_path)
		return

	current_zone_instance = zone_scene.instance()
	zone_holder.add_child(current_zone_instance)
	GlobalRefs.current_zone = current_zone_instance

	# 4. Find Agent Container and emit signal that the zone is ready
	var agent_container = current_zone_instance.find_node(
		Constants.AGENT_CONTAINER_NAME, true, false
	)
	GlobalRefs.agent_container = agent_container

	EventBus.emit_signal("zone_loaded", current_zone_instance, zone_scene_path, agent_container)


# --- Signal Handlers to maintain agent list ---
func _on_Agent_Spawned(agent_body, _init_data):
	if not _spawned_agent_bodies.has(agent_body):
		_spawned_agent_bodies.append(agent_body)


func _on_Agent_Despawning(agent_body):
	if _spawned_agent_bodies.has(agent_body):
		_spawned_agent_bodies.erase(agent_body)


func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		if GlobalRefs and GlobalRefs.world_manager == self:
			GlobalRefs.world_manager = null
		if EventBus.is_connected("agent_spawned", self, "_on_Agent_Spawned"):
			EventBus.disconnect("agent_spawned", self, "_on_Agent_Spawned")
		if EventBus.is_connected("agent_despawning", self, "_on_Agent_Despawning"):
			EventBus.disconnect("agent_despawning", self, "_on_Agent_Despawning")

--- Start of ./scenes/main_menu/SettingsRendering.gd ---

extends Control

var _viewport_size = Vector2(1920, 1080)


# Called when the node enters the scene tree for the first time.
func _ready():
	_viewport_size = get_viewport().size

# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass
